{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to Artinet SDK!","text":""},{"location":"index.html#what-is-the-artinet-sdk","title":"What is the Artinet SDK?","text":"<p>The Artinet SDK is a robust implementation of the Agent2Agent (A2A) Protocol that enables developers to create and connect AI agents. Written in TypeScript, this SDK provides everything you need to build, deploy, and interact with A2A-compliant agents.</p>"},{"location":"index.html#key-features","title":"Key Features","text":"<ul> <li>Production-Ready: Built with a focus on developer experience, reliability, and comprehensive features.</li> <li>Plug-and-Play Server: Built on Express.js, the SDK handles JSON-RPC complexity, routing, protocol compliance, and streaming mechanics automatically.</li> <li>Enhanced Client: Features refined error handling, flexible header management for authentication, and clear separation of concerns.</li> <li>TypeScript First: Fully written in TypeScript with comprehensive type definitions for a robust developer experience.</li> <li>Flexible Storage: Choose between memory storage for development or file-based persistence for production.</li> <li>Server Registration: Easily register your agents with the A2A registry for discovery.</li> </ul>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<pre><code># Install the SDK\nnpm install @artinet/sdk\n</code></pre> <p>Create your first agent in just a few lines of code:</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Define your agent logic\nconst myAgentLogic: TaskHandler = async function* (context: TaskContext) {\n  yield { state: \"working\" };\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Hello from Artinet!\" }],\n    },\n  };\n};\n\n// Start your server\nconst server = new A2AServer({\n  handler: myAgentLogic,\n  taskStore: new InMemoryTaskStore(),\n  port: 3000,\n  basePath: \"/a2a\",\n  card: {\n    name: \"My First Agent\",\n    url: \"http://localhost:3000/a2a\",\n    version: \"0.1.0\",\n    capabilities: { streaming: true },\n    skills: [{ id: \"greeting\", name: \"Greeting Skill\" }],\n  },\n});\n\nserver.start();\nconsole.log(\"Agent running at http://localhost:3000/a2a\");\n</code></pre>"},{"location":"index.html#why-use-artinet-sdk","title":"Why Use Artinet SDK?","text":"<ul> <li>A2A Protocol Compliance: Full implementation of the official A2A specification using the official JSON schema.</li> <li>Robust Streaming: Reliable Server-Sent Events (SSE) support for real-time communication.</li> <li>Configurable Logging: Integrated structured logging via <code>pino</code> with configurable levels.</li> <li>Advanced Customization: Fine-grained control over the JSON-RPC server, enabling integration with existing Express apps or adding custom methods.</li> <li>Comprehensive Testing: Includes a robust test suite to ensure reliability and maintainability.</li> <li>Agent Discovery: Support for registering agents with the A2A registry for discovery.</li> </ul>"},{"location":"index.html#next-steps","title":"Next Steps","text":"<p>Ready to dive deeper? Check out these resources:</p> <ul> <li>Quick Start Guide - Get up and running with a complete agent example</li> <li>Core Components - Understand the fundamental building blocks of the SDK</li> <li>Examples - Explore common usage patterns and scenarios</li> <li>API Reference - Detailed documentation of all classes and methods</li> <li>Quick Agents - Learn about bundling and testing agent deployments</li> </ul>"},{"location":"versions.html","title":"Version History","text":"<p>This page documents the version history of the Artinet SDK, highlighting breaking changes and important updates that may affect your integration.</p>"},{"location":"versions.html#migration-guides","title":"Migration Guides","text":""},{"location":"versions.html#03x-to-050-migration","title":"0.3.x to 0.5.0 Migration","text":"<p>If you're upgrading from 0.3.x to 0.5.0, be aware of the following breaking changes:</p> <ol> <li> <p>SystemError Constructor: The <code>data</code> parameter in the <code>SystemError</code> constructor and all specific error factory functions (e.g., <code>PARSE_ERROR()</code>, <code>INVALID_PARAMS()</code>, <code>TASK_NOT_FOUND()</code>) is now mandatory.</p> </li> <li> <p>Express Server Refactoring: The <code>createExpressServer</code> utility has been refactored:</p> </li> <li>No longer accepts a <code>port</code> parameter.</li> <li>No longer creates or returns an <code>http.Server</code> instance.</li> <li> <p>Server starting is now handled within <code>A2AServer.start()</code> only.</p> </li> <li> <p>Type Definition Changes: Optional properties are now defined using <code>type?</code> instead of <code>type | null</code>.</p> </li> <li> <p>Task Status Initialization: When a task is initiated, the initial task status no longer includes a <code>message: null</code> field.</p> </li> <li> <p>Error Messaging: Generic <code>METHOD_NOT_FOUND()</code> errors have been replaced with more specific <code>PUSH_NOTIFICATION_NOT_SUPPORTED()</code> errors.</p> </li> </ol>"},{"location":"versions.html#detailed-version-history","title":"Detailed Version History","text":""},{"location":"versions.html#changelog","title":"Changelog","text":"<p>All notable changes to the @artinet/sdk package will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"versions.html#050-2025-05-10","title":"[0.5.0] - 2025-05-10","text":""},{"location":"versions.html#added","title":"Added","text":"<ul> <li><code>A2AServer.getExpressApp()</code>: New method to access the underlying Express application instance, allowing for more flexible server customization and middleware integration.</li> <li>More specific error messages for various RPC errors (e.g., <code>TASK_NOT_FOUND</code>, <code>INVALID_PARAMS</code>, <code>PARSE_ERROR</code>), providing better debugging information and context.</li> </ul>"},{"location":"versions.html#changed","title":"Changed","text":"<ul> <li>BREAKING: The <code>data</code> parameter in the <code>SystemError</code> constructor and all specific error factory functions (e.g., <code>PARSE_ERROR()</code>, <code>INVALID_PARAMS()</code>, <code>TASK_NOT_FOUND()</code>) is now mandatory. This change aims to enhance error reporting by ensuring contextual information is always provided with errors.</li> <li>BREAKING: Refactored the <code>createExpressServer</code> utility (<code>src/server/lib/express-server.ts</code>):<ul> <li>It no longer accepts a <code>port</code> parameter.</li> <li>It no longer creates or returns an <code>http.Server</code> instance (i.e., it doesn't call <code>app.listen()</code>). It now solely configures and returns the Express <code>app</code> instance.</li> <li>The responsibility of starting the HTTP server is now fully handled within the <code>A2AServer.start()</code> method, which uses the <code>app</code> configured by <code>createExpressServer</code>.</li> </ul> </li> <li>Updated numerous TypeScript type definitions in <code>src/types/schema.ts</code> to more strictly define optional properties. Many properties that were previously <code>type | null</code> are now just <code>type?</code>, and JSDoc <code>@default null</code> comments have been removed. This aligns with standard TypeScript practices where optional properties are either present with a value or absent (undefined), rather than being explicitly <code>null</code>.</li> <li>When a task is initiated via <code>A2AServer.sendTaskAndStore()</code>, the initial task status (<code>Task.status</code>) no longer includes a <code>message: null</code> field.</li> <li>In <code>src/server/lib/state.ts</code>, when creating a new task object during <code>loadState</code>, <code>sessionId</code> and <code>metadata</code> properties are assigned directly if provided, without defaulting to <code>null</code> if they are undefined.</li> <li>Replaced generic <code>METHOD_NOT_FOUND()</code> errors with more specific <code>PUSH_NOTIFICATION_NOT_SUPPORTED()</code> errors in <code>defaultSetTaskPushNotificationMethod</code> and <code>defaultGetTaskPushNotificationMethod</code> when the agent's card indicates that push notifications are not supported.</li> </ul>"},{"location":"versions.html#removed","title":"Removed","text":"<ul> <li>The test file <code>tests/deployment.test.ts</code> has been removed. The <code>testDeployment</code> utility and related \"Quick-Agents\" features remain.</li> </ul>"},{"location":"versions.html#improved","title":"Improved","text":"<ul> <li>The documentation section in <code>README.md</code> regarding agent code deployment has been renamed from \"Agent Code Deployment (Beta)\" to \"Quick-Agents (Alpha)\". This section includes updated descriptions, code examples for bundling and testing agents, and a new FAQ.</li> <li>Server startup logging in <code>A2AServer</code> now consistently uses <code>logInfo</code> for messages like \"A2A Server started and listening\".</li> </ul>"},{"location":"versions.html#041-2025-05-08","title":"[0.4.1] - 2025-05-08","text":""},{"location":"versions.html#added_1","title":"Added","text":"<ul> <li>Utility for bundling agent code using <code>esbuild</code> (<code>src/utils/deployment/bundler.ts</code>).</li> <li>Task handler wrapper (<code>taskHandlerProxy</code>) and <code>fetchResponseProxy</code> for streamlined agent deployment logic (<code>src/utils/deployment/task-wrapper.ts</code>, <code>examples/task-wrapper.js</code>).</li> <li>Test deployment functionality (<code>testDeployment</code>) to test agent deployments in a sandboxed environment (<code>src/utils/deployment/test-deployment.ts</code>).</li> <li>New types for server deployment requests and responses (<code>ServerDeploymentRequestParams</code>, <code>ServerDeploymentResponse</code>, etc. in <code>src/types/extended-schema.ts</code>).</li> <li>Comprehensive tests for the new bundler and deployment features (<code>tests/bundler.test.ts</code>, <code>tests/deployment.test.ts</code>).</li> <li>Example agents demonstrating code deployment: <code>examples/code-deployment.js</code> and <code>examples/code-deployment.ts</code>.</li> <li><code>esbuild</code> dependency for bundling.</li> </ul>"},{"location":"versions.html#changed_1","title":"Changed","text":"<ul> <li>BREAKING: Updated <code>rootDir</code> in <code>tsconfig.json</code> to <code>src</code> and <code>declarationDir</code> to <code>./dist/types</code>. This changes the output structure for type declarations.</li> <li>Type declaration paths in <code>package.json</code> updated to <code>dist/types/index.d.ts</code> to reflect <code>tsconfig.json</code> changes.</li> <li>Deprecated <code>JSONRPCSuccessResponse</code>, <code>JSONRPCErrorResponse</code> in <code>src/types/extended-schema.ts</code> in favor of the more general <code>JSONRPCResponse</code>.</li> <li>Enhanced error logging in <code>src/transport/rpc/parser.ts</code> by adding response data to parse errors.</li> </ul>"},{"location":"versions.html#030-2025-04-28","title":"[0.3.0] - 2025-04-28","text":""},{"location":"versions.html#added_2","title":"Added","text":"<ul> <li>Server option <code>register: boolean</code> in <code>A2AServerParams</code> to automatically register the agent with the A2A Registry on startup (default: <code>false</code>).</li> <li><code>A2AServer.registerServer()</code> method to manually trigger agent registration.</li> <li>Server option <code>fallbackPath: string</code> in <code>A2AServerParams</code> to customize the fallback endpoint for serving the Agent Card (defaults to <code>/agent-card</code>). The standard <code>/.well-known/agent.json</code> endpoint remains.</li> <li>Client constructor option <code>fallbackPath: string</code> in <code>A2AClient</code> to specify a custom path when fetching the Agent Card if the standard paths fail.</li> </ul>"},{"location":"versions.html#changed_2","title":"Changed","text":"<ul> <li>BREAKING: Renamed server configuration type from <code>A2AServerOptions</code> to <code>A2AServerParams</code> for consistency.</li> <li>Updated dependencies to latest versions:<ul> <li><code>eventsource-parser</code> to <code>^3.0.1</code>. Adapted streaming logic (<code>handleEventStream</code>) to use <code>EventSourceMessage</code> type from this library.</li> <li><code>express</code> to <code>^5.1.0</code>.</li> <li><code>jayson</code> to <code>^4.2.0</code>.</li> <li><code>node:16</code> to <code>node:22</code></li> <li><code>ES2020</code> to <code>ES2022</code></li> </ul> </li> <li>Updated various code examples in documentation for improved clarity and consistency (<code>README.md</code>, <code>examples/</code>).</li> </ul>"},{"location":"versions.html#improved_1","title":"Improved","text":"<ul> <li>Refactored server JSON-RPC method handling:<ul> <li>Introduced <code>createJSONRPCMethod</code> helper for wrapping A2A method logic with dependency injection and error handling.</li> <li>Exported default implementations for standard A2A methods (e.g., <code>defaultSendTaskMethod</code>) from <code>lib/middleware/a2a-methods.js</code>.</li> <li>Provided <code>defaultCreateJSONRPCServer</code> factory demonstrating standard server setup. This simplifies advanced server customization.</li> </ul> </li> <li>Significantly revised and expanded <code>README.md</code> documentation:<ul> <li>Updated Features, Class Documentation, and Usage sections.</li> <li>Added detailed section on Server Registration &amp; Discovery.</li> <li>Corrected and clarified Advanced Server Customization examples.</li> </ul> </li> <li>Updated test suite to incorporate tests for new server registration and fallback path functionalities.</li> </ul>"},{"location":"versions.html#020-2025-04-25","title":"0.2.0 - 2025-04-25","text":""},{"location":"versions.html#fixed","title":"Fixed","text":"<ul> <li>Fixed TypeScript errors related to the <code>eventsource-parser</code> package imports</li> <li>Updated imports to use the correct types from <code>eventsource-parser</code> v1.1.1</li> <li>Properly typed the <code>EventSourceMessage</code> as <code>ParsedEvent</code></li> <li>Refactored <code>createParser</code> implementation to match the package's API</li> <li>Fixed streaming response handler to use the correct event type checking</li> </ul>"},{"location":"versions.html#changed_3","title":"Changed","text":"<ul> <li>Updated <code>tsconfig.json</code> to add <code>isolatedModules: true</code> for better compatibility with <code>ts-jest</code></li> <li>Modified <code>package.json</code> test scripts to include <code>NODE_OPTIONS=--experimental-vm-modules</code> flag to support ES modules in Jest tests</li> </ul>"},{"location":"versions.html#improved_2","title":"Improved","text":"<ul> <li>Expanded test suite to achieve 80% code coverage</li> <li>Added tests for all client methods</li> <li>Added robust error handling tests</li> <li>Added tests for streaming functionality</li> <li>Added tests for push notification configuration</li> <li>Added tests for edge cases in agent card fetching and capability detection</li> </ul>"},{"location":"versions.html#010-2025-04-22","title":"0.1.0 - 2025-04-22","text":""},{"location":"versions.html#added_3","title":"Added","text":"<ul> <li>Initial release of the @artinet/sdk package</li> <li>Implementation of the Agent2Agent (A2A) Protocol client</li> <li>Support for sending tasks, retrieving statuses, and canceling operations</li> <li>Support for streaming responses and push notifications</li> <li>Comprehensive test suite and documentation</li> </ul>"},{"location":"about/working-group.html","title":"The Artinet Project: Working Group","text":""},{"location":"about/working-group.html#vision","title":"Vision","text":"<p>We're transitioning into a more research-focused organization with a mission to democratize intelligence by creating a decentralized public infrastructure for AI agents.</p>"},{"location":"about/working-group.html#our-team","title":"Our Team","text":"Patrick Buah <p>Founder &amp; Project Lead London, United Kingdom</p> <p>Patrick leads the Artinet Project, guiding our vision to build an open infrastructure for AI agents. With expertise in cryptography and AI security, he brings a strong technical background from his work at Mastercard where he serves as Engineering Lead for Data Protection &amp; AI Security.</p> Experience: <ul> <li>Engineering Lead - Mastercard (Jan 2025 - Present)</li> <li>Lead - Enterprise Cryptography - Mastercard (Aug 2024 - Present)</li> <li>Lead - Cryptographic Architecture &amp; Engineering - Mastercard (Oct 2023 - Jul 2024)</li> </ul> Davronbek Imomov <p>Research Assistant London, United Kingdom </p> <p>Davronbek is a recent Computer Science graduate who brings fresh technical expertise to our team. His skills in Python, machine learning models, and data analysis support our research initiatives. With internship experience in software engineering and financial operations, he helps implement our technical solutions.</p> Skills: <ul> <li>Programming Languages: Python, Kotlin, C++, JavaScript, SQL, C</li> <li>Machine Learning &amp; Data Analysis: TensorFlow, PyTorch, Pandas, NumPy</li> <li>Cloud Integration: AWS workflows, serverless systems</li> </ul> Education: <ul> <li>University of York - Bachelor of Engineering, Computer Science (2020-2024)       <ul> <li>Second Class Honours: First Division (2:1)</li> </ul> </li> </ul> Pucheng Yang <p>Head of Research Seattle Area (Previously San Francisco Bay Area)</p> <p>Pucheng leads our research efforts with his extensive experience in big data infrastructure and software engineering. At Pinterest, he architected platforms for data lakes, query processing, and analytics that power the company's data-driven decision making.</p> Experience: <ul> <li>Senior Software Engineer - Pinterest (Jul 2018 - Present)</li> <li>Specialized in Big Data Query Platform/Big Data Storage Platform</li> <li>Implemented innovations that saved millions in S3 storage costs</li> <li>Presented at Trino Summit 2020 representing Pinterest</li> </ul> Education: <ul> <li>Carnegie Mellon University - Master's degree, Electrical and Computer Engineering (2017-2018)</li> <li>Sun Yat-sen University - Master's degree, Electrical and Computer Engineering (2016-2017)</li> </ul>"},{"location":"about/working-group.html#current-focus","title":"Current Focus","text":"<p>The Artinet Project is developing the Artinet SDK, a robust implementation of the Agent2Agent (A2A) Protocol that enables developers to create and connect AI agents. Our current focus is on:</p> <ol> <li>Creating production-ready tools for AI agent development</li> <li>Researching novel approaches to agent collaboration and communication</li> <li>Democratizing access to advanced AI agent capabilities</li> </ol>"},{"location":"about/working-group.html#join-our-community","title":"Join Our Community","text":"<p>Join our community-driven initiative by:</p> <ul> <li>Exploring our SDK on GitHub</li> <li>Connecting with our team on Discord</li> <li>Contributing to our research and development</li> <li>Building your own agents using our open tools</li> </ul>"},{"location":"agents/quick_agents.html","title":"Quick Agents Guide","text":"<p>This guide explains how to use the Artinet SDK's Quick Agents feature to rapidly build, test, and deploy your agents.</p>"},{"location":"agents/quick_agents.html#what-are-quick-agents","title":"What are Quick Agents?","text":"<p>Quick Agents provide a streamlined way to:</p> <ol> <li>Bundle your agent code and dependencies into a single file</li> <li>Test your agent in a sandboxed environment</li> <li>Deploy your agent to the Artinet platform (for alpha testers)</li> </ol> <p>This feature is ideal for:</p> <ul> <li>Rapid prototyping</li> <li>Testing agent behavior without setting up a full server</li> <li>Sharing your agent with others</li> <li>Deploying to the Artinet ecosystem</li> </ul>"},{"location":"agents/quick_agents.html#key-components","title":"Key Components","text":"<p>The Quick Agents feature includes several important utilities:</p> <ul> <li><code>bundle</code>: Packages your agent code and dependencies into a single distributable file</li> <li><code>taskHandlerProxy</code>: Simplifies running your agent logic in managed environments</li> <li><code>fetchResponseProxy</code>: Enables communication with other agents in the Artinet ecosystem</li> <li><code>testDeployment</code>: Tests your bundled agent in a temporary sandboxed environment</li> </ul>"},{"location":"agents/quick_agents.html#bundling-your-agent","title":"Bundling Your Agent","text":"<p>The first step is to bundle your agent's code:</p> <pre><code>import { bundle } from \"@artinet/sdk\";\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\n\n// Get the current file's directory\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nasync function bundleMyAgent() {\n  // Path to your agent's main file\n  const agentPath = path.join(__dirname, \"my-agent.ts\");\n\n  // Bundle the agent code\n  const bundledCode = await bundle(new URL(`file://${agentPath}`));\n\n  console.log(\"Agent bundled successfully!\");\n  return bundledCode;\n}\n\nbundleMyAgent()\n  .then((bundledCode) =&gt; {\n    // Save the bundled code to a file or use it for deployment\n    console.log(`Bundled code size: ${bundledCode.length} bytes`);\n  })\n  .catch((error) =&gt; {\n    console.error(\"Bundling failed:\", error);\n  });\n</code></pre>"},{"location":"agents/quick_agents.html#creating-a-quick-agent","title":"Creating a Quick Agent","text":"<p>When writing an agent for bundling, you can use the <code>taskHandlerProxy</code> to simplify the process:</p> <pre><code>// my-agent.ts\nimport { taskHandlerProxy, fetchResponseProxy, TaskContext } from \"@artinet/sdk\";\n\n// Define your agent's core logic as an async function\nasync function* myQuickAgent(context: TaskContext) {\n  // Extract the user's message\n  const userInput = context.userMessage.parts[0]?.text || \"\";\n\n  // Signal that we're working on the task\n  yield { state: \"working\" };\n\n  // Do some processing...\n  const response = `You said: \"${userInput}\"`;\n\n  // Complete the task\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: response }]\n    }\n  };\n}\n\n// Export the agent wrapped in taskHandlerProxy\nexport default taskHandlerProxy(myQuickAgent);\n</code></pre>"},{"location":"agents/quick_agents.html#testing-your-quick-agent","title":"Testing Your Quick Agent","text":"<p>Before deploying, you can test your bundled agent:</p> <pre><code>import { \n  testDeployment, \n  ServerDeploymentRequestParams, \n  SendTaskRequest \n} from \"@artinet/sdk\";\n\nasync function testMyAgent(bundledCode: string) {\n  // Prepare deployment parameters\n  const deploymentParams: ServerDeploymentRequestParams = {\n    code: bundledCode,\n    name: \"MyTestAgent\",\n    agentCard: {\n      name: \"My Test Agent\",\n      url: \"placeholder-url\", // Will be set by the test environment\n      version: \"0.1.0\",\n      capabilities: { streaming: true },\n      skills: [{ id: \"test\", name: \"Test Skill\" }]\n    }\n  };\n\n  // Create test tasks to verify your agent's behavior\n  const testRequests: SendTaskRequest[] = [\n    {\n      id: \"test-1\",\n      method: \"tasks/send\",\n      params: {\n        id: \"test-1\",\n        message: {\n          role: \"user\",\n          parts: [{ type: \"text\", text: \"Hello, agent!\" }]\n        }\n      }\n    },\n    {\n      id: \"test-2\",\n      method: \"tasks/send\",\n      params: {\n        id: \"test-2\",\n        message: {\n          role: \"user\",\n          parts: [{ type: \"text\", text: \"What can you do?\" }]\n        }\n      }\n    }\n  ];\n\n  console.log(\"Testing agent deployment...\");\n\n  try {\n    // Process each test result as it completes\n    for await (const result of testDeployment(deploymentParams, testRequests)) {\n      console.log(`Result for task ${result.id}:`);\n\n      if (result.message?.parts[0]?.type === \"text\") {\n        console.log(`Response: ${result.message.parts[0].text}`);\n      } else {\n        console.log(\"Task completed with non-text response:\", result);\n      }\n    }\n\n    console.log(\"All test tasks completed successfully!\");\n  } catch (error) {\n    console.error(\"Deployment test failed:\", error);\n  }\n}\n</code></pre>"},{"location":"agents/quick_agents.html#communication-between-agents","title":"Communication Between Agents","text":"<p>Your Quick Agent can communicate with other agents in the Artinet ecosystem using the <code>fetchResponseProxy</code>:</p> <pre><code>import { taskHandlerProxy, fetchResponseProxy, TaskContext } from \"@artinet/sdk\";\n\nasync function* collaborativeAgent(context: TaskContext) {\n  const userInput = context.userMessage.parts[0]?.text || \"\";\n\n  yield { state: \"working\" };\n\n  // Call another agent for assistance\n  try {\n    const helperResponse = await fetchResponseProxy(\n      \"WeatherExpertAgent\", // Name of another agent in the Artinet ecosystem\n      [\n        {\n          role: \"user\",\n          content: `What's the weather in ${userInput}?`\n        }\n      ]\n    );\n\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [{ \n          type: \"text\", \n          text: `I asked my colleague about the weather in ${userInput}. Here's what they said:\\n\\n${helperResponse}` \n        }]\n      }\n    };\n  } catch (error) {\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n        parts: [{ \n          type: \"text\", \n          text: `Sorry, I couldn't get weather information: ${error instanceof Error ? error.message : String(error)}` \n        }]\n      }\n    };\n  }\n}\n\nexport default taskHandlerProxy(collaborativeAgent);\n</code></pre>"},{"location":"agents/quick_agents.html#complete-workflow-example","title":"Complete Workflow Example","text":"<p>Here's a complete example that brings all the components together:</p> <pre><code>import { \n  bundle, \n  testDeployment, \n  ServerDeploymentRequestParams,\n  SendTaskRequest\n} from \"@artinet/sdk\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n\n// Get the current directory\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nasync function buildAndTestAgent() {\n  try {\n    console.log(\"Step 1: Bundling agent code...\");\n\n    // Bundle your agent code\n    const agentPath = path.join(__dirname, \"my-quick-agent.ts\");\n    const bundledCode = await bundle(new URL(`file://${agentPath}`));\n\n    console.log(`Successfully bundled agent (${bundledCode.length} bytes)`);\n\n    // Optionally save the bundled code\n    const outputPath = path.join(__dirname, \"bundled-agent.js\");\n    await fs.writeFile(outputPath, bundledCode);\n    console.log(`Saved bundled code to: ${outputPath}`);\n\n    console.log(\"\\nStep 2: Testing agent in sandbox environment...\");\n\n    // Prepare deployment parameters\n    const deploymentParams: ServerDeploymentRequestParams = {\n      code: bundledCode,\n      name: \"MyQuickAgent\",\n      // Agent card information\n      agentCard: {\n        name: \"My Quick Agent\",\n        url: \"placeholder-url\", // Will be assigned by test environment\n        version: \"1.0.0\",\n        description: \"A demonstration of the Quick Agents feature\",\n        capabilities: { streaming: true },\n        skills: [{ id: \"demo\", name: \"Demo Skill\" }]\n      }\n    };\n\n    // Create test scenarios\n    const testRequests: SendTaskRequest[] = [\n      {\n        id: \"greeting-test\",\n        method: \"tasks/send\",\n        params: {\n          id: \"greeting-test\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Hello there!\" }]\n          }\n        }\n      },\n      {\n        id: \"question-test\",\n        method: \"tasks/send\",\n        params: {\n          id: \"question-test\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"What's your purpose?\" }]\n          }\n        }\n      }\n    ];\n\n    // Test the agent with each scenario\n    console.log(\"Running test cases...\");\n    for await (const result of testDeployment(deploymentParams, testRequests)) {\n      console.log(`\\nTest case: ${result.id}`);\n      console.log(`Status: ${result.status.state}`);\n\n      if (result.message?.parts[0]?.type === \"text\") {\n        console.log(`Response: ${result.message.parts[0].text}`);\n      } else if (result.artifacts?.length &gt; 0) {\n        console.log(`Generated ${result.artifacts.length} artifacts`);\n        result.artifacts.forEach((artifact, index) =&gt; {\n          console.log(`Artifact ${index + 1}: ${artifact.name} (${artifact.mimeType})`);\n        });\n      }\n    }\n\n    console.log(\"\\nAll tests completed successfully!\");\n    console.log(\"\\nStep 3: Your agent is ready for deployment to Artinet!\");\n    console.log(\"To join the alpha and deploy your agent, email humans@artinet.io\");\n\n  } catch (error) {\n    console.error(\"Error during build and test process:\", error);\n  }\n}\n\nbuildAndTestAgent();\n</code></pre>"},{"location":"agents/quick_agents.html#limitations-and-considerations","title":"Limitations and Considerations","text":"<p>When using Quick Agents, be aware of these limitations:</p> <ol> <li> <p>Test-Agents expire after 60 seconds by default (you can request longer durations for testing complex agents)</p> </li> <li> <p>Limited environment access:</p> </li> <li>Quick Agents do not have access to a filesystem</li> <li>Network access is restricted</li> <li> <p>No persistent storage is available</p> </li> <li> <p>Resource constraints:</p> </li> <li>Memory and CPU usage are limited</li> <li>Large dependencies may affect performance</li> </ol>"},{"location":"agents/quick_agents.html#alpha-access-for-deployment","title":"Alpha Access for Deployment","text":"<p>The ability to permanently deploy agents to the Artinet platform is currently in alpha. To join the waitlist:</p> <ol> <li>Email humans@artinet.io with your request</li> <li>Describe your agent's purpose and use case</li> <li>Include any specific requirements or features you need</li> </ol>"},{"location":"agents/quick_agents.html#best-practices","title":"Best Practices","text":"<p>For optimal results with Quick Agents:</p> <ol> <li> <p>Keep dependencies minimal - Large dependencies increase bundle size and startup time</p> </li> <li> <p>Use efficient algorithms - Quick Agents have resource constraints</p> </li> <li> <p>Implement timeouts - Add timeouts for external operations to prevent hanging</p> </li> <li> <p>Handle errors gracefully - Ensure your agent can recover from failed operations</p> </li> <li> <p>Test thoroughly - Use a variety of test cases to verify behavior</p> </li> <li> <p>Structure your code carefully - Organize your agent logic for clarity and maintainability</p> </li> </ol>"},{"location":"agents/quick_agents.html#faq","title":"FAQ","text":"<p>Q: How long does it take to deploy a Quick Agent? A: Test deployments typically take a few seconds. Production deployments (for alpha users) may take 1-2 minutes.</p> <p>Q: Can I use external APIs in my Quick Agent? A: Yes, using the fetchResponseProxy, but be mindful of rate limits and timeouts.</p> <p>Q: How do I update a deployed agent? A: For alpha users, you can deploy a new version which will replace the previous one.</p> <p>Q: What's the difference between testDeployment and actual deployment? A: testDeployment creates a temporary sandbox that expires after 60 seconds. Actual deployment (for alpha users) creates a permanent agent instance in the Artinet ecosystem.</p> <p>Q: Can my Quick Agent maintain state between invocations? A: Test agents cannot maintain state. For alpha users, limited persistence capabilities are planned.</p>"},{"location":"agents/quick_agents.html#next-steps","title":"Next Steps","text":"<p>After mastering Quick Agents:</p> <ol> <li>Explore more complex agent architectures</li> <li>Implement collaboration between multiple agents</li> <li>Consider joining the alpha program for production deployment</li> <li>Explore integrations with other AI services and tools</li> </ol>"},{"location":"api/index.html","title":"API Reference","text":"<p>This section provides a comprehensive reference for the Artinet SDK Core API components. The SDK implements the Agent2Agent (A2A) Protocol and provides enhanced functionality for building interoperable AI agents.</p>"},{"location":"api/index.html#overview","title":"Overview","text":"<p>The Artinet SDK API is organized into several key component categories:</p> Client APIServer APIStorage APIAdvanced <ul> <li><code>A2AClient</code> - For sending tasks to and receiving responses from agents</li> <li>Task submission and streaming</li> <li>Push notification handling</li> </ul> <ul> <li><code>A2AServer</code> - For hosting and implementing agent behavior</li> <li>Task processing and state management</li> <li>Server registration</li> </ul> <ul> <li><code>InMemoryTaskStore</code> - For development</li> <li><code>FileTaskStore</code> - For production</li> <li>Custom store implementations</li> </ul> <ul> <li>Task handling customization</li> <li>Express middleware integration</li> <li>Runtime configuration</li> </ul> <p>TypeScript Support</p> <p>The Artinet SDK is fully written in TypeScript with comprehensive type definitions for a robust developer experience.</p>"},{"location":"api/index.html#client-api","title":"Client API","text":""},{"location":"api/index.html#a2aclient","title":"A2AClient","text":"<p>The primary class for interacting with A2A-compliant agent servers.</p> <pre><code>class A2AClient {\n  /**\n   * Creates a new A2AClient instance.\n   * @param baseUrl The base URL of the A2A-compliant server\n   * @param headers Optional custom headers to include in requests\n   * @param fallbackPath Optional path for retrieving the agent card if the standard path fails\n   */\n  constructor(\n    baseUrl: string | URL,\n    headers?: Record&lt;string, string&gt;,\n    fallbackPath?: string\n  );\n\n  /**\n   * Adds a single HTTP header to requests.\n   * @param key The header name\n   * @param value The header value\n   */\n  addHeader(key: string, value: string): void;\n\n  /**\n   * Sets multiple HTTP headers, replacing any existing headers.\n   * @param headers Key-value pairs of headers\n   */\n  setHeaders(headers: Record&lt;string, string&gt;): void;\n\n  /**\n   * Removes a specific HTTP header.\n   * @param name The header name to remove\n   */\n  removeHeader(name: string): void;\n\n  /**\n   * Clears all custom HTTP headers.\n   */\n  clearHeaders(): void;\n\n  /**\n   * Sends a task and returns the final result.\n   * @param params The task parameters\n   * @returns A Promise resolving to the completed task\n   */\n  async sendTask(params: TaskSendParams): Promise&lt;Task | null&gt;;\n\n  /**\n   * Retrieves information about an existing task.\n   * @param params The task parameters including task ID\n   * @returns A Promise resolving to the task\n   */\n  async getTask(params: TaskQueryParams): Promise&lt;Task | null&gt;;\n\n  /**\n   * Cancels an in-progress task.\n   * @param params The task parameters including task ID\n   */\n  async cancelTask(params: TaskIdParams): Promise&lt;Task | null&gt;;\n\n  /**\n   * Sends a task and subscribes to streaming updates.\n   * @param params The task parameters\n   * @returns An AsyncIterable yielding status and artifact updates\n   */\n  sendTaskSubscribe(params: TaskSendParams): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\n\n  /**\n   * Resubscribes to updates for an existing task.\n   * @param params The resubscribe parameters including task ID\n   * @returns An AsyncIterable yielding status and artifact updates\n   */\n  resubscribeTask(params: TaskQueryParams): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\n\n  /**\n   * Configures push notifications for a task.\n   * @param params The push notification parameters\n   */\n  async setTaskPushNotification(params: TaskPushNotificationConfig): Promise&lt;TaskPushNotificationConfig | null&gt;;\n\n  /**\n   * Retrieves push notification configuration for a task.\n   * @param params The parameters including task ID\n   * @returns The push notification configuration\n   */\n  async getTaskPushNotification(params: TaskIdParams): Promise&lt;TaskPushNotificationConfig | null&gt;;\n\n  /**\n   * Retrieves the agent card describing the server's capabilities.\n   * @returns A Promise resolving to the agent card\n   */\n  async agentCard(): Promise&lt;AgentCard&gt;;\n\n  /**\n   * Refreshes the cached agent card.\n   * @returns A Promise resolving to the refreshed agent card\n   */\n  async refreshAgentCard(): Promise&lt;AgentCard&gt;;\n\n  /**\n   * Checks if the server supports a specific capability.\n   * @param capability The capability to check\n   * @returns A Promise resolving to a boolean indicating support\n   */\n  async supports(capability: \"streaming\" | \"pushNotifications\" | \"stateTransitionHistory\"): Promise&lt;boolean&gt;;\n}\n</code></pre>"},{"location":"api/index.html#rpcerror","title":"RpcError","text":"<p>Represents client-side errors encountered during A2A communication.</p> <pre><code>class SystemError&lt;ErrorData = unknown, C extends number = number&gt; extends Error {\n  /**\n   * The error code (typically a JSON-RPC error code)\n   */\n  code: C;\n\n  /**\n   * Additional error data, if any\n   */\n  data: ErrorData;\n\n  /**\n   * Creates a new SystemError.\n   * @param message The error message\n   * @param code The error code\n   * @param data Additional error data\n   */\n  constructor(message: string, code: C, data: ErrorData);\n}\n</code></pre>"},{"location":"api/index.html#server-api","title":"Server API","text":""},{"location":"api/index.html#a2aserver","title":"A2AServer","text":"<p>The core server class for hosting A2A-compliant agents.</p> <pre><code>class A2AServer {\n  /**\n   * Creates a new A2AServer instance.\n   * @param params Configuration parameters\n   */\n  constructor(params: A2AServerParams);\n\n  /**\n   * Starts the server, making it available to accept requests.\n   * @returns The Express application instance\n   */\n  start(): express.Express;\n\n  /**\n   * Stops the server, closing all connections.\n   * @returns A Promise that resolves when the server is stopped\n   */\n  stop(): Promise&lt;void&gt;;\n\n  /**\n   * Gets the underlying Express application instance.\n   * Useful for advanced customization.\n   * @returns The Express application\n   */\n  getExpressApp(): express.Express;\n\n  /**\n   * Registers the server with the A2A registry.\n   * @returns A Promise resolving to the registration ID\n   */\n  registerServer(): Promise&lt;string&gt;;\n\n  /**\n   * Gets the base path for the server.\n   * @returns The base path\n   */\n  getBasePath(): string;\n\n  /**\n   * Gets the CORS options for the server.\n   * @returns The CORS options\n   */\n  getCorsOptions(): CorsOptions;\n\n  /**\n   * Gets the agent card for the server.\n   * @returns The agent card\n   */\n  getCard(): AgentCard;\n\n  /**\n   * Gets the task store.\n   * @returns The task store\n   */\n  getTaskStore(): TaskStore;\n\n  /**\n   * Gets the task handler.\n   * @returns The task handler\n   */\n  getTaskHandler(): TaskHandler;\n\n  /**\n   * Gets the active cancellations set.\n   * @returns The set of active cancellations\n   */\n  getActiveCancellations(): Set&lt;string&gt;;\n\n  /**\n   * Gets the active streams map.\n   * @returns The map of active streams\n   */\n  getActiveStreams(): Map&lt;string, Response[]&gt;;\n\n  /**\n   * Gets the port number.\n   * @returns The port number\n   */\n  getPort(): number;\n}\n</code></pre>"},{"location":"api/index.html#a2aserverparams","title":"A2AServerParams","text":"<p>Configuration interface for the A2AServer constructor.</p> <pre><code>interface A2AServerParams {\n  /**\n   * The task handler function that implements agent logic\n   */\n  handler: TaskHandler;\n\n  /**\n   * The storage implementation for persisting tasks\n   */\n  taskStore?: TaskStore;\n\n  /**\n   * Metadata about the agent's capabilities\n   */\n  card?: AgentCard;\n\n  /**\n   * Port number to listen on (default: 41241)\n   */\n  port?: number;\n\n  /**\n   * Host address to bind to (default: '0.0.0.0')\n   */\n  host?: string;\n\n  /**\n   * Base URL path for API endpoints (default: '/')\n   */\n  basePath?: string;\n\n  /**\n   * Alternative path for agent card (default: '/agent-card')\n   */\n  fallbackPath?: string;\n\n  /**\n   * Whether to register this agent with the Artinet registry (default: false)\n   */\n  register?: boolean;\n\n  /**\n   * Custom JSON-RPC server factory for advanced usage\n   */\n  createJSONRPCServer?: JSONRPCServerFactory;\n\n  /**\n   * CORS options for the server\n   */\n  corsOptions?: CorsOptions;\n\n  /**\n   * Logging verbosity level (default: LogLevel.info)\n   */\n  logLevel?: LogLevel;\n}\n</code></pre>"},{"location":"api/index.html#task-handling-api","title":"Task Handling API","text":""},{"location":"api/index.html#taskhandler","title":"TaskHandler","text":"<p>The core type for defining agent logic.</p> <pre><code>/**\n * An asynchronous generator function that processes tasks and yields updates.\n * @param context The context containing task information\n * @returns An AsyncGenerator that yields status and artifact updates\n */\ntype TaskHandler = (\n  context: TaskContext\n) =&gt; AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt;;\n</code></pre>"},{"location":"api/index.html#taskcontext","title":"TaskContext","text":"<p>Provides task details to the TaskHandler.</p> <pre><code>interface TaskContext {\n  /**\n   * The Task being processed\n   */\n  readonly task: Task;\n\n  /**\n   * The message from the user that initiated this task\n   */\n  readonly userMessage: Message;\n\n  /**\n   * Message history for this task (if available)\n   */\n  readonly history: Message[];\n\n  /**\n   * Function to check if the task has been cancelled\n   * @returns true if the task is cancelled, false otherwise\n   */\n  isCancelled(): boolean;\n}\n</code></pre>"},{"location":"api/index.html#taskyieldupdate","title":"TaskYieldUpdate","text":"<p>Union type for updates yielded by a TaskHandler.</p> <pre><code>/**\n * Represents either a status update or an artifact creation\n */\ntype TaskYieldUpdate = \n  /**\n   * Status update with optional message\n   */\n  | { state: TaskStatus[\"state\"]; message?: Message }\n\n  /**\n   * Artifact creation\n   */\n  | { name: string; parts: Part[]; mimeType?: string };\n</code></pre>"},{"location":"api/index.html#storage-api","title":"Storage API","text":""},{"location":"api/index.html#taskstore","title":"TaskStore","text":"<p>Interface for task persistence implementations.</p> <pre><code>interface TaskStore {\n  /**\n   * Saves a task and its associated message history.\n   * @param data An object containing the task and its history\n   * @returns A promise resolving when the save operation is complete\n   */\n  save(data: TaskAndHistory): Promise&lt;void&gt;;\n\n  /**\n   * Loads a task and its history by task ID.\n   * @param taskId The ID of the task to load\n   * @returns A promise resolving to an object containing the Task and its history, or null if not found\n   */\n  load(taskId: string): Promise&lt;TaskAndHistory | null&gt;;\n}\n</code></pre>"},{"location":"api/index.html#taskandhistory","title":"TaskAndHistory","text":"<p>Interface representing a task and its associated message history.</p> <pre><code>interface TaskAndHistory {\n  /**\n   * The task object\n   */\n  task: Task;\n\n  /**\n   * The complete message history associated with the task\n   */\n  history: Message[];\n}\n</code></pre>"},{"location":"api/index.html#inmemorytaskstore","title":"InMemoryTaskStore","text":"<p>Simple in-memory task persistence for development/testing.</p> <pre><code>class InMemoryTaskStore implements TaskStore {\n  /**\n   * Creates a new InMemoryTaskStore\n   */\n  constructor();\n\n  /**\n   * Saves a task and its associated message history.\n   * @param data An object containing the task and its history\n   */\n  save(data: TaskAndHistory): Promise&lt;void&gt;;\n\n  /**\n   * Loads a task and its history by task ID.\n   * @param taskId The ID of the task to load\n   * @returns A promise resolving to the task and history, or null if not found\n   */\n  load(taskId: string): Promise&lt;TaskAndHistory | null&gt;;\n}\n</code></pre>"},{"location":"api/index.html#filestore","title":"FileStore","text":"<p>File-based task persistence that stores task data in the filesystem.</p> <pre><code>class FileStore implements TaskStore {\n  /**\n   * Creates a new FileStore\n   * @param dataDirectory Path to the directory for storing task files\n   */\n  constructor(dataDirectory: string);\n\n  /**\n   * Saves a task and its associated message history.\n   * @param data An object containing the task and its history\n   */\n  save(data: TaskAndHistory): Promise&lt;void&gt;;\n\n  /**\n   * Loads a task and its history by task ID.\n   * @param taskId The ID of the task to load\n   * @returns A promise resolving to the task and history, or null if not found\n   */\n  load(taskId: string): Promise&lt;TaskAndHistory | null&gt;;\n}\n</code></pre>"},{"location":"api/index.html#logging-api","title":"Logging API","text":""},{"location":"api/index.html#logger","title":"logger","text":"<p>Built-in structured logger based on Pino.</p> <pre><code>/**\n * The main logger instance for the SDK\n */\nconst logger: Logger;\n</code></pre>"},{"location":"api/index.html#configurelogger","title":"configureLogger","text":"<p>Function to configure the logging level and other options.</p> <pre><code>/**\n * Configures the global logger's settings\n * @param options Configuration options\n */\nfunction configureLogger(options: { level?: LogLevel, name?: string, prettyPrint?: boolean }): Logger;\n</code></pre>"},{"location":"api/index.html#log-helper-functions","title":"Log Helper Functions","text":"<pre><code>/**\n * Logs a message at DEBUG level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param data Optional data to include\n */\nfunction logDebug(context: string, message: string, data?: unknown): void;\n\n/**\n * Logs a message at INFO level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param data Optional data to include\n */\nfunction logInfo(context: string, message: string, data?: unknown): void;\n\n/**\n * Logs a message at WARN level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param data Optional data to include\n */\nfunction logWarn(context: string, message: string, data?: unknown): void;\n\n/**\n * Logs a message at ERROR level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param error The error object\n * @param data Optional additional data\n */\nfunction logError(context: string, message: string, error: unknown, data?: unknown): void;\n</code></pre>"},{"location":"api/index.html#loglevel","title":"LogLevel","text":"<p>Type defining logging levels.</p> <pre><code>type LogLevel = \"silent\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n</code></pre>"},{"location":"api/index.html#advanced-customization-api","title":"Advanced Customization API","text":""},{"location":"api/index.html#jsonrpcserverfactory","title":"JSONRPCServerFactory","text":"<p>Function signature for providing custom JSON-RPC server creation logic.</p> <pre><code>/**\n * Factory function for creating a custom JSON-RPC server\n * @param params Parameters with dependencies needed for server creation\n * @returns A configured JSON-RPC server\n */\ntype JSONRPCServerFactory = (\n  params: CreateJSONRPCServerParams\n) =&gt; JSONRPCServerType;\n</code></pre>"},{"location":"api/index.html#createjsonrpcserverparams","title":"CreateJSONRPCServerParams","text":"<p>Object containing dependencies provided to a JSONRPCServerFactory function.</p> <pre><code>interface CreateJSONRPCServerParams {\n  /**\n   * The task handler function\n   */\n  taskHandler: TaskHandler;\n\n  /**\n   * The storage implementation\n   */\n  taskStore: TaskStore;\n\n  /**\n   * The agent's metadata\n   */\n  card: AgentCard;\n\n  /**\n   * Set of active task cancellations\n   */\n  activeCancellations: Set&lt;string&gt;;\n\n  /**\n   * Function to create a TaskContext for a task\n   */\n  createTaskContext: (task: Task, message: Message, history: Message[]) =&gt; TaskContext;\n\n  /**\n   * Function to close all streams for a task\n   */\n  closeStreamsForTask: (taskId: string) =&gt; void;\n}\n</code></pre>"},{"location":"api/index.html#method-type-definitions","title":"Method Type Definitions","text":"<pre><code>/**\n * Type definition for the tasks/send method handler\n */\ntype SendTaskMethod = A2AMethodHandler&lt;\n  SendTaskRequest[\"params\"],\n  SendTaskResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/get method handler\n */\ntype GetTaskMethod = A2AMethodHandler&lt;\n  GetTaskRequest[\"params\"],\n  GetTaskResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/cancel method handler\n */\ntype CancelTaskMethod = A2AMethodHandler&lt;\n  CancelTaskRequest[\"params\"],\n  CancelTaskResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/pushNotification/set method handler\n */\ntype SetTaskPushNotificationMethod = A2AMethodHandler&lt;\n  SetTaskPushNotificationRequest[\"params\"],\n  SetTaskPushNotificationResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/pushNotification/get method handler\n */\ntype GetTaskPushNotificationMethod = A2AMethodHandler&lt;\n  GetTaskPushNotificationRequest[\"params\"],\n  GetTaskPushNotificationResponse | null\n&gt;;\n</code></pre>"},{"location":"api/index.html#createjsonrpcmethod","title":"createJSONRPCMethod","text":"<p>Helper function for creating JSON-RPC method handlers.</p> <pre><code>/**\n * Creates a JSON-RPC method with dependency injection and error handling\n * @param deps The dependency parameters\n * @param methodImpl The method implementation\n * @param methodName The name of the method\n * @returns A configured JSON-RPC method handler\n */\nfunction createJSONRPCMethod&lt;\n  Params extends RequestParams,\n  Result extends A2AResponse | null,\n&gt;(\n  deps: CreateJSONRPCServerParams,\n  methodImpl: A2AMethodHandler&lt;Params, Result&gt;,\n  methodName: string\n): (params: Params, callback: JSONRPCCallback&lt;Result&gt;) =&gt; void;\n</code></pre>"},{"location":"api/index.html#quick-agent-api","title":"Quick Agent API","text":""},{"location":"api/index.html#bundle","title":"bundle","text":"<p>Bundles agent code for deployment.</p> <pre><code>/**\n * Bundles an agent's code and dependencies into a single file\n * @param fileUrl URL to the agent's main file\n * @returns A Promise resolving to the bundled code as a string\n */\nfunction bundle(fileUrl: URL): Promise&lt;string&gt;;\n</code></pre>"},{"location":"api/index.html#taskhandlerproxy","title":"taskHandlerProxy","text":"<p>Simplifies agent implementation for quick agents.</p> <pre><code>/**\n * Wraps agent logic for use in managed environments\n * @param agentLogic The agent's main function\n * @returns A Promise that resolves when the agent completes\n */\nfunction taskHandlerProxy(\n  agentLogic: (context: TaskContext) =&gt; AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt;\n): Promise&lt;void&gt;;\n</code></pre>"},{"location":"api/index.html#fetchresponseproxy","title":"fetchResponseProxy","text":"<p>Enables communication between quick agents.</p> <pre><code>/**\n * Fetches a response from another agent in the Artinet ecosystem\n * @param agentID Name of the agent to call\n * @param messages Array of message objects to send to the target agent\n * @returns A Promise resolving to the agent's response string\n */\nfunction fetchResponseProxy(\n  agentID: string,\n  messages: { role: string; content: string }[]\n): Promise&lt;string&gt;;\n</code></pre>"},{"location":"api/index.html#testdeployment","title":"testDeployment","text":"<p>Tests a deployment in a temporary sandbox environment.</p> <pre><code>/**\n * Tests an agent deployment in a sandboxed environment\n * @param params Deployment parameters including the agent code\n * @param requests Test requests to send to the deployed agent\n * @returns An AsyncGenerator yielding deployment responses\n */\nfunction testDeployment(\n  params: ServerDeploymentRequestParams,\n  requests: SendTaskRequest[]\n): AsyncGenerator&lt;Task | ServerDeploymentResponse | null&gt;;\n</code></pre>"},{"location":"api/index.html#deployment-types","title":"Deployment Types","text":"<pre><code>/**\n * Parameters for agent deployment\n */\ninterface ServerDeploymentRequestParams {\n  /**\n   * The bundled agent code\n   */\n  code: string;\n\n  /**\n   * Name of the agent\n   */\n  name: string;\n\n  /**\n   * The agent card defining capabilities and metadata\n   */\n  agentCard: AgentCard;\n\n  /**\n   * Optional NPM dependencies\n   */\n  dependencies?: string[];\n}\n\n/**\n * Response from a deployment test\n */\ninterface ServerDeploymentResponse {\n  /**\n   * The deployment ID\n   */\n  deploymentId: string;\n\n  /**\n   * Whether the deployment was successful \n   */\n  success: boolean;\n\n  /**\n   * The name of the server (if successful)\n   */\n  name?: string;\n\n  /**\n   * The URL of the server (if successful)\n   */\n  url?: string;\n\n  /**\n   * The base path of the server (if successful)\n   */\n  basePath?: string;\n}\n</code></pre>"},{"location":"api/index.html#core-types","title":"Core Types","text":"<p>The SDK includes comprehensive TypeScript definitions for all A2A Protocol types. Here are the most important ones:</p>"},{"location":"api/index.html#agentcard","title":"AgentCard","text":"<p>Describes the agent's capabilities, metadata, skills, and endpoint URL.</p> <pre><code>interface AgentCard {\n  /**\n   * The name of the agent\n   */\n  name: string;\n\n  /**\n   * The URL where the agent can be reached\n   */\n  url: string;\n\n  /**\n   * The agent's version\n   */\n  version: string;\n\n  /**\n   * Description of the agent's purpose\n   */\n  description?: string;\n\n  /**\n   * The agent's capabilities\n   */\n  capabilities: {\n    /**\n     * Whether the agent supports streaming\n     */\n    streaming?: boolean;\n\n    /**\n     * Whether the agent supports push notifications\n     */\n    pushNotifications?: boolean;\n\n    /**\n     * Whether the agent supports state transition history\n     */\n    stateTransitionHistory?: boolean;\n  };\n\n  /**\n   * Skills the agent provides\n   */\n  skills: Array&lt;{\n    /**\n     * Unique identifier for the skill\n     */\n    id: string;\n\n    /**\n     * Human-readable name for the skill\n     */\n    name: string;\n\n    /**\n     * Description of what the skill does\n     */\n    description?: string;\n  }&gt;;\n}\n</code></pre>"},{"location":"api/index.html#task","title":"Task","text":"<p>Represents the state and metadata of an A2A task.</p> <pre><code>interface Task {\n  /**\n   * Unique identifier for the task\n   */\n  id: string;\n\n  /**\n   * Current status of the task\n   */\n  status: TaskStatus;\n\n  /**\n   * Optional message that initiated this task\n   */\n  message?: Message;\n\n  /**\n   * Optional session identifier\n   */\n  sessionId?: string;\n\n  /**\n   * Custom metadata associated with the task\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n\n  /**\n   * Artifacts generated during task execution\n   */\n  artifacts?: Artifact[];\n}\n</code></pre>"},{"location":"api/index.html#message","title":"Message","text":"<p>Represents a message in the A2A protocol.</p> <pre><code>interface Message {\n  /**\n   * Who sent the message\n   */\n  role: \"user\" | \"agent\";\n\n  /**\n   * Content parts of the message\n   */\n  parts: Part[];\n\n  /**\n   * Optional metadata about the message\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"api/index.html#part","title":"Part","text":"<p>Represents a part of a message in the A2A protocol.</p> <pre><code>type Part = TextPart | FilePart | DataPart;\n\ninterface TextPart {\n  /**\n   * Type identifier\n   */\n  type: \"text\";\n\n  /**\n   * Text content\n   */\n  text: string;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n\ninterface FilePart {\n  /**\n   * Type identifier\n   */\n  type: \"file\";\n\n  /**\n   * File content\n   */\n  file: FileContent;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n\ninterface DataPart {\n  /**\n   * Type identifier\n   */\n  type: \"data\";\n\n  /**\n   * Structured data\n   */\n  data: Record&lt;string, unknown&gt;;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"api/index.html#artifact","title":"Artifact","text":"<p>Represents an artifact generated during a task.</p> <pre><code>interface Artifact {\n  /**\n   * Name of the artifact\n   */\n  name?: string;\n\n  /**\n   * Description of the artifact\n   */\n  description?: string;\n\n  /**\n   * MIME type of the artifact\n   */\n  mimeType?: string;\n\n  /**\n   * Content parts of the artifact\n   */\n  parts: Part[];\n\n  /**\n   * Optional index for ordering\n   */\n  index?: number;\n\n  /**\n   * Whether to append to existing content\n   */\n  append?: boolean;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n\n  /**\n   * Whether this is the last chunk\n   */\n  lastChunk?: boolean;\n}\n</code></pre>"},{"location":"api/index.html#taskstatus","title":"TaskStatus","text":"<p>Represents the status of an A2A task.</p> <pre><code>interface TaskStatus {\n  /**\n   * Current state of the task\n   */\n  state: TaskState;\n\n  /**\n   * Optional message describing the status\n   */\n  message?: Message;\n\n  /**\n   * Timestamp when the status was recorded\n   */\n  timestamp?: string;\n}\n</code></pre>"},{"location":"api/index.html#stream-event-types","title":"Stream Event Types","text":"<pre><code>/**\n * Event emitted when a task's status changes\n */\ninterface TaskStatusUpdateEvent {\n  /**\n   * Task ID\n   */\n  id: string;\n\n  /**\n   * The new status\n   */\n  status: TaskStatus;\n\n  /**\n   * Whether this is the final update\n   */\n  final?: boolean;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n\n/**\n * Event emitted when a task generates an artifact\n */\ninterface TaskArtifactUpdateEvent {\n  /**\n   * Task ID\n   */\n  id: string;\n\n  /**\n   * The generated artifact\n   */\n  artifact: Artifact;\n\n  /**\n   * Whether this is the final update\n   */\n  final?: boolean;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"api/bundler.html","title":"Agent Bundler","text":""},{"location":"api/bundler.html#bundle","title":"bundle","text":"<p>Bundles a given JavaScript or TypeScript file into a single minified ES module string. This utility leverages <code>esbuild</code> for efficient bundling, minification, and sourcemap generation. It's designed to prepare agent code for deployment by packaging it and its local dependencies.</p> <p>@param filePath - The URL of the entry point file to bundle. @returns A promise that resolves to a string containing the bundled and minified code. @throws An error if the file path does not exist, is not a file, or if bundling fails for any reason.</p> <pre><code>(filePath: URL): Promise&lt;string&gt; {\n  const entryPath = fileURLToPath(filePath);\n  logDebug(\n    `bundler: `,\n    `Attempting to recursively read imports starting from:`,\n    entryPath\n  );\n  try {\n    const fs = await import(\"node:fs\");\n    const stats = fs.statSync(entryPath);\n    if (!stats.isFile()) {\n      logError(`bundler: `, `Filepath is not a file:`, entryPath);\n      throw new Error(\n        `// BUNDLING FAILED: Filepath is not a file: ${entryPath}`\n      );\n    }\n    logDebug(`bundler: `, `Filepath exists:`, entryPath);\n  } catch (err: any) {\n    logError(`bundler: `, `Filepath does not exist:`, entryPath);\n    throw new Error(\n      `// BUNDLING FAILED: Filepath does not exist: ${entryPath}`\n    );\n  }\n\n  try {\n    const result = await esbuild.build({\n      entryPoints: [entryPath],\n      bundle: true,\n      minify: true,\n      sourcemap: true,\n      platform: \"node\",\n      format: \"esm\",\n      write: false,\n    });\n    const output = result?.outputFiles?.[0]?.text ?? \"\";\n    logDebug(\n      `bundler: Successfully read and bundled code:`,\n      output.length.toString()\n    );\n    return output;\n  } catch (err: any) {\n    logError(`bundler: `, `Error during recursive read:`, err.message);\n    throw new Error(`// BUNDLING FAILED: ${err.message}`);\n  }\n}\n</code></pre>"},{"location":"api/client.html","title":"A2AClient","text":""},{"location":"api/client.html#a2aclient_1","title":"A2AClient","text":"<p>A2AClient is the main client class for interacting with Agent2Agent (A2A) protocol-compliant services. It provides methods for sending tasks, retrieving statuses, canceling operations, and handling streaming responses.</p> <pre><code>export class A2AClient implements Client {\n  private baseUrl: URL;\n  private cachedAgentCard: AgentCard | null = null;\n  private customHeaders: Record&lt;string, string&gt; = {};\n  private fallbackPath: string;\n  /**\n   * Creates a new A2AClient instance.\n   * @param baseUrl The base URL for the A2A server.\n   * @param headers Optional custom headers to include in all requests.\n   */\n  constructor(\n    baseUrl: URL | string,\n    headers: Record&lt;string, string&gt; = {},\n    fallbackPath?: string\n  ) {\n    this.baseUrl = typeof baseUrl === \"string\" ? new URL(baseUrl) : baseUrl;\n    this.customHeaders = headers;\n    this.fallbackPath = fallbackPath ?? \"/agent-card\";\n  }\n\n  /**\n   * Retrieves the AgentCard from the A2A server.\n   * Caches the result after the first successful fetch.\n   * @returns A promise resolving to the AgentCard.\n   */\n  async agentCard(): Promise&lt;AgentCard&gt; {\n    if (this.cachedAgentCard) {\n      return this.cachedAgentCard;\n    }\n\n    // Standard location for agent cards\n    const wellKnownUrl = new URL(\"/.well-known/agent.json\", this.baseUrl);\n\n    try {\n      try {\n        const card = await executeGetRequest&lt;AgentCard&gt;(\n          wellKnownUrl,\n          this.customHeaders,\n          \"agent card (well-known)\"\n        );\n\n        this.cachedAgentCard = card;\n\n        return this.cachedAgentCard;\n      } catch (error) {\n        const fallbackUrl = new URL(this.fallbackPath, this.baseUrl);\n\n        const fallbackCard = await executeGetRequest&lt;AgentCard&gt;(\n          fallbackUrl,\n          this.customHeaders,\n          \"agent card (fallback)\"\n        );\n\n        this.cachedAgentCard = fallbackCard;\n\n        return this.cachedAgentCard;\n      }\n    } catch (error) {\n      logError(\n        \"A2AClient:agentCard\",\n        \"Failed to fetch or parse agent card:\",\n        error\n      );\n\n      throw INTERNAL_ERROR(\n        `Could not retrieve agent card: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Refreshes the cached AgentCard by fetching it again from the server.\n   * @returns A promise resolving to the updated AgentCard.\n   */\n  async refreshAgentCard(): Promise&lt;AgentCard&gt; {\n    this.cachedAgentCard = null;\n    return this.agentCard();\n  }\n\n  /**\n   * Sends a task request to the agent (non-streaming).\n   * @param params The parameters for the tasks/send method.\n   * @returns A promise resolving to the Task object or null.\n   */\n  async sendTask(params: TaskSendParams): Promise&lt;Task | null&gt; {\n    return await executeJsonRpcRequest&lt;SendTaskRequest, SendTaskResponse&gt;(\n      this.baseUrl,\n      \"tasks/send\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Sends a task and returns a subscription to status and artifact updates.\n   * @param params Task parameters for the request\n   * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.\n   */\n  sendTaskSubscribe(\n    params: TaskSendParams\n  ): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt; {\n    return executeStreamEvents&lt;\n      SendTaskStreamingRequest,\n      { result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent }\n    &gt;(this.baseUrl, \"tasks/sendSubscribe\", params, this.customHeaders);\n  }\n\n  /**\n   * Retrieves the current state of a task.\n   * @param params The parameters for the tasks/get method.\n   * @returns A promise resolving to the Task object or null.\n   */\n  async getTask(params: TaskQueryParams): Promise&lt;Task | null&gt; {\n    return await executeJsonRpcRequest&lt;GetTaskRequest, GetTaskResponse&gt;(\n      this.baseUrl,\n      \"tasks/get\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Cancels a currently running task.\n   * @param params The parameters for the tasks/cancel method.\n   * @returns A promise resolving to the updated Task object (usually canceled state) or null.\n   */\n  async cancelTask(params: TaskIdParams): Promise&lt;Task | null&gt; {\n    return await executeJsonRpcRequest&lt;CancelTaskRequest, CancelTaskResponse&gt;(\n      this.baseUrl,\n      \"tasks/cancel\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Sets or updates the push notification config for a task.\n   * @param params The parameters for the tasks/pushNotification/set method (which is TaskPushNotificationConfig).\n   * @returns A promise resolving to the confirmed TaskPushNotificationConfig or null.\n   */\n  async setTaskPushNotification(\n    params: TaskPushNotificationConfig\n  ): Promise&lt;TaskPushNotificationConfig | null&gt; {\n    return await executeJsonRpcRequest&lt;\n      SetTaskPushNotificationRequest,\n      SetTaskPushNotificationResponse\n    &gt;(this.baseUrl, \"tasks/pushNotification/set\", params, this.customHeaders);\n  }\n\n  /**\n   * Retrieves the currently configured push notification config for a task.\n   * @param params The parameters for the tasks/pushNotification/get method.\n   * @returns A promise resolving to the TaskPushNotificationConfig or null.\n   */\n  async getTaskPushNotification(\n    params: TaskIdParams\n  ): Promise&lt;TaskPushNotificationConfig | null&gt; {\n    return await executeJsonRpcRequest&lt;\n      GetTaskPushNotificationRequest,\n      GetTaskPushNotificationResponse\n    &gt;(this.baseUrl, \"tasks/pushNotification/get\", params, this.customHeaders);\n  }\n\n  /**\n   * Resubscribes to an existing task's update stream.\n   * @param params Parameters identifying the task to resubscribe to\n   * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.\n   */\n  resubscribeTask(\n    params: TaskQueryParams\n  ): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt; {\n    return executeStreamEvents&lt;\n      TaskResubscriptionRequest,\n      { result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent }\n    &gt;(this.baseUrl, \"tasks/resubscribe\", params, this.customHeaders);\n  }\n\n  /**\n   * Checks if the server supports a specific capability based on the agent card.\n   * @param capability The capability to check (e.g., 'streaming', 'pushNotifications').\n   * @returns A promise resolving to true if the capability is supported.\n   */\n  async supports(\n    capability: \"streaming\" | \"pushNotifications\" | \"stateTransitionHistory\"\n  ): Promise&lt;boolean&gt; {\n    try {\n      const card = await this.agentCard();\n\n      if (!card.capabilities) {\n        return false;\n      }\n\n      switch (capability) {\n        case \"streaming\":\n          return !!card.capabilities.streaming;\n        case \"pushNotifications\":\n          return !!card.capabilities.pushNotifications;\n        case \"stateTransitionHistory\":\n          return !!card.capabilities.stateTransitionHistory;\n        default:\n          return false;\n      }\n    } catch (error) {\n      logError(\n        \"A2AClient:supports\",\n        `Failed to determine support for capability '${capability}':`,\n        error\n      );\n      return false; // Assume not supported if card fetch fails\n    }\n  }\n\n  /**\n   * Sets custom headers to be included in all requests.\n   * @param headers A record of header name/value pairs.\n   */\n  setHeaders(headers: Record&lt;string, string&gt;): void {\n    this.customHeaders = { ...headers };\n  }\n\n  /**\n   * Adds a single custom header to be included in all requests.\n   * @param name The header name.\n   * @param value The header value.\n   */\n  addHeader(name: string, value: string): void {\n    this.customHeaders[name] = value;\n  }\n\n  /**\n   * Removes a custom header.\n   * @param name The header name to remove.\n   */\n  removeHeader(name: string): void {\n    delete this.customHeaders[name];\n  }\n\n  /**\n   * Clears all custom headers.\n   */\n  clearHeaders(): void {\n    this.customHeaders = {};\n  }\n}\n</code></pre>"},{"location":"api/server.html","title":"A2AServer","text":""},{"location":"api/server.html#a2aserver_1","title":"A2AServer","text":"<p>Implements an A2A protocol compliant server using Express. Handles task creation, streaming, cancellation and more. Uses Jayson for JSON-RPC handling.</p> <pre><code>implements Server {\n  private taskHandler: TaskHandler;\n  private taskStore: TaskStore;\n  private corsOptions: CorsOptions;\n  private basePath: string;\n  private port: number;\n  private rpcServer: JSONRPCServerType;\n  private serverInstance: http.Server | undefined;\n  private app: express.Express;\n  private fallbackPath: string;\n  private register: boolean;\n  private activeCancellations: Set&lt;string&gt; = new Set();\n  private activeStreams: Map&lt;string, Response[]&gt; = new Map();\n\n  /** The agent card representing this server */\n  public card!: AgentCard;\n\n  /**\n   * Returns the base path for the server\n   */\n  getBasePath(): string {\n    return this.basePath;\n  }\n\n  /**\n   * Returns the CORS options for the server\n   */\n  getCorsOptions(): CorsOptions {\n    return this.corsOptions;\n  }\n\n  /**\n   * Returns the agent card for the server\n   */\n  getCard(): AgentCard {\n    return this.card;\n  }\n\n  /**\n   * Returns the task store\n   */\n  getTaskStore(): TaskStore {\n    return this.taskStore;\n  }\n\n  /**\n   * Returns the task handler\n   */\n  getTaskHandler(): TaskHandler {\n    return this.taskHandler;\n  }\n\n  /**\n   * Returns the set of active cancellations\n   */\n  getActiveCancellations(): Set&lt;string&gt; {\n    return this.activeCancellations;\n  }\n\n  /**\n   * Returns the map of active streams\n   */\n  getActiveStreams(): Map&lt;string, Response[]&gt; {\n    return this.activeStreams;\n  }\n\n  /**\n   * Returns the port number\n   */\n  getPort(): number {\n    return this.port;\n  }\n\n  /**\n   * Returns the JSON-RPC server\n   */\n  getRpcServer(): JSONRPCServerType {\n    return this.rpcServer;\n  }\n\n  /**\n   * Returns the server instance\n   */\n  getServerInstance(): http.Server | undefined {\n    return this.serverInstance;\n  }\n\n  /**\n   * Returns the Express app\n   */\n  getExpressApp(): express.Express {\n    return this.app;\n  }\n\n  /**\n   * Returns a task context for the specified task and messages\n   */\n  getTaskContext(\n    task: Task,\n    userMessage: Message,\n    history: Message[]\n  ): TaskContext {\n    return this.createTaskContext(task, userMessage, history);\n  }\n\n  /**\n   * Returns the default agent card\n   */\n  defaultAgentCard(): AgentCard {\n    return A2AServer.defaultAgentCard();\n  }\n\n  /**\n   * Creates a new A2AServer.\n   * @param handler The task handler function that will process tasks\n   * @param options Options for configuring the server\n   */\n  constructor(params: A2AServerParams) {\n    // Store the handler\n    this.taskHandler = params.handler;\n\n    // Set up store\n    this.taskStore = params.taskStore ?? new InMemoryTaskStore();\n\n    // Configure CORS\n    this.corsOptions = params.corsOptions ?? {\n      origin: \"*\",\n      methods: [\"GET\", \"POST\"],\n      allowedHeaders: [\"Content-Type\"],\n    };\n\n    // Set port\n    this.port = params.port ?? 41241;\n\n    let basePath = params.basePath ?? \"/\";\n\n    if (basePath !== \"/\") {\n      basePath = `/${basePath.replace(/^\\/|\\/$/g, \"\")}/`;\n    }\n    this.basePath = basePath;\n    // Set up default agent card if not provided\n    this.card = params.card ?? A2AServer.defaultAgentCard();\n\n    // Initialize the Jayson server\n    this.rpcServer = params.createJSONRPCServer\n      ? params.createJSONRPCServer({\n          taskStore: this.taskStore,\n          card: this.card,\n          taskHandler: this.taskHandler,\n          activeCancellations: this.activeCancellations,\n          createTaskContext: this.createTaskContext.bind(this),\n          closeStreamsForTask: this.closeStreamsForTask.bind(this),\n        })\n      : defaultCreateJSONRPCServer({\n          taskStore: this.taskStore,\n          card: this.card,\n          taskHandler: this.taskHandler,\n          activeCancellations: this.activeCancellations,\n          createTaskContext: this.createTaskContext.bind(this),\n          closeStreamsForTask: this.closeStreamsForTask.bind(this),\n        });\n\n    this.fallbackPath = params.fallbackPath ?? \"/agent-card\";\n\n    const { app } = createExpressServer({\n      card: this.card,\n      corsOptions: this.corsOptions,\n      basePath: this.basePath,\n      port: this.port,\n      rpcServer: this.rpcServer,\n      fallbackPath: this.fallbackPath,\n      errorHandler: errorHandler,\n      onTaskSendSubscribe: this.handleTaskSendSubscribe.bind(this),\n      onTaskResubscribe: this.handleTaskResubscribe.bind(this),\n    });\n    this.app = app;\n\n    //register your server with the A2A registry on startup\n    this.register = params.register ?? false;\n\n    logDebug(\"A2AServer\", \"Server initialized\", {\n      basePath: this.basePath,\n      port: this.port,\n      corsEnabled: !!this.corsOptions,\n    });\n  }\n\n  /**\n   * Starts the Express server listening on the specified port.\n   * @returns The running Express application instance.\n   */\n  start(): express.Express {\n    if (this.serverInstance) {\n      throw new Error(\"Server already started\");\n    }\n\n    const server = this.app.listen(this.port, () =&gt; {\n      logInfo(\"A2AServer\", `A2A Server started and listening`, {\n        port: this.port,\n        path: this.basePath,\n      });\n    });\n\n    this.serverInstance = server;\n    //lazily register your server with the A2A registry on startup\n    //this is so that you can start the server without having to wait for registration\n    //you can call also call this.registerServer() later to register your server\n    if (this.register) {\n      this.registerServer();\n    }\n    return this.app;\n  }\n\n  /**\n   * Stops the server and closes all connections.\n   * @returns A promise that resolves when the server is stopped.\n   */\n  async stop(): Promise&lt;void&gt; {\n    if (!this.serverInstance) {\n      return;\n    }\n\n    // Close all active streams first\n    this.activeStreams.forEach((streams, taskId) =&gt; {\n      if (streams.length &gt; 0) {\n        logDebug(\"A2AServer\", \"Closing streams for task during stop\", {\n          taskId,\n        });\n        this.closeStreamsForTask(taskId);\n      }\n    });\n    this.activeStreams.clear();\n\n    const closeServer = util\n      .promisify(this.serverInstance.close)\n      .bind(this.serverInstance);\n\n    try {\n      await closeServer();\n      logDebug(\"A2AServer\", \"Server stopped successfully.\");\n      this.serverInstance = undefined;\n    } catch (err) {\n      logDebug(\"A2AServer\", \"Error stopping server:\", err);\n      this.serverInstance = undefined;\n      throw err;\n    }\n  }\n\n  /**\n   * Registers the server with the A2A registry.\n   * @returns A promise that resolves to the registration ID or an empty string if registration fails.\n   */\n  public async registerServer(): Promise&lt;string&gt; {\n    if (this.card) {\n      return await register(this.card);\n    }\n    return \"\";\n  }\n\n  /**\n   * Handles task cancellation\n   * @param data Task and history data\n   * @param res Response object\n   */\n  public async onCancel(data: TaskAndHistory, res: Response): Promise&lt;void&gt; {\n    const currentData = await updateState(this.taskStore, data, CANCEL_UPDATE);\n\n    // Send the canceled status\n    sendSSEEvent(res, {\n      id: currentData.task.id,\n      status: currentData.task.status,\n      final: true,\n    });\n\n    this.closeStreamsForTask(currentData.task.id);\n  }\n\n  /**\n   * Handles cleanup when a task stream ends\n   * @param taskId The task ID\n   * @param res Response object\n   */\n  public async onEnd(taskId: string, res: Response): Promise&lt;void&gt; {\n    this.activeCancellations.delete(taskId);\n    this.removeStreamForTask(taskId, res);\n  }\n\n  /**\n   * Handles the tasks/sendSubscribe method.\n   * @param req The SendTaskRequest object\n   * @param res The Express Response object\n   */\n  public async handleTaskSendSubscribe(\n    req: SendTaskStreamingRequest,\n    res: Response\n  ): Promise&lt;void&gt; {\n    validateTaskSendParams(req.params);\n    const { id: taskId, message, sessionId, metadata } = req.params;\n\n    // Set up SSE stream with initial status\n    setupSseStream(\n      res,\n      taskId,\n      {\n        id: taskId,\n        status: {\n          state: \"submitted\",\n          timestamp: getCurrentTimestamp(),\n        },\n      },\n      this.addStreamForTask.bind(this)\n    );\n\n    // Load or create task\n    let currentData = await loadState(\n      this.taskStore,\n      taskId,\n      message,\n      sessionId,\n      metadata\n    );\n\n    // Create task context\n    const context = this.createTaskContext(\n      currentData.task,\n      message,\n      currentData.history\n    );\n\n    currentData = await updateState(\n      this.taskStore,\n      currentData,\n      WORKING_UPDATE\n    );\n\n    // Send the working status\n    sendSSEEvent(res, {\n      id: taskId,\n      status: currentData.task.status,\n      final: false,\n    });\n\n    // Process the task using the shared method\n    await processTaskStream(\n      this.taskStore,\n      this.taskHandler,\n      res,\n      taskId,\n      context,\n      currentData,\n      this.onCancel.bind(this),\n      this.onEnd.bind(this)\n    );\n  }\n\n  /**\n   * Handles the tasks/resubscribe method.\n   * @param req The TaskResubscriptionRequest object\n   * @param res The Express Response object\n   */\n  public async handleTaskResubscribe(\n    req: TaskResubscriptionRequest,\n    res: Response\n  ): Promise&lt;void&gt; {\n    const { id: taskId } = req.params;\n    if (!taskId) {\n      console.error(\"Task ID is required\", req);\n      throw INVALID_PARAMS(\"Missing task ID\");\n    }\n\n    // Try to load the task\n    const data = await this.taskStore.load(taskId);\n    if (!data) {\n      throw TASK_NOT_FOUND(\"Task Id: \" + taskId);\n    }\n\n    // Set up SSE stream with current task status\n    setupSseStream(\n      res,\n      taskId,\n      {\n        id: taskId,\n        status: data.task.status,\n        final: false,\n      },\n      this.addStreamForTask.bind(this)\n    );\n\n    // Check if task is in final state\n    if (FINAL_STATES.includes(data.task.status.state)) {\n      // If the task is already complete, send all artifacts and close\n      if (data.task.artifacts &amp;&amp; data.task.artifacts.length &gt; 0) {\n        for (const artifact of data.task.artifacts) {\n          sendSSEEvent(res, {\n            id: taskId,\n            artifact,\n            final: true,\n          });\n        }\n      }\n\n      // Remove from tracking and close\n      this.removeStreamForTask(taskId, res);\n      res.write(\"event: close\\ndata: {}\\n\\n\");\n      res.end();\n      return;\n    }\n\n    // For non-final states, create context and continue processing\n    // We need to use the last user message as the current message\n    const lastUserMessage = data.history\n      .filter((msg) =&gt; msg.role === \"user\")\n      .pop();\n    if (!lastUserMessage) {\n      throw INVALID_REQUEST(\"No user message found\");\n    }\n\n    const context = this.createTaskContext(\n      data.task,\n      lastUserMessage,\n      data.history\n    );\n\n    // Continue processing the task using the shared method\n    await processTaskStream(\n      this.taskStore,\n      this.taskHandler,\n      res,\n      taskId,\n      context,\n      data,\n      this.onCancel.bind(this),\n      this.onEnd.bind(this)\n    );\n  }\n\n  /**\n   * Adds a response stream to the tracking map for a task.\n   * @param taskId The task ID\n   * @param res The response stream\n   */\n  public addStreamForTask(taskId: string, res: Response): void {\n    if (!this.activeStreams.has(taskId)) {\n      this.activeStreams.set(taskId, []);\n    }\n    logDebug(\"A2AServer\", \"Adding stream for task\", {\n      taskId,\n      activeStreams: this.activeStreams,\n    });\n    this.activeStreams.get(taskId)?.push(res);\n  }\n\n  /**\n   * Removes a response stream from the tracking map for a task.\n   * @param taskId The task ID\n   * @param res The response stream\n   */\n  public removeStreamForTask(taskId: string, res: Response): void {\n    const streams = this.activeStreams.get(taskId);\n    if (streams) {\n      const index = streams.indexOf(res);\n      if (index !== -1) {\n        streams.splice(index, 1);\n        if (streams.length === 0) {\n          logDebug(\"A2AServer\", \"Removing stream for task\", {\n            taskId,\n            activeStreams: this.activeStreams,\n          });\n          this.activeStreams.delete(taskId);\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes the default agent card\n   */\n  public static defaultAgentCard(): AgentCard {\n    return {\n      name: \"A2A Server\",\n      description: \"A general-purpose A2A protocol server\",\n      version: \"0.1.0\",\n      url: \"http://localhost\",\n      capabilities: {\n        streaming: true,\n        pushNotifications: false,\n        stateTransitionHistory: true,\n      },\n      skills: [],\n    };\n  }\n\n  /**\n   * Creates a TaskContext object for a task handler.\n   * @param task The task\n   * @param userMessage The user message\n   * @param history The message history\n   * @returns A TaskContext object\n   */\n  public createTaskContext(\n    task: Task,\n    userMessage: Message,\n    history: Message[]\n  ): TaskContext {\n    return {\n      task,\n      userMessage,\n      history,\n      isCancelled: () =&gt; this.activeCancellations.has(task.id),\n    };\n  }\n\n  /**\n   * Closes any active streams for a task.\n   * @param taskId The task ID\n   */\n  public closeStreamsForTask(taskId: string): void {\n    const streams = this.activeStreams.get(taskId);\n    if (streams) {\n      // Send close event to all streams\n      for (const stream of streams) {\n        if (stream.writable) {\n          stream.write(\"event: close\\ndata: {}\\n\\n\");\n          stream.end();\n        }\n      }\n      this.activeStreams.delete(taskId);\n    }\n  }\n}\n</code></pre>"},{"location":"api/task-context.html","title":"Task Context","text":""},{"location":"api/task-context.html#taskcontext","title":"TaskContext","text":"<p>Context object provided to the TaskHandler. Contains the information needed for the handler to process the task.</p> <pre><code>{\n  /**\n   * The current state of the task when the handler is invoked or resumed.\n   * This is a snapshot - the latest state may need to be reloaded during async operations.\n   */\n  task: Task;\n\n  /**\n   * The specific user message that triggered this handler invocation or resumption.\n   */\n  userMessage: Message;\n\n  /**\n   * Function to check if cancellation has been requested for this task.\n   * Handlers should check this periodically during long-running operations.\n   * @returns True if cancellation has been requested, false otherwise.\n   */\n  isCancelled(): boolean;\n\n  /**\n   * The message history associated with the task up to the point the handler is invoked.\n   */\n  history: Message[];\n}\n</code></pre>"},{"location":"api/task-context.html#taskhandler","title":"TaskHandler","text":"<p>The current state of the task when the handler is invoked or resumed. This is a snapshot - the latest state may need to be reloaded during async operations. /   task: Task;</p> <p>/** The specific user message that triggered this handler invocation or resumption. /   userMessage: Message;</p> <p>/** Function to check if cancellation has been requested for this task. Handlers should check this periodically during long-running operations. @returns True if cancellation has been requested, false otherwise. /   isCancelled(): boolean;</p> <p>/** The message history associated with the task up to the point the handler is invoked. /   history: Message[]; }</p> <p>/** Defines the signature for a task handler function.</p> <p>Handlers are implemented as async generators. They receive context about the task and the triggering message. They perform work and yield status or artifact updates (TaskYieldUpdate). The server consumes these yields, updates the task state in the store, and streams events if applicable.</p> <p>@param context The TaskContext object containing task details and state. @yields Updates to the task's status or artifacts. @returns Optionally returns the final complete Task object (needed for non-streaming 'tasks/send').   If void is returned, the server uses the last known state after processing all yields.</p> <pre><code>task: Task;\n</code></pre>"},{"location":"contributing/code-documentation.html","title":"Code Documentation Guidelines","text":"<p>When contributing to the Artinet SDK, please use the following Doxygen-style comment patterns to ensure consistent documentation.</p>"},{"location":"contributing/code-documentation.html#class-documentation","title":"Class Documentation","text":"<pre><code>/**\n * @brief Brief description of the class\n * \n * Detailed description of what the class does and how to use it.\n * Include any important concepts or patterns the class implements.\n * \n * @example\n * ```typescript\n * const instance = new ExampleClass(params);\n * instance.doSomething();\n * ```\n */\nclass ExampleClass {\n  // Class implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#method-documentation","title":"Method Documentation","text":"<pre><code>/**\n * @brief Brief description of the method\n * \n * Detailed description of what the method does, including any side effects\n * or state changes it causes. Mention any exceptions that might be thrown.\n * \n * @param paramName Description of the parameter, including type constraints and requirements\n * @param optionalParam Description of an optional parameter and its default value if omitted\n * @return Description of what the method returns, including possible error states\n * \n * @example\n * ```typescript\n * const result = instance.methodName(\"input value\");\n * console.log(result); // Expected output\n * ```\n */\npublic methodName(paramName: string, optionalParam?: number): ReturnType {\n  // Method implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#interface-documentation","title":"Interface Documentation","text":"<pre><code>/**\n * @brief Brief description of the interface\n * \n * Detailed explanation of the interface purpose and usage patterns.\n * Include information about when and why this interface should be implemented.\n * \n * @example\n * ```typescript\n * class MyImplementation implements ExampleInterface {\n *   // Implementation details\n * }\n * ```\n */\ninterface ExampleInterface {\n  /**\n   * @brief Description of the property\n   */\n  propertyName: string;\n\n  /**\n   * @brief Description of the method\n   * @param input Description of parameter\n   * @return Description of return value\n   */\n  methodName(input: InputType): OutputType;\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#type-definition-documentation","title":"Type Definition Documentation","text":"<pre><code>/**\n * @brief Brief description of the type\n * \n * Detailed explanation of what this type represents and when to use it.\n * Include any constraints or special considerations.\n * \n * @example\n * ```typescript\n * const value: ExampleType = {\n *   property: \"value\"\n * };\n * ```\n */\ntype ExampleType = {\n  property: string;\n  optional?: number;\n};\n</code></pre>"},{"location":"contributing/code-documentation.html#function-documentation","title":"Function Documentation","text":"<pre><code>/**\n * @brief Brief description of the function\n * \n * Detailed explanation of what the function does, including any side effects.\n * \n * @param input Description of the input parameter\n * @return Description of the return value\n * @throws Description of any exceptions that might be thrown\n * \n * @example\n * ```typescript\n * const result = utilityFunction(\"input\");\n * ```\n */\nfunction utilityFunction(input: string): number {\n  // Function implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#constants-documentation","title":"Constants Documentation","text":"<pre><code>/**\n * @brief Brief description of the constant\n * \n * Additional details about the constant, including where and how it's used.\n */\nconst IMPORTANT_CONSTANT = \"value\";\n</code></pre>"},{"location":"contributing/code-documentation.html#file-headers","title":"File Headers","text":"<p>Each file should include a header comment describing the file's contents:</p> <pre><code>/**\n * @fileoverview Brief description of the file\n * \n * Detailed description of the file contents, purpose, and any important\n * concepts or patterns used within. Mention any dependencies.\n * \n * @example\n * ```typescript\n * import { Something } from './this-file';\n * ```\n */\n</code></pre>"},{"location":"contributing/code-documentation.html#deprecation-notices","title":"Deprecation Notices","text":"<pre><code>/**\n * @brief Brief description of the deprecated item\n * \n * @deprecated This feature will be removed in version X.Y.Z.\n * Use NewFeature instead.\n * \n * @see {@link NewFeature} for the recommended alternative\n */\n</code></pre> <p>Following these guidelines will ensure that the SDK's documentation is consistent and comprehensive, making it easier for developers to understand and use the library correctly.</p>"},{"location":"sdk/core.html","title":"Core SDK Components","text":"<p>This page provides a comprehensive overview of the main classes, types, and utilities available in the Artinet SDK. These are the fundamental building blocks you'll use to create and interact with A2A-compliant agents.</p>"},{"location":"sdk/core.html#a2aserver","title":"A2AServer","text":"<ul> <li>The primary class for instantiating and running an A2A agent server. It manages the agent's lifecycle, handles incoming requests, executes tasks via a <code>TaskHandler</code>, and uses a <code>TaskStore</code> for persistence. Built on Express.js, it automatically handles JSON-RPC complexity, routing, A2A protocol compliance, and Server-Sent Events (SSE) streaming.</li> </ul> <pre><code>// Key methods\nstart(): express.Express;  // Starts the server and returns the Express app\nstop(): Promise&lt;void&gt;;     // Stops the server and closes all connections\ngetExpressApp(): express.Express;  // Returns the underlying Express app for customization\nregisterServer(): Promise&lt;string&gt;; // Registers the server with the A2A registry\n</code></pre>"},{"location":"sdk/core.html#a2aclient","title":"A2AClient","text":"<ul> <li>The client class used to connect to an <code>A2AServer</code> instance. It allows you to send tasks (using <code>sendTask</code> for single responses or <code>sendTaskSubscribe</code> for streaming updates) and manage communication headers. Features refined error handling via <code>RpcError</code>, flexible header management for authentication, and clear separation of concerns.</li> </ul> <pre><code>// Key methods\nasync sendTask(params: TaskSendParams): Promise&lt;Task | null&gt;;\nsendTaskSubscribe(params: TaskSendParams): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\nasync getTask(params: TaskQueryParams): Promise&lt;Task | null&gt;;\nasync cancelTask(params: TaskIdParams): Promise&lt;Task | null&gt;;\nasync supports(capability: \"streaming\" | \"pushNotifications\" | \"stateTransitionHistory\"): Promise&lt;boolean&gt;;\naddHeader(name: string, value: string): void;\nsetHeaders(headers: Record&lt;string, string&gt;): void;\n</code></pre>"},{"location":"sdk/core.html#taskhandler-type","title":"TaskHandler (Type)","text":"<ul> <li>An asynchronous generator function (<code>async function*</code>) type that defines the core logic of an agent. It receives a <code>TaskContext</code> and yields <code>TaskYieldUpdate</code> objects to report progress and results. This is where you implement your agent's main functionality, processing user messages and generating responses.</li> </ul> <pre><code>type TaskHandler = (\n  context: TaskContext\n) =&gt; AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt;;\n</code></pre>"},{"location":"sdk/core.html#taskcontext-interfacetype","title":"TaskContext (Interface/Type)","text":"<ul> <li>An object passed as an argument to the <code>TaskHandler</code>. It provides task details such as <code>userMessage</code>, <code>taskId</code>, and methods like <code>isCancelled()</code> to check if a task should be aborted. Use this to access user inputs and manage the agent's execution flow.</li> </ul> <pre><code>interface TaskContext {\n  task: Task;              // Current task state\n  userMessage: Message;    // Message that triggered this task\n  history: Message[];      // Previous messages in this conversation\n  isCancelled(): boolean;  // Check if cancellation was requested\n}\n</code></pre>"},{"location":"sdk/core.html#message-interfacetype","title":"Message (Interface/Type)","text":"<ul> <li>Defines the structure for messages exchanged between users and agents, or between agents. It includes a <code>role</code> (e.g., 'user', 'agent') and <code>parts</code> containing the content (e.g., text, images). This structure follows the A2A protocol specifications and ensures standardized communication.</li> </ul> <pre><code>interface Message {\n  role: \"user\" | \"agent\";\n  parts: Part[];           // Content parts (text, file, data)\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"sdk/core.html#inmemorytaskstore","title":"InMemoryTaskStore","text":"<ul> <li>A simple implementation of the <code>TaskStore</code> interface that stores task state and history in memory. Suitable for development, testing, or agents that do not require persistent task data across restarts. Ideal for rapid prototyping and experimentation.</li> </ul> <pre><code>// Usage\nconst store = new InMemoryTaskStore();\nconst server = new A2AServer({\n  handler: myTaskHandler,\n  taskStore: store,\n  // other parameters...\n});\n</code></pre>"},{"location":"sdk/core.html#filestore","title":"FileStore","text":"<ul> <li>An implementation of the <code>TaskStore</code> interface that persists task state and history to the local filesystem in a specified directory. Useful for agents that need to retain task data between server restarts. Ensures your agent can maintain conversation context and task state.</li> </ul> <pre><code>// Usage\nconst dataDir = path.join(process.cwd(), \"task-data\");\nconst store = new FileStore(dataDir);\nconst server = new A2AServer({\n  handler: myTaskHandler,\n  taskStore: store,\n  // other parameters...\n});\n</code></pre>"},{"location":"sdk/core.html#taskstatusupdateevent-interfacetype","title":"TaskStatusUpdateEvent (Interface/Type)","text":"<ul> <li>An event object yielded by a <code>TaskHandler</code> during streaming operations. It includes the current <code>state</code> of the task (e.g., 'working', 'completed', 'error') and can include an updated <code>message</code> from the agent. This allows real-time progress updates to be sent to clients.</li> </ul> <pre><code>interface TaskStatusUpdateEvent {\n  id: string;\n  status: TaskStatus;      // Current state with timestamp\n  final?: boolean;         // True if this is the final update\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"sdk/core.html#taskartifactupdateevent-interfacetype","title":"TaskArtifactUpdateEvent (Interface/Type)","text":"<ul> <li>An event object yielded by a <code>TaskHandler</code> when an agent produces an artifact (like a file) during a task. It includes details about the <code>artifact</code> such as its name, mimeType, and content. This enables agents to share documents, files, or other complex outputs during task execution.</li> </ul> <pre><code>interface TaskArtifactUpdateEvent {\n  id: string;\n  artifact: Artifact;      // The produced artifact\n  final?: boolean;         // True if this is the final update\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"sdk/core.html#logger-configurelogger-logdebug-utilities","title":"logger / configureLogger / logDebug (Utilities)","text":"<ul> <li>A set of logging utilities provided by the SDK. <code>logger</code> is the main logger instance based on the Pino library. <code>configureLogger</code> allows customization of log levels and output. <code>logDebug</code> and similar functions are helpers for common log levels, making it easier to add structured logging to your agent.</li> </ul> <pre><code>// Configure logging level\nconfigureLogger({ level: \"debug\" });  // Options: silent, error, warn, info, debug, trace\n\n// Use logging helpers\nlogDebug(\"ComponentName\", \"Debug message\", optionalData);\nlogInfo(\"ComponentName\", \"Info message\", optionalData);\nlogWarn(\"ComponentName\", \"Warning message\", optionalData);\nlogError(\"ComponentName\", \"Error message\", errorObject, optionalData);\n</code></pre>"},{"location":"sdk/core.html#jsonrpcserverfactory-type","title":"JSONRPCServerFactory (Type)","text":"<ul> <li>A function signature for providing custom JSON-RPC server creation logic to the A2AServer for advanced customization. This allows you to implement custom methods, integrate with existing Express apps, or fine-tune the API behavior to meet specific requirements.</li> </ul> <pre><code>type JSONRPCServerFactory = (\n  params: CreateJSONRPCServerParams\n) =&gt; JSONRPCServerType;\n</code></pre>"},{"location":"sdk/core.html#agentcard-interfacetype","title":"AgentCard (Interface/Type)","text":"<ul> <li>Describes an agent's capabilities, metadata, skills, and endpoint URL. This information is exposed at the standard <code>/.well-known/agent.json</code> endpoint (and optional fallback paths) to enable discovery and interoperability with other A2A-compliant systems.</li> </ul> <pre><code>interface AgentCard {\n  name: string;            // Agent name\n  url: string;             // Endpoint URL\n  version: string;         // Version identifier\n  description?: string;    // Optional description\n  capabilities: {          // Supported features\n    streaming?: boolean;\n    pushNotifications?: boolean;\n    stateTransitionHistory?: boolean;\n  };\n  skills: Array&lt;{          // Agent's abilities\n    id: string;\n    name: string;\n    description?: string;\n  }&gt;;\n  // Additional optional properties\n}\n</code></pre>"},{"location":"sdk/quickstart.html","title":"Quick Start Guide: Artinet SDK","text":"<p>This guide will help you get your first A2A-compliant agent up and running and show you how to interact with it.</p>"},{"location":"sdk/quickstart.html#installation","title":"Installation","text":"<p>First, you need to install the Artinet SDK into your project. If you're using Node.js and npm, you can install it with the following command in your terminal:</p> <p><pre><code>npm install @artinet/sdk\n</code></pre> If you're using Yarn, you can use:</p> <pre><code>yarn add @artinet/sdk\n</code></pre>"},{"location":"sdk/quickstart.html#1-creating-your-first-agent-server-side","title":"1. Creating Your First Agent (Server-Side)","text":"<p>An A2A-compliant agent is essentially a server that can perform tasks. Here's how to create a simple agent that echoes back any text it receives:</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Define the logic for your agent\n// This function is a 'TaskHandler'. It processes incoming tasks.\nconst echoAgentLogic: TaskHandler = async function* (context: TaskContext) {\n  // Extract text from the user's message\n  // (Assuming the message part is text)\n  const userInput =\n    context.userMessage.parts[0]?.type === \"text\"\n      ? context.userMessage.parts[0].text\n      : \"No text provided\";\n\n  // 1. Yield a 'working' state to indicate the task has started\n  yield { state: \"working\" };\n\n  // You could do more complex work here.\n  // For long tasks, you might periodically check `context.isCancelled()`\n\n  // 2. Yield a 'completed' state with the agent's response\n  yield {\n    state: \"completed\",\n    message: { // This is the agent's reply\n      role: \"agent\",\n      parts: [{ type: \"text\", text: `Your agent says: You sent '${userInput}'` }],\n    },\n  };\n};\n\n// Configure and create the A2A Server instance\nconst server = new A2AServer({\n  handler: echoAgentLogic,          // The logic our agent will use\n  taskStore: new InMemoryTaskStore(),   // Stores task information (in memory for this example)\n  port: 4000,                           // The port your agent server will run on\n  basePath: \"/a2a\",                     // The base API path for your agent\n\n  // The 'card' provides metadata about your agent so others can discover it\n  card: {\n    name: \"EchoAgent\",\n    url: \"http://localhost:4000/a2a\", // How to reach this agent\n    version: \"0.1.0\",\n    capabilities: { streaming: true }, // Indicates this agent supports streaming updates\n    skills: [{ id: \"echo\", name: \"Echo Skill\" }], // Describes what the agent can do\n  },\n});\n\n// Start the server\nasync function main() {\n  try {\n    await server.start(); // Start listening for requests\n    console.log(\"EchoAgent server running at http://localhost:4000/a2a\");\n  } catch (error) {\n    console.error(\"Failed to start server:\", error);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"sdk/quickstart.html#key-concepts","title":"Key Concepts:","text":"<ul> <li>TaskHandler: This is the heart of your agent - an asynchronous generator function that processes incoming tasks and yields status updates.</li> <li>TaskContext: Contains information about the task, including the user's message and methods like <code>isCancelled()</code>.</li> <li>A2AServer: Creates and manages your agent server, handling protocol details automatically.</li> <li>AgentCard (in <code>card</code> parameter): Describes your agent's capabilities and how to reach it.</li> </ul>"},{"location":"sdk/quickstart.html#2-interacting-with-your-agent-client-side","title":"2. Interacting with Your Agent (Client-Side)","text":"<p>Now that you have an agent server running, let's send it a task using the A2AClient:</p> <pre><code>import { A2AClient, Message } from \"@artinet/sdk\";\n\nasync function talkToAgent() {\n  // Create a client pointing to your running agent server\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  // Define the message you want to send to the agent\n  const userMessage: Message = {\n    role: \"user\", // Indicates the message is from a user\n    parts: [{ type: \"text\", text: \"Hello Artinet Agent!\" }], // The content of the message\n  };\n\n  try {\n    console.log(\"Sending message to agent...\");\n\n    // Send the task and wait for the final response\n    // 'sendTask' is good for tasks that have a single, final response.\n    const taskResponse = await client.sendTask({\n      id: \"my-echo-task-01\", // A unique ID for this task\n      message: userMessage,\n    });\n\n    console.log(\"Agent responded successfully!\");\n\n    // The final message from the agent is in taskResponse.message\n    if (taskResponse?.message &amp;&amp; taskResponse.message.parts[0]?.type === \"text\") {\n      console.log(\"Agent's final reply:\", taskResponse.message.parts[0].text);\n    } else {\n      console.log(\"Agent's final response structure:\", taskResponse);\n    }\n\n  } catch (error) {\n    console.error(\"Error interacting with agent:\", error);\n  }\n}\n\ntalkToAgent();\n</code></pre>"},{"location":"sdk/quickstart.html#key-concepts_1","title":"Key Concepts:","text":"<ul> <li>A2AClient: Connects to and interacts with A2A-compliant agent servers.</li> <li>Message: Structured format for communication, with a <code>role</code> and <code>parts</code> containing content.</li> <li>sendTask(): Sends a one-time request and waits for the final response.</li> </ul>"},{"location":"sdk/quickstart.html#3-receiving-streaming-updates","title":"3. Receiving Streaming Updates","text":"<p>For long-running tasks or real-time updates, you can use the streaming API:</p> <pre><code>import { A2AClient, TaskStatusUpdateEvent, TaskArtifactUpdateEvent } from \"@artinet/sdk\";\n\nasync function streamFromAgent() {\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  const userMessage = {\n    role: \"user\",\n    parts: [{ type: \"text\", text: \"Process this data please\" }],\n  };\n\n  try {\n    // Use sendTaskSubscribe to get a stream of updates\n    const stream = client.sendTaskSubscribe({\n      id: \"streaming-task-01\",\n      message: userMessage,\n    });\n\n    // Process updates as they arrive\n    for await (const update of stream) {\n      if (\"status\" in update) {\n        const statusUpdate = update as TaskStatusUpdateEvent;\n        console.log(`Task status: ${statusUpdate.status.state}`);\n\n        if (statusUpdate.message?.parts[0]?.type === \"text\") {\n          console.log(`Agent says: ${statusUpdate.message.parts[0].text}`);\n        }\n      } else if (\"artifact\" in update) {\n        // Handle artifact updates\n        const artifactUpdate = update as TaskArtifactUpdateEvent;\n        console.log(`Received artifact: ${artifactUpdate.artifact.name}`);\n      }\n    }\n\n    console.log(\"Stream completed\");\n  } catch (error) {\n    console.error(\"Error with streaming task:\", error);\n  }\n}\n\nstreamFromAgent();\n</code></pre>"},{"location":"sdk/quickstart.html#4-running-the-examples","title":"4. Running the Examples","text":"<p>To run these examples:</p> <ol> <li>Save the server code as <code>myEchoAgent.ts</code></li> <li>Save the client code as <code>runClient.ts</code> or <code>streamClient.ts</code></li> <li>Run the server with <code>npx ts-node myEchoAgent.ts</code></li> <li>In another terminal, run the client with <code>npx ts-node runClient.ts</code></li> </ol>"},{"location":"sdk/quickstart.html#next-steps","title":"Next Steps","text":"<p>Now that you've built your first agent, you can:</p> <ul> <li>Explore more complex examples</li> <li>Learn about the core components of the SDK</li> <li>Add authentication to your agent's endpoints</li> <li>Implement persistent storage with <code>FileStore</code></li> <li>Create agents with advanced capabilities by integrating LLMs or other APIs</li> </ul> <p>The Artinet SDK provides a solid foundation for building sophisticated A2A-compliant agents with minimal boilerplate!</p>"},{"location":"sdk/examples/index.html","title":"Artinet SDK Examples","text":"<p>This section contains examples demonstrating how to use the Artinet SDK.</p>"},{"location":"sdk/examples/index.html#available-examples","title":"Available Examples","text":"<ul> <li>basic-server - Example demonstrating basic-server</li> <li>basic-usage - Example demonstrating basic-usage</li> <li>code-deployment - Example demonstrating code-deployment</li> <li>file-storage-client-continued - Example demonstrating file-storage-client-continued</li> <li>file-storage-client - Example demonstrating file-storage-client</li> <li>file-storage-server - Example demonstrating file-storage-server</li> <li>streaming-updates - Example demonstrating streaming-updates</li> <li>task-resubscribe - Example demonstrating task-resubscribe</li> <li>task-wrapper - Example demonstrating task-wrapper</li> </ul>"},{"location":"sdk/examples/basic-server.html","title":"basic-server","text":"<p>Basic A2A Server Example</p> <p>This example demonstrates how to create a simple A2A server that responds to incoming tasks.</p>"},{"location":"sdk/examples/basic-server.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Basic A2A Server Example\n *\n * This example demonstrates how to create a simple A2A server\n * that responds to incoming tasks.\n */\n\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  configureLogger,\n} from \"../dist/index.js\";\n\n// Configure logging for this example\nconfigureLogger({ level: \"info\" });\n\n/**\n * Implement a simple task handler\n */\nasync function* simpleEchoAgent(context) {\n  // Extract the user's message\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  console.log(`Processing request: ${userText}`);\n\n  // Send a \"working\" status update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: \"Thinking about your request...\", type: \"text\" }],\n    },\n  };\n\n  // Simulate some work with delay\n  await new Promise((resolve) =&gt; setTimeout(resolve, 1500));\n\n  // Check for task cancellation\n  if (context.isCancelled()) {\n    console.log(\"Task was cancelled\");\n    yield {\n      state: \"canceled\",\n      message: {\n        role: \"agent\",\n        parts: [{ text: \"Processing has been cancelled.\", type: \"text\" }],\n      },\n    };\n    return;\n  }\n\n  // Create a response\n  const response = `You said: \"${userText}\". This is an echo server example.`;\n\n  // Yield an artifact (optional)\n  yield {\n    name: \"response.txt\",\n    parts: [{ text: response, type: \"text\" }],\n  };\n\n  // Yield a completed status with response message\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: response, type: \"text\" }],\n    },\n  };\n}\n\n// Create a server\nconst server = new A2AServer({\n  // Use in-memory storage (no persistence between restarts)\n  handler: simpleEchoAgent,\n  taskStore: new InMemoryTaskStore(),\n  // Customize the port\n  port: 3000,\n\n  // Base path for the API endpoint\n  basePath: \"/api\",\n\n  // CORS options\n  corsOptions: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"],\n    allowedHeaders: [\"Content-Type\"],\n  },\n\n  // Customize the agent card\n  card: {\n    name: \"Echo Agent\",\n    description: \"A simple echo agent that responds with your message\",\n    version: \"1.0.0\",\n    url: \"http://localhost:3000\",\n    skills: [\n      {\n        id: \"echo\",\n        name: \"echo\",\n        description: \"Echoes back the user's message\",\n      },\n    ],\n    capabilities: {\n      streaming: true,\n      pushNotifications: false,\n      stateTransitionHistory: true,\n    },\n  },\n});\n\n// Start the server\nserver.start();\nconsole.log(\"A2A Server started on port 3000\");\nconsole.log(\"Try connecting with an A2A client:\");\nconsole.log(\"  A2A Endpoint: http://localhost:3000/api\");\nconsole.log(\"  Agent Card: http://localhost:3000/.well-known/agent.json\");\n</code></pre>"},{"location":"sdk/examples/basic-server.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node basic-server.js</code></li> </ol>"},{"location":"sdk/examples/basic-server.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/basic-usage.html","title":"basic-usage","text":"<p>Basic usage example for the Artinet SDK</p> <p>This example demonstrates how to: - Create an A2AClient instance - Get the agent card - Send a simple task - Handle the response</p>"},{"location":"sdk/examples/basic-usage.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Basic usage example for the Artinet SDK\n *\n * This example demonstrates how to:\n * - Create an A2AClient instance\n * - Get the agent card\n * - Send a simple task\n * - Handle the response\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance pointing to our local server\n    const client = new A2AClient(\"http://localhost:3000/api\");\n    console.log(\"Client initialized\");\n\n    // Get the agent card to discover capabilities\n    try {\n      const agentCard = await client.agentCard();\n      console.log(`Connected to agent: ${agentCard.name}`);\n      console.log(`Agent version: ${agentCard.version}`);\n      console.log(\n        `Streaming supported: ${\n          agentCard.capabilities.streaming ? \"Yes\" : \"No\"\n        }`\n      );\n    } catch (error) {\n      console.log(\"Could not retrieve agent card, continuing anyway...\");\n      console.error(error);\n    }\n\n    // Create a message to send\n    const message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Hello! Can you help me with a question about climate change?\",\n        },\n      ],\n    };\n\n    // Generate a unique task ID\n    const taskId = `task-${Date.now()}`;\n\n    // Send a task\n    console.log(`Sending task with ID: ${taskId}...`);\n\n    const task = await client.sendTask({\n      id: taskId,\n      message,\n    });\n\n    if (task) {\n      console.log(`Task status: ${task.status.state}`);\n\n      if (task.status.message) {\n        // Extract the text parts from the response\n        const textParts = task.status.message.parts\n          .filter((part) =&gt; part.type === \"text\")\n          .map((part) =&gt; part.text);\n\n        console.log(\"Agent response:\", textParts.join(\"\\n\"));\n      }\n    } else {\n      console.log(\"No task response received\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/basic-usage.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node basic-usage.js</code></li> </ol>"},{"location":"sdk/examples/basic-usage.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/code-deployment.html","title":"code-deployment","text":"<p>Example demonstrating code-deployment</p>"},{"location":"sdk/examples/code-deployment.html#source-code","title":"Source Code","text":"<pre><code>import { TaskYieldUpdate, TaskContext, Task, TextPart } from \"@artinet/sdk\";\nimport {\n  taskHandlerProxy,\n  fetchResponseProxy,\n} from \"../src/utils/deployment/task-wrapper\";\n\nconsole.log(\"[CoderAgent] Starting\");\nexport async function* coderAgent({\n  task,\n  history,\n}: TaskContext): AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt; {\n  history = [...history, ...(task.status.message ? [task.status.message] : [])];\n  const messages = (history ?? [])\n    .map((m) =&gt; ({\n      role: (m.role === \"agent\" ? \"model\" : \"user\") as \"user\" | \"model\",\n      content: m.parts\n        .filter((p): p is TextPart =&gt; !!(p as TextPart).text)\n        .map((p) =&gt; p.text)\n        .join(\"\\n\"),\n    }))\n    .filter((m) =&gt; m.content.length &gt; 0);\n\n  if (messages.length === 0) {\n    console.warn(`[CoderAgent] No history/messages found for task ${task.id}`);\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"No input message found.\" }],\n      },\n    };\n    return;\n  }\n\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Generating code...\" }],\n    },\n  };\n\n  const response = await fetchResponseProxy(\"Qwen/Qwen2.5-Coder-32B-Instruct\", [\n    {\n      role: \"system\",\n      content:\n        \"You are an expert coding assistant. Provide a high-quality code sample according to the output instructions provided below. You may generate multiple files as needed.\",\n    },\n    ...messages,\n  ]);\n\n  console.log(\"response: \", response);\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [\n        {\n          type: \"text\",\n          text: response,\n        },\n      ],\n    },\n  };\n}\n\nawait taskHandlerProxy(coderAgent);\nconsole.log(\"[CoderAgent] Finished\");\n</code></pre>"},{"location":"sdk/examples/code-deployment.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node code-deployment.ts</code></li> </ol>"},{"location":"sdk/examples/code-deployment.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/file-storage-client-continued.html","title":"file-storage-client-continued","text":"<p>Test client for the file storage server example - part 2 This test demonstrates history retrieval after server restart</p>"},{"location":"sdk/examples/file-storage-client-continued.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Test client for the file storage server example - part 2\n * This test demonstrates history retrieval after server restart\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\n// Use the same task ID as in the previous run\nconst taskId = `conversation-1745596127049`;\n\nasync function main() {\n  try {\n    // Create a new client instance\n    const client = new A2AClient(\"http://localhost:3000\");\n    console.log(\"Client initialized\");\n\n    // Get the agent card to discover capabilities\n    try {\n      const agentCard = await client.agentCard();\n      console.log(`Connected to agent: ${agentCard.name}`);\n    } catch (error) {\n      console.log(\"Could not retrieve agent card, continuing anyway...\");\n    }\n\n    console.log(`\\nSending third message with task ID: ${taskId}`);\n    const message =\n      \"This is my third message. The server was restarted. Do you still remember our conversation?\";\n    console.log(`Message: \"${message}\"`);\n\n    // Send a task\n    const task = await client.sendTask({\n      id: taskId,\n      message: {\n        role: \"user\",\n        parts: [\n          {\n            type: \"text\",\n            text: message,\n          },\n        ],\n      },\n    });\n\n    if (task) {\n      console.log(`Task status: ${task.status.state}`);\n\n      if (task.status.message) {\n        // Extract the text parts from the response\n        const textParts = task.status.message.parts\n          .filter((part) =&gt; part.type === \"text\")\n          .map((part) =&gt; part.text);\n\n        console.log(\"Agent response:\", textParts.join(\"\\n\"));\n      }\n    } else {\n      console.log(\"No task response received\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/file-storage-client-continued.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node file-storage-client-continued.js</code></li> </ol>"},{"location":"sdk/examples/file-storage-client-continued.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/file-storage-client.html","title":"file-storage-client","text":"<p>Test client for the file storage server example</p>"},{"location":"sdk/examples/file-storage-client.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Test client for the file storage server example\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance\n    const client = new A2AClient(\"http://localhost:3000\");\n    console.log(\"Client initialized\");\n\n    // Get the agent card to discover capabilities\n    try {\n      const agentCard = await client.agentCard();\n      console.log(`Connected to agent: ${agentCard.name}`);\n      console.log(`Agent version: ${agentCard.version}`);\n      console.log(\n        `Streaming supported: ${\n          agentCard.capabilities.streaming ? \"Yes\" : \"No\"\n        }`\n      );\n    } catch (error) {\n      console.log(\"Could not retrieve agent card, continuing anyway...\");\n      console.error(error);\n    }\n\n    // Generate a unique task ID - we'll reuse this for the second message\n    const taskId = `conversation-${Date.now()}`;\n\n    // First message\n    await sendMessage(client, taskId, \"Hello! This is my first message!\");\n\n    // Second message to the same conversation\n    await sendMessage(\n      client,\n      taskId,\n      \"This is my second message. Do you remember our conversation?\"\n    );\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\nasync function sendMessage(client, taskId, text) {\n  console.log(`\\nSending message with task ID: ${taskId}`);\n  console.log(`Message: \"${text}\"`);\n\n  const message = {\n    role: \"user\",\n    parts: [\n      {\n        type: \"text\",\n        text: text,\n      },\n    ],\n  };\n\n  // Send a task\n  const task = await client.sendTask({\n    id: taskId,\n    message,\n  });\n\n  if (task) {\n    console.log(`Task status: ${task.status.state}`);\n\n    if (task.status.message) {\n      // Extract the text parts from the response\n      const textParts = task.status.message.parts\n        .filter((part) =&gt; part.type === \"text\")\n        .map((part) =&gt; part.text);\n\n      console.log(\"Agent response:\", textParts.join(\"\\n\"));\n    }\n  } else {\n    console.log(\"No task response received\");\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/file-storage-client.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node file-storage-client.js</code></li> </ol>"},{"location":"sdk/examples/file-storage-client.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/file-storage-server.html","title":"file-storage-server","text":"<p>File Storage A2A Server Example</p> <p>This example demonstrates how to create an A2A server that uses file-based storage for persisting tasks and message history between server restarts.</p>"},{"location":"sdk/examples/file-storage-server.html#source-code","title":"Source Code","text":"<pre><code>/**\n * File Storage A2A Server Example\n *\n * This example demonstrates how to create an A2A server that uses\n * file-based storage for persisting tasks and message history\n * between server restarts.\n */\n\nimport { A2AServer, FileStore, configureLogger } from \"../dist/index.js\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\n\n// Configure logging\nconfigureLogger({ level: \"info\" });\n\n// Ensure storage directory exists\nconst DATA_DIR = path.join(process.cwd(), \"data\");\ntry {\n  await fs.mkdir(DATA_DIR, { recursive: true });\n  console.log(`Storage directory created: ${DATA_DIR}`);\n} catch (error) {\n  console.error(`Failed to create storage directory: ${error}`);\n  process.exit(1);\n}\n\n/**\n * Implement a simple task handler with history awareness\n */\nasync function* historyAwareAgent(context) {\n  // Extract the user's most recent message\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  console.log(`Processing request: ${userText}`);\n\n  // Count user messages in history\n  const userMessageCount = context.history.filter(\n    (msg) =&gt; msg.role === \"user\"\n  ).length;\n\n  // Send a \"working\" status update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: \"Processing your request...\", type: \"text\" }],\n    },\n  };\n\n  // Simulate work\n  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));\n\n  // Check for task cancellation\n  if (context.isCancelled()) {\n    console.log(\"Task was cancelled\");\n    yield {\n      state: \"canceled\",\n      message: {\n        role: \"agent\",\n        parts: [{ text: \"Processing has been cancelled.\", type: \"text\" }],\n      },\n    };\n    return;\n  }\n\n  // Create a history-aware response\n  let response;\n\n  if (userMessageCount === 1) {\n    response = `Hello! This is your first message: \"${userText}\". I'll remember our conversation.`;\n  } else {\n    // Summarize past messages\n    const pastUserMessages = context.history\n      .filter((msg) =&gt; msg.role === \"user\")\n      .slice(0, -1) // Exclude the current message\n      .map((msg) =&gt;\n        msg.parts\n          .filter((part) =&gt; part.type === \"text\")\n          .map((part) =&gt; part.text)\n          .join(\" \")\n      );\n\n    response = `You've sent ${userMessageCount} messages. Your previous messages were: ${JSON.stringify(\n      pastUserMessages\n    )}. Your current message is: \"${userText}\"`;\n  }\n\n  // Yield an artifact with conversation stats\n  yield {\n    name: \"conversation-stats.txt\",\n    parts: [\n      {\n        text: `Conversation statistics:\n- Total messages: ${context.history.length}\n- User messages: ${userMessageCount}\n- Agent messages: ${context.history.length - userMessageCount}\n`,\n        type: \"text\",\n      },\n    ],\n  };\n\n  // Yield a completed status with response message\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: response, type: \"text\" }],\n    },\n  };\n}\n\n// Create a server with file-based storage\nconst server = new A2AServer({\n  // Use file-based storage for persistence between restarts\n  taskStore: new FileStore(DATA_DIR),\n  handler: historyAwareAgent,\n\n  // Customize the port\n  port: 3000,\n\n  // Customize the agent card\n  card: {\n    url: \"http://localhost:3000\",\n    name: \"History-Aware Agent\",\n    description: \"An agent that remembers your conversation history\",\n    version: \"1.0.0\",\n    skills: [\n      {\n        id: \"history-aware\",\n        name: \"history-aware\",\n        description: \"An agent that remembers your conversation history\",\n      },\n    ],\n    capabilities: {\n      streaming: true,\n      stateTransitionHistory: true,\n    },\n  },\n});\n\n// Start the server\nserver.start();\nconsole.log(\"A2A Server started on port 3000 with file-based storage\");\nconsole.log(`Tasks and history will be stored in: ${DATA_DIR}`);\nconsole.log(\"Try connecting with an A2A client, then restart the server\");\nconsole.log(\"and continue the conversation with the same task ID!\");\n</code></pre>"},{"location":"sdk/examples/file-storage-server.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node file-storage-server.js</code></li> </ol>"},{"location":"sdk/examples/file-storage-server.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/streaming-updates.html","title":"streaming-updates","text":"<p>Streaming updates example for the Artinet SDK</p> <p>This example demonstrates how to: - Create an A2AClient instance - Check if streaming is supported - Send a task with streaming updates - Process updates as they arrive</p>"},{"location":"sdk/examples/streaming-updates.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Streaming updates example for the Artinet SDK\n *\n * This example demonstrates how to:\n * - Create an A2AClient instance\n * - Check if streaming is supported\n * - Send a task with streaming updates\n * - Process updates as they arrive\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance pointing to our local server\n    const client = new A2AClient(\"http://localhost:3000/api\");\n    console.log(\"Client initialized\");\n\n    // Check if streaming is supported\n    let streamingSupported = false;\n    try {\n      streamingSupported = await client.supports(\"streaming\");\n      console.log(`Streaming supported: ${streamingSupported ? \"Yes\" : \"No\"}`);\n    } catch (error) {\n      console.log(\n        \"Could not check streaming support, assuming it is supported...\"\n      );\n      streamingSupported = true; // Assume it's supported for this example\n    }\n\n    if (streamingSupported) {\n      // Create a message to send\n      const message = {\n        role: \"user\",\n        parts: [\n          {\n            type: \"text\",\n            text: \"Tell me a story about space exploration. Take your time and give details about different missions.\",\n          },\n        ],\n      };\n\n      // Generate a unique task ID\n      const taskId = `streaming-task-${Date.now()}`;\n      console.log(`Sending streaming task with ID: ${taskId}...`);\n\n      // Send the task and subscribe to updates\n      const stream = client.sendTaskSubscribe({\n        id: taskId,\n        message,\n      });\n\n      console.log(\"Processing streaming updates...\");\n\n      // Process the updates as they arrive\n      let responseText = \"\";\n\n      for await (const update of stream) {\n        // Check the type of update\n        if (\"status\" in update) {\n          console.log(`Task status update: ${update.status.state}`);\n\n          // If there's a message in this status update\n          if (update.status.message) {\n            const textParts = update.status.message.parts\n              .filter((part) =&gt; part.type === \"text\")\n              .map((part) =&gt; part.text);\n\n            const newText = textParts.join(\"\\n\");\n\n            // Check if this is new text or a replacement\n            if (\n              update.status.message.parts.some((part) =&gt; part.metadata?.append)\n            ) {\n              responseText += newText;\n            } else {\n              responseText = newText;\n            }\n\n            // Print the text received so far\n            console.log(`\\nResponse so far (${responseText.length} chars):`);\n            console.log(\"-------------------\");\n            console.log(responseText);\n            console.log(\"-------------------\\n\");\n          }\n\n          // If this is the final update, we're done\n          if (update.final) {\n            console.log(\"Final update received\");\n          }\n        } else if (\"artifact\" in update) {\n          // Handle artifact updates\n          console.log(\n            `Received artifact: ${update.artifact.name || \"unnamed\"}`\n          );\n\n          // Process artifact parts\n          for (const part of update.artifact.parts) {\n            if (part.type === \"text\") {\n              console.log(`Artifact text: ${part.text.substring(0, 100)}...`);\n            } else if (part.type === \"file\") {\n              console.log(`Artifact file: ${part.file.name || \"unnamed\"}`);\n              // In a real app, you might download the file from part.file.uri\n            }\n          }\n\n          // If this is the final artifact, note it\n          if (update.final) {\n            console.log(\"Final artifact received\");\n          }\n        }\n      }\n\n      console.log(\"Stream completed\");\n    } else {\n      console.log(\"Streaming is not supported by this agent\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/streaming-updates.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node streaming-updates.js</code></li> </ol>"},{"location":"sdk/examples/streaming-updates.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/task-resubscribe.html","title":"task-resubscribe","text":"<p>Task resubscription example for the Artinet SDK</p> <p>This example demonstrates how to: - Create an A2AClient instance - Send a task without subscribing initially - Resubscribe to an existing task to get updates</p>"},{"location":"sdk/examples/task-resubscribe.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Task resubscription example for the Artinet SDK\n *\n * This example demonstrates how to:\n * - Create an A2AClient instance\n * - Send a task without subscribing initially\n * - Resubscribe to an existing task to get updates\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance pointing to our local server\n    const client = new A2AClient(\"http://localhost:3000/api\");\n    console.log(\"Client initialized\");\n\n    // Create a message to send\n    const message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Generate a detailed analysis of climate change impacts over the next 50 years. This should take some time.\",\n        },\n      ],\n    };\n\n    // Generate a unique task ID\n    const taskId = `long-running-task-${Date.now()}`;\n    console.log(`Sending task with ID: ${taskId}...`);\n\n    // First, send the task without subscribing\n    await client.sendTask({\n      id: taskId,\n      message,\n    });\n    console.log(\"Task sent successfully\");\n\n    console.log(\"Simulating a client disconnect...\");\n    // In a real application, this might be triggered by a client reconnection\n    // after a network interruption or browser refresh\n\n    // Wait for 2 seconds to simulate time passing\n    await new Promise((resolve) =&gt; setTimeout(resolve, 2000));\n\n    console.log(\"Client reconnected, resubscribing to task...\");\n\n    // Now resubscribe to the task to get updates\n    const stream = client.resubscribeTask({ id: taskId });\n    console.log(\"Resubscribed to task\");\n\n    // Process the updates as they arrive\n    console.log(\"Processing task updates after resubscription:\");\n    let responseText = \"\";\n\n    for await (const update of stream) {\n      // Check the type of update\n      if (\"status\" in update) {\n        console.log(`Task status update: ${update.status.state}`);\n\n        // Process message if present\n        if (update.status.message) {\n          const textParts = update.status.message.parts\n            .filter((part) =&gt; part.type === \"text\")\n            .map((part) =&gt; part.text);\n\n          responseText = textParts.join(\"\\n\");\n          console.log(`\\nResponse text (${responseText.length} chars):`);\n          console.log(\"-------------------\");\n          console.log(\n            responseText.substring(0, 200) +\n              (responseText.length &gt; 200 ? \"...\" : \"\")\n          );\n          console.log(\"-------------------\\n\");\n        }\n\n        // Check if this is the final update\n        if (update.final) {\n          console.log(\"Final update received, task is complete\");\n        }\n      } else if (\"artifact\" in update) {\n        // Handle artifact updates\n        console.log(`Received artifact: ${update.artifact.name || \"unnamed\"}`);\n\n        // Process artifact parts\n        for (const part of update.artifact.parts) {\n          if (part.type === \"text\") {\n            console.log(`Artifact text: ${part.text.substring(0, 100)}...`);\n          } else if (part.type === \"file\") {\n            console.log(`Artifact file: ${part.file.name || \"unnamed\"}`);\n            // In a real app, you might download the file from part.file.uri\n          }\n        }\n      }\n    }\n\n    console.log(\"Task stream completed\");\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n\n    // If there's an error, try to get the current status of the task\n    if (error.message.includes(\"connection\") &amp;&amp; client) {\n      console.log(\"Attempting to check task status...\");\n      try {\n        const taskId = error.taskId || `long-running-task-${Date.now() - 2000}`;\n        const taskStatus = await client.getTask(taskId);\n        console.log(\"Current task status:\", taskStatus);\n      } catch (statusError) {\n        console.error(\"Could not retrieve task status:\", statusError.message);\n      }\n    }\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/task-resubscribe.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node task-resubscribe.js</code></li> </ol>"},{"location":"sdk/examples/task-resubscribe.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/task-wrapper.html","title":"task-wrapper","text":"<p>Example demonstrating task-wrapper</p>"},{"location":"sdk/examples/task-wrapper.html#source-code","title":"Source Code","text":"<pre><code>export const taskHandlerProxy = async (taskHandler) =&gt; {\n  if (!env.hostOnYield &amp;&amp; !env.Context) {\n    const err = new Error(\"invalid runtime environment\");\n    throw err;\n  }\n  const context = env.Context;\n  const onYieldProxy = env.hostOnYield;\n\n  if (!onYieldProxy || !context) {\n    const err = new Error(\"invalid runtime environment\");\n    throw err;\n  }\n  const generator = taskHandler(context);\n  for await (const yieldValue of generator) {\n    onYieldProxy(yieldValue);\n  }\n};\n\nexport const fetchResponseProxy = async (agentID, messages) =&gt; {\n  if (!env.hostFetchResponse) {\n    const err = new Error(\"invalid runtime environment\");\n    throw err;\n  }\n  const fetchResponseImpl = env.hostFetchResponse;\n  return fetchResponseImpl(agentID, messages);\n};\n</code></pre>"},{"location":"sdk/examples/task-wrapper.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node task-wrapper.js</code></li> </ol>"},{"location":"sdk/examples/task-wrapper.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/tests/index.html","title":"Artinet SDK Tests","text":"<p>This section contains documentation for the test suite of the Artinet SDK.</p>"},{"location":"sdk/tests/index.html#available-tests","title":"Available Tests","text":"<ul> <li>a2a-protocol.test - Tests for a2a protocol.test</li> <li>bundler.test - Tests for bundler.test</li> <li>client.test - Tests for client.test</li> <li>common-errors.test - Tests for common errors.test</li> <li>file-storage.test - Tests for file storage.test</li> <li>http-utils.test - Tests for http utils.test</li> <li>integration.test - Tests for integration.test</li> <li>register.test - Tests for register.test</li> <li>rpc-client.test - Tests for rpc client.test</li> <li>server-error-handling.test - Tests for server error handling.test</li> <li>server-impl.test - Tests for server impl.test</li> <li>server.test - Tests for server.test</li> <li>streaming.test - Tests for streaming.test</li> </ul>"},{"location":"sdk/tests/index.html#running-all-tests","title":"Running All Tests","text":"<p>To run the full test suite:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run all tests with <code>npm test</code></li> </ol>"},{"location":"sdk/tests/index.html#test-coverage","title":"Test Coverage","text":"<p>To generate a test coverage report:</p> <pre><code>npm test -- --coverage\n</code></pre> <p>This will create a coverage report that can be viewed in the browser.</p>"},{"location":"sdk/tests/a2a-protocol.test.html","title":"a2a-protocol.test","text":"<p>Tests for a2a protocol.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/a2a-protocol.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2A Protocol Specification Tests</li> <li>Agent Card</li> <li>Task States</li> <li>Message and Artifact Types</li> <li>Task Management</li> <li>Push Notification API</li> <li>Invalid Method Handling</li> </ul>"},{"location":"sdk/tests/a2a-protocol.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  TaskContext,\n  TaskYieldUpdate,\n  configureLogger,\n} from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\n\n// Define a comprehensive task handler for A2A protocol testing\nasync function* a2aProtocolTestHandler(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, void, unknown&gt; {\n  const text = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Test for all possible states in A2A protocol\n  if (text.includes(\"throw\")) {\n    throw new Error(\"Simulated task error\");\n  }\n\n  if (text.includes(\"fail\")) {\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task failed intentionally.\" }],\n      },\n    };\n    return;\n  }\n\n  if (text.includes(\"input-required\")) {\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Processing request...\" }],\n      },\n    };\n\n    yield {\n      state: \"input-required\",\n      message: {\n        role: \"agent\",\n        parts: [\n          {\n            type: \"text\",\n            text: \"I need more information. Please provide details.\",\n          },\n        ],\n      },\n    };\n    return;\n  }\n\n  if (text.includes(\"working-only\")) {\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Still working...\" }],\n      },\n    };\n    return;\n  }\n\n  if (text.includes(\"multi-part\")) {\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [\n          { type: \"text\", text: \"First part\" },\n          { type: \"data\", data: { key: \"value\" } },\n        ],\n      },\n    };\n\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [\n          { type: \"text\", text: \"Task completed with multiple part types.\" },\n          {\n            type: \"file\",\n            file: {\n              name: \"test.txt\",\n              mimeType: \"text/plain\",\n              bytes: Buffer.from(\"test content\").toString(\"base64\"),\n            },\n          },\n        ],\n      },\n      // Using 'as any' to bypass the type checking for testing purposes\n      artifacts: [\n        {\n          name: \"test-artifact\",\n          description: \"Test artifact description\",\n          parts: [{ type: \"text\", text: \"Artifact content\" }],\n          index: 0,\n          metadata: {\n            testKey: \"testValue\",\n          },\n        },\n      ] as any,\n    };\n    return;\n  }\n\n  if (text.includes(\"streaming\")) {\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Working...\" }],\n      },\n    };\n\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Still working...\" }],\n      },\n      // Using 'as any' to bypass the type checking for testing purposes\n      artifacts: [\n        {\n          name: \"partial-artifact\",\n          parts: [{ type: \"text\", text: \"Partial \" }],\n          index: 0,\n          append: false,\n          lastChunk: false,\n        },\n      ] as any,\n    };\n\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Almost done...\" }],\n      },\n      // Using 'as any' to bypass the type checking for testing purposes\n      artifacts: [\n        {\n          name: \"partial-artifact\",\n          parts: [{ type: \"text\", text: \"artifact content\" }],\n          index: 0,\n          append: true,\n          lastChunk: true,\n        },\n      ] as any,\n    };\n\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Streaming completed!\" }],\n      },\n    };\n    return;\n  }\n\n  // Default case - normal processing\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Working...\" }],\n    },\n  };\n\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Task completed successfully.\" }],\n    },\n  };\n}\n\ndescribe(\"A2A Protocol Specification Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    server = new A2AServer({\n      handler: a2aProtocolTestHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n      card: {\n        name: \"A2A Protocol Test Agent\",\n        url: \"http://localhost:41241\",\n        version: \"1.0.0\",\n        capabilities: {\n          streaming: true,\n          pushNotifications: true,\n          stateTransitionHistory: true,\n        },\n        skills: [\n          {\n            id: \"test\",\n            name: \"Test Skill\",\n          },\n        ],\n      },\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Agent Card\", () =&gt; {\n    it(\"returns agent card at /.well-known/agent.json\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).get(\"/.well-known/agent.json\")\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.name).toBe(\"A2A Protocol Test Agent\");\n      expect(response.body.capabilities.streaming).toBe(true);\n      expect(response.body.capabilities.pushNotifications).toBe(true);\n      expect(response.body.skills).toHaveLength(1);\n      expect(response.body.skills[0].id).toBe(\"test\");\n    });\n\n    it(\"returns agent card at /agent-card\", async () =&gt; {\n      const response = await trackRequest(request(app).get(\"/agent-card\"));\n\n      expect(response.status).toBe(200);\n      expect(response.body.name).toBe(\"A2A Protocol Test Agent\");\n    });\n  });\n\n  describe(\"Task States\", () =&gt; {\n    it(\"handles task/send with task/completed state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"test-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"test-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Basic test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"test-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n      expect(response.body.result.status.message.parts[0].text).toBe(\n        \"Task completed successfully.\"\n      );\n    });\n\n    it(\"handles task/send with task/failed state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"fail-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"fail-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This will fail\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"fail-task-1\");\n      expect(response.body.result.status.state).toBe(\"failed\");\n      expect(response.body.result.status.message.parts[0].text).toBe(\n        \"Task failed intentionally.\"\n      );\n    });\n\n    it(\"handles task/send with input-required state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"input-required-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"input-required-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This needs input-required\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"input-required-task-1\");\n      expect(response.body.result.status.state).toBe(\"input-required\");\n      expect(response.body.result.status.message.parts[0].text).toContain(\n        \"need more information\"\n      );\n    });\n\n    it(\"handles task/send with working state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"working-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"working-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This is working-only\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"working-task-1\");\n      expect(response.body.result.status.state).toBe(\"working\");\n      expect(response.body.result.status.message.parts[0].text).toContain(\n        \"Still working...\"\n      );\n    });\n  });\n\n  describe(\"Message and Artifact Types\", () =&gt; {\n    it(\"handles multiple part types and artifacts\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"multi-part-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"multi-part-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This is multi-part\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"multi-part-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n\n      // Check multiple parts in message\n      expect(response.body.result.status.message.parts).toHaveLength(2);\n      expect(response.body.result.status.message.parts[0].type).toBe(\"text\");\n      expect(response.body.result.status.message.parts[1].type).toBe(\"file\");\n      expect(response.body.result.status.message.parts[1].file.name).toBe(\n        \"test.txt\"\n      );\n\n      // Check artifacts only if present (implementation may vary)\n      if (response.body.result.artifacts) {\n        expect(response.body.result.artifacts).toHaveLength(1);\n        expect(response.body.result.artifacts[0].name).toBe(\"test-artifact\");\n        expect(response.body.result.artifacts[0].description).toBe(\n          \"Test artifact description\"\n        );\n        expect(response.body.result.artifacts[0].parts[0].text).toBe(\n          \"Artifact content\"\n        );\n        expect(response.body.result.artifacts[0].metadata.testKey).toBe(\n          \"testValue\"\n        );\n      }\n    });\n  });\n\n  describe(\"Task Management\", () =&gt; {\n    it(\"retrieves task with tasks/get\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"create-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"retrieve-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task to be retrieved\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now retrieve it\n      const retrieveBody = {\n        jsonrpc: \"2.0\",\n        id: \"retrieve-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"retrieve-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(retrieveBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"retrieve-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n    });\n\n    it(\"returns error for non-existent task\", async () =&gt; {\n      const retrieveBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(retrieveBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001); // Task not found error\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n\n    it(\"cancels a task with tasks/cancel\", async () =&gt; {\n      // First create a task that will stay in working state\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"cancel-create-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"cancel-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This is working-only\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now cancel it\n      const cancelBody = {\n        jsonrpc: \"2.0\",\n        id: \"cancel-request-1\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"cancel-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"cancel-task-1\");\n      expect(response.body.result.status.state).toBe(\"canceled\");\n    });\n\n    it(\"returns error when canceling non-existent task\", async () =&gt; {\n      const cancelBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-cancel-request-1\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001); // Task not found error\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n\n    it(\"returns error when canceling completed task\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"completed-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"completed-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task to be completed\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now try to cancel it\n      const cancelBody = {\n        jsonrpc: \"2.0\",\n        id: \"completed-cancel-request-1\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"completed-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32002);\n      expect(response.body.error.message).toBe(\"Task cannot be canceled\");\n    });\n  });\n\n  describe(\"Push Notification API\", () =&gt; {\n    it(\"sets push notification configuration\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-create-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"push-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task for push notifications\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now set push notification config\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-request-1\",\n        method: \"tasks/pushNotification/set\",\n        params: {\n          id: \"push-task-1\",\n          pushNotificationConfig: {\n            url: \"https://example.com/webhook\",\n            token: \"test-token\",\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n\n      // The implementation might return either a result with the config or a method not found error\n      if (response.body.result) {\n        expect(response.body.result.id).toBe(\"push-task-1\");\n        if (response.body.result.pushNotificationConfig) {\n          expect(response.body.result.pushNotificationConfig.url).toBe(\n            \"https://example.com/webhook\"\n          );\n          expect(response.body.result.pushNotificationConfig.token).toBe(\n            \"test-token\"\n          );\n        }\n      } else if (response.body.error) {\n        // The server might return method not found error if push notifications aren't implemented\n        expect([-32601, -32003]).toContain(response.body.error.code);\n      }\n    });\n\n    it(\"gets push notification configuration\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-create-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"push-get-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task for push notifications\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now try to get push notification config\n      const getBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-get-request-1\",\n        method: \"tasks/pushNotification/get\",\n        params: {\n          id: \"push-get-task-1\",\n        },\n      };\n\n      const response = await trackRequest(request(app).post(\"/\").send(getBody));\n\n      expect(response.status).toBe(200);\n\n      // Since we didn't set a push notification, we might get null result\n      // or a method not found error if not implemented\n      if (response.body.result !== undefined) {\n        // Result might be null or an actual config object\n        // Test passes in either case since we're just checking the response structure\n      } else if (response.body.error) {\n        // The server might return method not found error if push notifications aren't implemented\n        expect([-32601, -32003]).toContain(response.body.error.code);\n      }\n    });\n\n    it(\"returns error when setting push notification for non-existent task\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-push-request-1\",\n        method: \"tasks/pushNotification/set\",\n        params: {\n          id: \"nonexistent-task-1\",\n          pushNotificationConfig: {\n            url: \"https://example.com/webhook\",\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n\n      // The implementation might return either a task not found error\n      // or a method not found error if push notifications aren't implemented\n      expect(response.body.error).toBeDefined();\n      expect([-32001, -32601, -32003]).toContain(response.body.error.code);\n    });\n  });\n\n  describe(\"Invalid Method Handling\", () =&gt; {\n    it(\"handles non-existent method\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-method-request-1\",\n        method: \"invalid/method\",\n        params: {\n          id: \"invalid-method-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32601); // Method not found error\n      expect(response.body.error.message).toBe(\"Method not found\");\n    });\n\n    it(\"handles invalid params\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-params-request-1\",\n        method: \"tasks/send\",\n        params: {\n          // Missing required id field\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Invalid params\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602); // Invalid params error\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/a2a-protocol.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest a2a-protocol.test.ts</code></li> </ol>"},{"location":"sdk/tests/a2a-protocol.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/bundler.test.html","title":"bundler.test","text":"<p>Tests for bundler.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/bundler.test.html#test-suites","title":"Test Suites","text":"<ul> <li>bundle</li> </ul>"},{"location":"sdk/tests/bundler.test.html#source-code","title":"Source Code","text":"<pre><code>import { bundle } from \"../src/index.js\";\nimport { configureLogger } from \"../src/index.js\";\n\nconfigureLogger({ level: \"debug\" });\n\ndescribe(\"bundle\", () =&gt; {\n  it(\"should be defined\", () =&gt; {\n    expect(bundle).toBeDefined();\n  });\n\n  it(\"should bundle a file\", async () =&gt; {\n    const filePath = new URL(\"../examples/code-deployment.js\", import.meta.url);\n    const result = await bundle(filePath);\n    expect(result).toBeDefined();\n\n    console.log(\"result: \", result);\n  });\n});\n</code></pre>"},{"location":"sdk/tests/bundler.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest bundler.test.ts</code></li> </ol>"},{"location":"sdk/tests/bundler.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/client.test.html","title":"client.test","text":"<p>Tests for client.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/client.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2AClient</li> </ul>"},{"location":"sdk/tests/client.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  A2AClient,\n  SystemError,\n  AgentCard,\n  Message,\n  Task,\n  TaskState,\n  TaskSendParams,\n  TaskStatusUpdateEvent,\n  TaskArtifactUpdateEvent,\n  TaskPushNotificationConfig,\n  TaskIdParams,\n  TaskQueryParams,\n  PushNotificationConfig,\n  configureLogger,\n} from \"../src/index.js\";\nimport { http, HttpResponse } from \"msw\";\nimport { setupServer } from \"msw/node\";\n\nconfigureLogger({ level: \"silent\" });\n\nconst MOCK_AGENT_CARD: AgentCard = {\n  name: \"Test Agent\",\n  description: \"A test agent for unit tests\",\n  url: \"https://test-agent.example.com/api\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,\n    pushNotifications: true,\n    stateTransitionHistory: false,\n  },\n  skills: [\n    {\n      id: \"test-skill\",\n      name: \"Test Skill\",\n      description: \"A test skill for unit tests\",\n    },\n  ],\n};\n\nconst MOCK_TASK: Task = {\n  id: \"test-task-123\",\n  status: {\n    state: \"completed\" as TaskState,\n    message: {\n      role: \"agent\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"This is a test response\",\n        },\n      ],\n    },\n    timestamp: new Date().toISOString(),\n  },\n  artifacts: [\n    {\n      name: \"test-artifact\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Artifact content\",\n        },\n      ],\n    },\n  ],\n};\n\n// Task update events for streaming\nconst STATUS_UPDATE_EVENT: TaskStatusUpdateEvent = {\n  id: \"test-task-123\",\n  status: {\n    state: \"in_progress\" as TaskState,\n    timestamp: new Date().toISOString(),\n  },\n};\n\nconst ARTIFACT_UPDATE_EVENT: TaskArtifactUpdateEvent = {\n  id: \"test-task-123\",\n  artifact: {\n    name: \"new-artifact\",\n    parts: [\n      {\n        type: \"text\",\n        text: \"New artifact content\",\n      },\n    ],\n  },\n};\n\nconst MOCK_NOTIFICATION_CONFIG: PushNotificationConfig = {\n  url: \"https://notification-endpoint.example.com\",\n  token: \"test-notification-token\",\n};\n\nconst MOCK_PUSH_NOTIFICATION_CONFIG: TaskPushNotificationConfig = {\n  id: \"test-task-123\",\n  pushNotificationConfig: MOCK_NOTIFICATION_CONFIG,\n};\n\n// Setup MSW server for mocking HTTP requests\nconst server = setupServer(\n  // Mock agent card endpoint\n  http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n    return HttpResponse.json(MOCK_AGENT_CARD);\n  }),\n\n  // Mock fallback agent card endpoint\n  http.get(\"https://test-agent.example.com/agent-card\", () =&gt; {\n    return HttpResponse.json(MOCK_AGENT_CARD);\n  }),\n\n  // Mock tasks/send endpoint\n  http.post(\"https://test-agent.example.com\", async ({ request }) =&gt; {\n    const body = (await request.json()) as {\n      method: string;\n      id: string | number;\n      params?: Record&lt;string, any&gt;;\n    };\n\n    if (body.method === \"tasks/send\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: MOCK_TASK,\n      });\n    }\n\n    if (body.method === \"tasks/get\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: MOCK_TASK,\n      });\n    }\n\n    if (body.method === \"tasks/cancel\") {\n      const canceledTask = {\n        ...MOCK_TASK,\n        status: {\n          ...MOCK_TASK.status,\n          state: \"canceled\",\n        },\n      };\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: canceledTask,\n      });\n    }\n\n    if (body.method === \"tasks/pushNotification/set\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: body.params,\n      });\n    }\n\n    if (body.method === \"tasks/pushNotification/get\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: MOCK_PUSH_NOTIFICATION_CONFIG,\n      });\n    }\n\n    if (\n      body.method === \"tasks/sendSubscribe\" ||\n      body.method === \"tasks/resubscribe\"\n    ) {\n      // For streaming endpoints, create a mock SSE response\n      // This is a simplified implementation since MSW doesn't handle SSE natively\n      // We'll create a text response with the correct format\n      const eventData1 = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: STATUS_UPDATE_EVENT,\n      });\n\n      const eventData2 = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: ARTIFACT_UPDATE_EVENT,\n      });\n\n      // Create a text response that mimics SSE format\n      const responseText =\n        `event: event\\ndata: ${eventData1}\\n\\n` +\n        `event: event\\ndata: ${eventData2}\\n\\n`;\n      return new HttpResponse(responseText, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n    }\n\n    // Default case for unhandled methods\n    return HttpResponse.json(\n      {\n        jsonrpc: \"2.0\",\n        id: body.id,\n        error: {\n          code: -32601,\n          message: \"Method not found\",\n        },\n      },\n      { status: 400 }\n    );\n  })\n);\n\ndescribe(\"A2AClient\", () =&gt; {\n  let client: A2AClient;\n\n  beforeAll(() =&gt; {\n    server.listen();\n  });\n\n  afterAll(() =&gt; {\n    server.close();\n  });\n\n  beforeEach(() =&gt; {\n    client = new A2AClient(\"https://test-agent.example.com\");\n    server.resetHandlers();\n  });\n\n  // Test agent card retrieval\n  test(\"should fetch an agent card\", async () =&gt; {\n    const card = await client.agentCard();\n    expect(card).toEqual(MOCK_AGENT_CARD);\n\n    // Test the cached card path (line 51 in client.ts)\n    // This second call should use the cached card without making a network request\n\n    // Override the server to return a different card,\n    // if the cache is used, we'll still get the original\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return HttpResponse.json({\n          ...MOCK_AGENT_CARD,\n          version: \"2.0.0\", // Changed version\n        });\n      })\n    );\n\n    const cachedCard = await client.agentCard();\n    // Verify we got the original card (from cache) not the new one\n    expect(cachedCard).toEqual(MOCK_AGENT_CARD);\n    expect(cachedCard.version).toBe(\"1.0.0\"); // Original version, not 2.0.0\n  });\n\n  // Test agent card refreshing\n  test(\"should refresh an agent card\", async () =&gt; {\n    // First get the card to cache it\n    await client.agentCard();\n\n    // Mock a change to the agent card on the server\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return HttpResponse.json({\n          ...MOCK_AGENT_CARD,\n          version: \"1.1.0\",\n        });\n      })\n    );\n\n    // Refresh the card\n    const updatedCard = await client.refreshAgentCard();\n    expect(updatedCard.version).toBe(\"1.1.0\");\n  });\n\n  // Test fallback to secondary card URL\n  test(\"should fetch agent card from fallback URL when primary fails\", async () =&gt; {\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return new HttpResponse(null, { status: 404 });\n      })\n    );\n\n    const card = await client.agentCard();\n    expect(card).toEqual(MOCK_AGENT_CARD);\n  });\n\n  // Test agent card fetching error\n  test(\"should throw when both agent card endpoints fail\", async () =&gt; {\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return new HttpResponse(\"Not found\", {\n          status: 404,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }),\n      http.get(\"https://test-agent.example.com/agent-card\", () =&gt; {\n        return new HttpResponse(\"Server error\", {\n          status: 500,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    await expect(client.agentCard()).rejects.toThrow();\n  });\n\n  // Test constructor with string URL and headers\n  test(\"should construct client with string URL and headers\", () =&gt; {\n    const testClient = new A2AClient(\"https://example.com\", {\n      Authorization: \"Bearer test-token\",\n    });\n\n    // Check internal state\n    expect((testClient as any).baseUrl.href).toBe(\"https://example.com/\");\n    expect((testClient as any).customHeaders[\"Authorization\"]).toBe(\n      \"Bearer test-token\"\n    );\n  });\n\n  // Test sending a task\n  test(\"should send a task and receive a response\", async () =&gt; {\n    const message: Message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Hello, this is a test message\",\n        },\n      ],\n    };\n\n    const params: TaskSendParams = {\n      id: \"test-task-123\",\n      message,\n    };\n\n    const task = await client.sendTask(params);\n    expect(task).toEqual(MOCK_TASK);\n  });\n\n  // Test getting a task\n  test(\"should get a task by ID\", async () =&gt; {\n    const task = await client.getTask({ id: \"test-task-123\" });\n    expect(task).toEqual(MOCK_TASK);\n  });\n\n  // Test canceling a task\n  test(\"should cancel a task\", async () =&gt; {\n    const task = await client.cancelTask({ id: \"test-task-123\" });\n    expect(task).toMatchObject({\n      id: \"test-task-123\",\n      status: {\n        state: \"canceled\",\n      },\n    });\n  });\n\n  // Test push notification config setting\n  test(\"should set task push notification config\", async () =&gt; {\n    const config: TaskPushNotificationConfig = {\n      id: \"test-task-123\",\n      pushNotificationConfig: {\n        url: \"https://notification-endpoint.example.com\",\n        token: \"test-notification-token\",\n      },\n    };\n\n    const result = await client.setTaskPushNotification(config);\n    expect(result).toEqual(config);\n  });\n\n  // Test push notification config getting\n  test(\"should get task push notification config\", async () =&gt; {\n    const params: TaskIdParams = {\n      id: \"test-task-123\",\n    };\n\n    const config = await client.getTaskPushNotification(params);\n    expect(config).toEqual(MOCK_PUSH_NOTIFICATION_CONFIG);\n  });\n\n  // Test streaming task updates\n  test(\"should stream task updates\", async () =&gt; {\n    const message: Message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Hello, this is a test message\",\n        },\n      ],\n    };\n\n    const params: TaskSendParams = {\n      id: \"test-task-123\",\n      message,\n    };\n\n    const events: (TaskStatusUpdateEvent | TaskArtifactUpdateEvent)[] = [];\n    const stream = client.sendTaskSubscribe(params);\n    for await (const event of stream) {\n      events.push(event);\n    }\n\n    expect(events.length).toBe(2);\n    // Check event types without explicit type property references\n    expect(events[0]).toHaveProperty(\"status\"); // It's a status update\n    expect(events[1]).toHaveProperty(\"artifact\"); // It's an artifact update\n  });\n\n  // Test resubscribe task updates\n  test(\"should resubscribe to task updates\", async () =&gt; {\n    const params: TaskQueryParams = {\n      id: \"test-task-123\",\n    };\n\n    const events: (TaskStatusUpdateEvent | TaskArtifactUpdateEvent)[] = [];\n\n    for await (const event of client.resubscribeTask(params)) {\n      events.push(event);\n    }\n\n    expect(events.length).toBe(2);\n    // Check event types without explicit type property references\n    expect(events[0]).toHaveProperty(\"status\"); // It's a status update\n    expect(events[1]).toHaveProperty(\"artifact\"); // It's an artifact update\n  });\n\n  // Test error handling - network errors\n  test(\"should handle network errors during HTTP request\", async () =&gt; {\n    // Mock a network error by using a response that forces a fetch error\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(null, { status: 500 });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - invalid JSON response\n  test(\"should handle invalid JSON response\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(\"This is not JSON\", {\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - invalid JSON-RPC structure\n  test(\"should handle invalid JSON-RPC structure\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return HttpResponse.json({ not: \"valid-jsonrpc\" });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - HTTP error with JSON-RPC error\n  test(\"should handle HTTP error with JSON-RPC error\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return HttpResponse.json(\n          {\n            jsonrpc: \"2.0\",\n            id: \"123\",\n            error: {\n              code: -32000,\n              message: \"Task not found\",\n            },\n          },\n          { status: 400 }\n        );\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - HTTP error with non-JSON response\n  test(\"should handle HTTP error with non-JSON response\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(\"Internal Server Error\", {\n          status: 500,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling for streaming - response not OK\n  test(\"should handle streaming error when response is not OK\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(\"Bad Request\", {\n          status: 400,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    const stream = client.sendTaskSubscribe({\n      id: \"test-task-123\",\n      message: { role: \"user\", parts: [{ type: \"text\", text: \"Test\" }] },\n    });\n\n    await expect(async () =&gt; {\n      for await (const event of stream) {\n        // This should not execute\n      }\n    }).rejects.toThrow();\n  });\n\n  // Test capability check - edge case with no capabilities\n  test(\"should handle agent card with no capabilities\", async () =&gt; {\n    // First ensure the agent card is cached with valid data\n    await client.agentCard();\n\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return HttpResponse.json({\n          ...MOCK_AGENT_CARD,\n          capabilities: undefined,\n        });\n      })\n    );\n\n    // Force refresh to clear the cache\n    await client.refreshAgentCard();\n\n    const hasStreaming = await client.supports(\"streaming\");\n    expect(hasStreaming).toBe(false);\n  });\n\n  // Test capability check error handling\n  test(\"should handle error during capability check\", async () =&gt; {\n    // Re-use the server default handlers which have valid responses\n    // This ensures the test doesn't fail when trying to fetch the agent card\n\n    // Create a client with a known invalid URL to simulate error\n    const badClient = new A2AClient(\"https://invalid-url.example.com\");\n\n    // Mock a failed request for the invalid URL\n    server.use(\n      http.get(\"https://invalid-url.example.com/.well-known/agent.json\", () =&gt; {\n        return new HttpResponse(null, { status: 404 });\n      }),\n      http.get(\"https://invalid-url.example.com/agent-card\", () =&gt; {\n        return new HttpResponse(null, { status: 404 });\n      })\n    );\n\n    const hasStreaming = await badClient.supports(\"streaming\");\n    expect(hasStreaming).toBe(false);\n  });\n\n  // Test error handling\n  test(\"should handle JSON-RPC errors\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: \"123\",\n          error: {\n            code: -32000,\n            message: \"Task not found\",\n          },\n        });\n      })\n    );\n\n    await expect(client.getTask({ id: \"nonexistent-task\" })).rejects.toThrow(\n      SystemError\n    );\n  });\n\n  // Test capability check\n  test(\"should check if a capability is supported\", async () =&gt; {\n    // First, ensure the agent card is cached\n    await client.agentCard();\n\n    const hasStreaming = await client.supports(\"streaming\");\n    expect(hasStreaming).toBe(true);\n\n    const hasPushNotifications = await client.supports(\"pushNotifications\");\n    expect(hasPushNotifications).toBe(true);\n\n    const hasStateTransitionHistory = await client.supports(\n      \"stateTransitionHistory\"\n    );\n    expect(hasStateTransitionHistory).toBe(false);\n\n    // Test the default case in the switch statement for uncovered branch\n    const hasUnsupportedCapability = await client.supports(\n      \"unknownCapability\" as any\n    );\n    expect(hasUnsupportedCapability).toBe(false);\n  });\n\n  // Test header management\n  test(\"should manage custom headers\", () =&gt; {\n    // Add a header\n    client.addHeader(\"Authorization\", \"Bearer test-token\");\n\n    // Check internal state (this is a private test hack, normally wouldn't test private members)\n    const headers = (client as any).customHeaders;\n    expect(headers[\"Authorization\"]).toBe(\"Bearer test-token\");\n\n    // Add another header\n    client.addHeader(\"X-Custom-Header\", \"test-value\");\n    expect((client as any).customHeaders[\"X-Custom-Header\"]).toBe(\"test-value\");\n\n    // Replace all headers\n    client.setHeaders({\n      \"Content-Type\": \"application/json\",\n      \"Accept-Language\": \"en-US\",\n    });\n\n    const newHeaders = (client as any).customHeaders;\n    expect(newHeaders[\"Authorization\"]).toBeUndefined();\n    expect(newHeaders[\"Content-Type\"]).toBe(\"application/json\");\n    expect(newHeaders[\"Accept-Language\"]).toBe(\"en-US\");\n\n    // Remove a header\n    client.removeHeader(\"Content-Type\");\n    expect((client as any).customHeaders[\"Content-Type\"]).toBeUndefined();\n\n    // Clear all headers\n    client.clearHeaders();\n    expect(Object.keys((client as any).customHeaders).length).toBe(0);\n  });\n});\n</code></pre>"},{"location":"sdk/tests/client.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest client.test.ts</code></li> </ol>"},{"location":"sdk/tests/client.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/common-errors.test.html","title":"common-errors.test","text":"<p>Tests for common errors.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/common-errors.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Error Handling Utilities</li> <li>SystemError</li> <li>Error Factories</li> <li>FAILED_UPDATE</li> <li>Error Constants</li> </ul>"},{"location":"sdk/tests/common-errors.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  SystemError,\n  PARSE_ERROR,\n  METHOD_NOT_FOUND,\n  INVALID_REQUEST,\n  INVALID_PARAMS,\n  INTERNAL_ERROR,\n  TASK_NOT_FOUND,\n  TASK_NOT_CANCELABLE,\n  UNSUPPORTED_OPERATION,\n  PUSH_NOTIFICATION_NOT_SUPPORTED,\n  FAILED_UPDATE,\n  ErrorCodeParseError,\n  ErrorCodeInvalidParams,\n  ErrorCodeInternalError,\n  ErrorCodeInvalidRequest,\n  ErrorCodeMethodNotFound,\n  ErrorCodeTaskNotFound,\n  ErrorCodeTaskNotCancelable,\n  ErrorCodeUnsupportedOperation,\n  ErrorCodePushNotificationNotSupported,\n  configureLogger,\n} from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\ndescribe(\"Error Handling Utilities\", () =&gt; {\n  describe(\"SystemError\", () =&gt; {\n    it(\"should create a SystemError with proper attributes\", () =&gt; {\n      const error = new SystemError(\"System operation failed\", -12345);\n      expect(error.name).toBe(\"RpcError\");\n      expect(error.message).toBe(\"System operation failed\");\n      expect(error.code).toBe(-12345);\n      expect(error).toBeInstanceOf(Error);\n      expect(error).toBeInstanceOf(SystemError);\n    });\n\n    it(\"should include optional data in error object\", () =&gt; {\n      const data = { detail: \"Additional error information\" };\n      const error = new SystemError(\"Error with data\", -32000, data);\n      expect(error.data).toEqual(data);\n    });\n  });\n\n  describe(\"Error Factories\", () =&gt; {\n    it(\"should create Parse Error\", () =&gt; {\n      const error = PARSE_ERROR();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeParseError);\n      expect(error.message).toBe(\"Invalid JSON payload\");\n    });\n\n    it(\"should create Invalid Request Error\", () =&gt; {\n      const error = INVALID_REQUEST();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeInvalidRequest);\n      expect(error.message).toBe(\"Request payload validation error\");\n    });\n\n    it(\"should create Method Not Found Error\", () =&gt; {\n      const error = METHOD_NOT_FOUND();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeMethodNotFound);\n      expect(error.message).toBe(\"Method not found\");\n    });\n\n    it(\"should create Invalid Params Error\", () =&gt; {\n      const error = INVALID_PARAMS();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeInvalidParams);\n      expect(error.message).toBe(\"Invalid parameters\");\n    });\n\n    it(\"should create Internal Error\", () =&gt; {\n      const error = INTERNAL_ERROR();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeInternalError);\n      expect(error.message).toBe(\"Internal error\");\n    });\n\n    it(\"should create Task Not Found Error\", () =&gt; {\n      const error = TASK_NOT_FOUND();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeTaskNotFound);\n      expect(error.message).toBe(\"Task not found\");\n    });\n\n    it(\"should create Task Not Cancelable Error\", () =&gt; {\n      const error = TASK_NOT_CANCELABLE();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeTaskNotCancelable);\n      expect(error.message).toBe(\"Task cannot be canceled\");\n    });\n\n    it(\"should create Unsupported Operation Error\", () =&gt; {\n      const error = UNSUPPORTED_OPERATION();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeUnsupportedOperation);\n      expect(error.message).toBe(\"This operation is not supported\");\n    });\n\n    it(\"should create Push Notification Not Supported Error\", () =&gt; {\n      const error = PUSH_NOTIFICATION_NOT_SUPPORTED();\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodePushNotificationNotSupported);\n      expect(error.message).toBe(\"Push Notification is not supported\");\n    });\n\n    it(\"should include data in created error\", () =&gt; {\n      const data = { field: \"taskId\", reason: \"not found\" };\n      const error = TASK_NOT_FOUND(data);\n      expect(error.data).toEqual(data);\n    });\n  });\n\n  describe(\"FAILED_UPDATE\", () =&gt; {\n    it(\"should create a failed task update\", () =&gt; {\n      const message = \"Task execution failed\";\n      const update = FAILED_UPDATE(message);\n\n      // Test the structure without relying on specific type\n      const failedUpdate = update as any;\n      expect(failedUpdate.state).toBe(\"failed\");\n      expect(failedUpdate.message).toBeDefined();\n      expect(failedUpdate.message.role).toBe(\"agent\");\n      expect(Array.isArray(failedUpdate.message.parts)).toBe(true);\n      expect(failedUpdate.message.parts).toHaveLength(1);\n      expect(failedUpdate.message.parts[0].type).toBe(\"text\");\n      expect(failedUpdate.message.parts[0].text).toBe(message);\n    });\n  });\n\n  describe(\"Error Constants\", () =&gt; {\n    it(\"should have the correct error code values\", () =&gt; {\n      expect(ErrorCodeParseError).toBe(-32700);\n      expect(ErrorCodeInvalidParams).toBe(-32602);\n      expect(ErrorCodeInternalError).toBe(-32603);\n      expect(ErrorCodeInvalidRequest).toBe(-32600);\n      expect(ErrorCodeMethodNotFound).toBe(-32601);\n      expect(ErrorCodeTaskNotFound).toBe(-32001);\n      expect(ErrorCodeTaskNotCancelable).toBe(-32002);\n      expect(ErrorCodeUnsupportedOperation).toBe(-32004);\n      expect(ErrorCodePushNotificationNotSupported).toBe(-32003);\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/common-errors.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest common-errors.test.ts</code></li> </ol>"},{"location":"sdk/tests/common-errors.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/file-storage.test.html","title":"file-storage.test","text":"<p>Tests for file storage.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/file-storage.test.html#test-suites","title":"Test Suites","text":"<ul> <li>FileStore</li> </ul>"},{"location":"sdk/tests/file-storage.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport { join } from \"path\";\nimport { mkdtemp, rm } from \"fs/promises\";\nimport * as os from \"os\";\nimport {\n  configureLogger,\n  FileStore,\n  Task,\n  TaskState,\n  Message,\n} from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\ndescribe(\"FileStore\", () =&gt; {\n  let tempDir: string;\n  let fileStore: FileStore;\n\n  // Create a temporary directory for testing\n  beforeEach(async () =&gt; {\n    tempDir = await mkdtemp(join(os.tmpdir(), \"a2a-file-store-test-\"));\n    fileStore = new FileStore(tempDir);\n  });\n\n  // Clean up the temporary directory after tests\n  afterEach(async () =&gt; {\n    await rm(tempDir, { recursive: true, force: true });\n  });\n\n  it(\"should save and retrieve a task\", async () =&gt; {\n    const taskId = \"test-task-1\";\n    const task: Task = {\n      id: taskId,\n      status: {\n        state: \"working\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n    };\n\n    // Save the task\n    await fileStore.save({ task, history: [] });\n\n    // Retrieve the task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.id).toBe(taskId);\n    expect(result?.task.status.state).toBe(\"working\");\n  });\n\n  it(\"should update an existing task\", async () =&gt; {\n    const taskId = \"test-task-2\";\n    const task: Task = {\n      id: taskId,\n      status: {\n        state: \"submitted\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n    };\n\n    // Save the task initially\n    await fileStore.save({ task, history: [] });\n\n    // Update the task\n    const updatedTask: Task = {\n      id: taskId,\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n      artifacts: [\n        {\n          name: \"result.txt\",\n          parts: [\n            {\n              type: \"text\",\n              text: \"Task completed successfully\",\n            },\n          ],\n        },\n      ],\n    };\n\n    await fileStore.save({ task: updatedTask, history: [] });\n\n    // Retrieve the updated task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.id).toBe(taskId);\n    expect(result?.task.status.state).toBe(\"completed\");\n    expect(result?.task.artifacts).toBeDefined();\n    expect(result?.task.artifacts?.length).toBe(1);\n    expect(result?.task.artifacts?.[0].name).toBe(\"result.txt\");\n  });\n\n  it(\"should return null for non-existent task\", async () =&gt; {\n    const nonExistentTaskId = \"non-existent-task\";\n\n    const result = await fileStore.load(nonExistentTaskId);\n\n    expect(result).toBeNull();\n  });\n\n  it(\"should handle tasks with artifacts containing file parts\", async () =&gt; {\n    const taskId = \"test-file-task\";\n    const fileContent = \"SGVsbG8gQTJBIQ==\"; // Base64 encoded \"Hello A2A!\"\n\n    const task: Task = {\n      id: taskId,\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n      artifacts: [\n        {\n          name: \"example.txt\",\n          parts: [\n            {\n              type: \"file\",\n              file: {\n                name: \"example.txt\",\n                mimeType: \"text/plain\",\n                bytes: fileContent,\n              },\n            },\n          ],\n        },\n      ],\n    };\n\n    // Save the task\n    await fileStore.save({ task, history: [] });\n\n    // Retrieve the task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.artifacts).toBeDefined();\n    expect(result?.task.artifacts?.length).toBe(1);\n\n    const filePart = result?.task.artifacts?.[0].parts[0];\n    expect(filePart?.type).toBe(\"file\");\n    expect((filePart as any).file.name).toBe(\"example.txt\");\n    expect((filePart as any).file.bytes).toBe(fileContent);\n  });\n\n  it(\"should handle tasks with multiple artifacts\", async () =&gt; {\n    const taskId = \"multi-artifact-task\";\n\n    const task: Task = {\n      id: taskId,\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n      artifacts: [\n        {\n          name: \"result1.txt\",\n          parts: [\n            {\n              type: \"text\",\n              text: \"First result\",\n            },\n          ],\n        },\n        {\n          name: \"result2.txt\",\n          parts: [\n            {\n              type: \"text\",\n              text: \"Second result\",\n            },\n          ],\n        },\n      ],\n    };\n\n    // Save the task\n    await fileStore.save({ task, history: [] });\n\n    // Retrieve the task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.artifacts).toBeDefined();\n    expect(result?.task.artifacts?.length).toBe(2);\n    expect(result?.task.artifacts?.[0].name).toBe(\"result1.txt\");\n    expect(result?.task.artifacts?.[1].name).toBe(\"result2.txt\");\n  });\n\n  it(\"should save and retrieve task history\", async () =&gt; {\n    const taskId = \"history-task\";\n\n    const task: Task = {\n      id: taskId,\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n    };\n\n    const history: Message[] = [\n      {\n        role: \"user\",\n        parts: [\n          {\n            type: \"text\",\n            text: \"Initial request\",\n          },\n        ],\n      },\n      {\n        role: \"agent\",\n        parts: [\n          {\n            type: \"text\",\n            text: \"Agent response\",\n          },\n        ],\n      },\n    ];\n\n    // Save the task with history\n    await fileStore.save({ task, history });\n\n    // Retrieve the task and history\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.history).toBeDefined();\n    expect(result?.history.length).toBe(2);\n    expect(result?.history[0].role).toBe(\"user\");\n    expect(result?.history[1].role).toBe(\"agent\");\n  });\n});\n</code></pre>"},{"location":"sdk/tests/file-storage.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest file-storage.test.ts</code></li> </ol>"},{"location":"sdk/tests/file-storage.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/http-utils.test.html","title":"http-utils.test","text":"<p>Tests for http utils.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/http-utils.test.html#test-suites","title":"Test Suites","text":"<ul> <li>HTTP Utils</li> <li>sendJsonRpcRequest</li> <li>sendGetRequest</li> <li>handleJsonRpcResponse</li> <li>handleJsonResponse</li> <li>parseResponse</li> <li>executeJsonRpcRequest</li> <li>executeGetRequest</li> <li>handleEventStream</li> <li>executeStreamEvents</li> <li>createJsonRpcRequest</li> <li>sendJsonRpcRequest with network errors</li> <li>sendGetRequest with network errors</li> <li>parseResponse additional cases</li> <li>handleJsonResponse additional cases</li> </ul>"},{"location":"sdk/tests/http-utils.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport { http, HttpResponse } from \"msw\";\nimport { setupServer } from \"msw/node\";\nimport {\n  sendJsonRpcRequest,\n  sendGetRequest,\n  handleJsonRpcResponse,\n  handleJsonResponse,\n  executeJsonRpcRequest,\n  executeGetRequest,\n  createJsonRpcRequest,\n  parseResponse,\n  handleEventStream,\n  ErrorCodeParseError,\n  JSONRPCRequest,\n  JSONRPCResponse,\n  SystemError,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Define a TestRequest type that matches JSONRPCRequest constraint\ntype TestMethod =\n  | \"test/method\"\n  | \"test/empty\"\n  | \"test/invalid\"\n  | \"test/error\"\n  | \"test/network-error\"\n  | \"test/streaming\";\n\n// Define a custom request type for testing\ninterface TestRequest extends JSONRPCRequest {\n  method: TestMethod;\n  params: {\n    param?: string;\n    status?: string;\n    [key: string]: any;\n  };\n}\n\nconfigureLogger({ level: \"silent\" });\n\n// Setup MSW server for mocking HTTP requests\nconst server = setupServer(\n  // Mock successful request\n  http.post(\"https://example.com/api\", ({ request }) =&gt; {\n    const url = new URL(request.url);\n    if (url.pathname === \"/api\") {\n      const contentType = request.headers.get(\"Content-Type\") || \"\";\n      if (contentType.includes(\"application/json\")) {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          result: { foo: \"bar\" },\n        });\n      }\n    }\n    return HttpResponse.json({}, { status: 404 });\n  }),\n\n  // Mock successful GET request\n  http.get(\"https://example.com/api\", () =&gt; {\n    return HttpResponse.json({ success: true });\n  }),\n\n  // Mock network error GET request\n  http.get(\"https://example.com/api/error\", () =&gt; {\n    return new HttpResponse(null, { status: 500 });\n  }),\n\n  // Mock invalid JSON response\n  http.get(\"https://example.com/api/invalid\", () =&gt; {\n    return new HttpResponse(\"not a json\", {\n      status: 200,\n      headers: { \"Content-Type\": \"text/plain\" },\n    });\n  }),\n\n  // Mock invalid JSON-RPC response with null result\n  http.get(\"https://example.com/api/null-result\", () =&gt; {\n    return HttpResponse.json({\n      jsonrpc: \"2.0\",\n      id: \"test-id\",\n    });\n  }),\n\n  // Mock empty response\n  http.get(\"https://example.com/api/empty-response\", () =&gt; {\n    return new HttpResponse(null, { status: 204 });\n  }),\n\n  // Mock network error for specific endpoints\n  http.get(\"https://example.com/api/network-error\", () =&gt; {\n    throw new Error(\"Network error\");\n  }),\n\n  http.post(\"https://example.com/api/network-error\", () =&gt; {\n    throw new Error(\"Network error\");\n  }),\n\n  // Mock RPC error response\n  http.post(\"https://example.com/api/rpc-error\", () =&gt; {\n    return HttpResponse.json(\n      {\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32603,\n          message: \"Internal error\",\n          data: { details: \"Something went wrong\" },\n        },\n      },\n      { status: 200 }\n    );\n  }),\n\n  // Mock invalid streaming response\n  http.post(\"https://example.com/api/streaming\", () =&gt; {\n    const encoder = new TextEncoder();\n    const stream = new ReadableStream({\n      start(controller) {\n        controller.enqueue(\n          encoder.encode(\n            `event: message\\ndata: ${JSON.stringify({\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              result: { status: \"working\" },\n            })}\\n\\n`\n          )\n        );\n        controller.enqueue(\n          encoder.encode(\n            `event: message\\ndata: ${JSON.stringify({\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              result: { status: \"completed\" },\n            })}\\n\\n`\n          )\n        );\n        controller.close();\n      },\n    });\n\n    return new HttpResponse(stream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        Connection: \"keep-alive\",\n        \"Cache-Control\": \"no-cache\",\n      },\n    });\n  }),\n\n  http.post(\"https://example.com/api/invalid-streaming\", () =&gt; {\n    const encoder = new TextEncoder();\n    const stream = new ReadableStream({\n      start(controller) {\n        controller.enqueue(encoder.encode(`event: message\\ndata: invalid\\n\\n`));\n        controller.close();\n      },\n    });\n\n    return new HttpResponse(stream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        Connection: \"keep-alive\",\n        \"Cache-Control\": \"no-cache\",\n      },\n    });\n  })\n);\n\ndescribe(\"HTTP Utils\", () =&gt; {\n  beforeAll(() =&gt; {\n    server.listen();\n  });\n\n  afterAll(() =&gt; {\n    server.close();\n  });\n\n  beforeEach(() =&gt; {\n    server.resetHandlers();\n  });\n\n  describe(\"sendJsonRpcRequest\", () =&gt; {\n    test(\"should send a JSON-RPC request and return the response\", async () =&gt; {\n      const response = await sendJsonRpcRequest(\n        new URL(\"https://example.com/api\"),\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        { \"Custom-Header\": \"value\" }\n      );\n\n      expect(response.ok).toBe(true);\n      const data = await response.json();\n      expect(data).toEqual({\n        jsonrpc: \"2.0\",\n        id: expect.any(String),\n        result: { foo: \"bar\" },\n      });\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      // Configure MSW to simulate a network error for this specific test\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(null, { status: 500 });\n        })\n      );\n\n      try {\n        await sendJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/method\" as any,\n          {} as any\n        );\n        // If we get here, the test should fail only if we got a response\n        // but we expected to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n  });\n\n  describe(\"sendGetRequest\", () =&gt; {\n    test(\"should send a GET request and return the response\", async () =&gt; {\n      const response = await sendGetRequest(\n        new URL(\"https://example.com/api\"),\n        { \"Custom-Header\": \"value\" }\n      );\n\n      expect(response.ok).toBe(true);\n      const data = await response.json();\n      expect(data).toEqual({ success: true });\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      // Configure MSW to simulate a network error for this specific test\n      server.use(\n        http.get(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(null, { status: 500 });\n        })\n      );\n\n      try {\n        await sendGetRequest(new URL(\"https://example.com/api\"));\n        // If we got here, the test should only fail if we got a response\n        // when we expected it to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n  });\n\n  describe(\"handleJsonRpcResponse\", () =&gt; {\n    test(\"should parse and return the result from a JSON-RPC response\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/method\",\n        }),\n      });\n\n      const result = await handleJsonRpcResponse&lt;\n        JSONRPCResponse&lt;{ foo: string }&gt;\n      &gt;(response, \"test/method\");\n      expect(result).toEqual({ foo: \"bar\" });\n    });\n\n    test(\"should handle HTTP errors with JSON-RPC errors\", async () =&gt; {\n      // Override the response for this specific test\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return HttpResponse.json(\n            {\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              error: {\n                code: -32603,\n                message: \"Internal error\",\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/error\",\n        }),\n      });\n\n      try {\n        await handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/error\");\n        // If we get here, the test should fail\n        expect(true).toBe(false); // Force test to fail\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n      }\n    });\n\n    test(\"should handle HTTP errors with non-JSON-RPC responses\", async () =&gt; {\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(\"Not a JSON-RPC response\", {\n            status: 500,\n            headers: { \"Content-Type\": \"text/plain\" },\n          });\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/method\",\n        }),\n      });\n\n      await expect(\n        handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/method\")\n      ).rejects.toThrow();\n    });\n\n    test(\"should handle responses with invalid JSON\", async () =&gt; {\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(\"not a json\", {\n            status: 200,\n            headers: { \"Content-Type\": \"text/plain\" },\n          });\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/method\",\n        }),\n      });\n\n      await expect(\n        handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/method\")\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle JSON-RPC errors with data field\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/rpc-error\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ jsonrpc: \"2.0\", id: \"test-id\" }),\n      });\n\n      await expect(\n        handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/error-with-data\")\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle non-A2AError exceptions during processing\", async () =&gt; {\n      // Use a direct test of the error handling path in handleJsonRpcResponse\n      const invalidResponse = new Response(null, { status: 200 });\n\n      try {\n        await handleJsonRpcResponse&lt;JSONRPCResponse&gt;(\n          invalidResponse,\n          \"test/error-handling\"\n        );\n        // Should not reach here\n        expect(\"this line\").toBe(\"not reached\");\n      } catch (error) {\n        // Verify it's an A2AError with the right code\n        expect(error instanceof SystemError).toBe(true);\n        expect((error as SystemError).code).toBe(ErrorCodeParseError);\n      }\n    });\n  });\n\n  describe(\"handleJsonResponse\", () =&gt; {\n    test(\"should parse and return JSON from a successful response\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api\");\n      const result = await handleJsonResponse&lt;{ success: boolean }&gt;(\n        response,\n        \"test-endpoint\"\n      );\n      expect(result).toEqual({ success: true });\n    });\n\n    test(\"should handle HTTP errors\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/error\");\n      await expect(\n        handleJsonResponse&lt;any&gt;(response, \"error-endpoint\")\n      ).rejects.toThrow();\n    });\n\n    test(\"should handle invalid JSON\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/invalid\");\n      await expect(\n        handleJsonResponse&lt;any&gt;(response, \"invalid-endpoint\")\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle empty responses\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/empty-response\");\n      await expect(\n        handleJsonResponse&lt;any&gt;(response, \"empty-response-endpoint\")\n      ).rejects.toThrow(SystemError);\n    });\n  });\n\n  describe(\"parseResponse\", () =&gt; {\n    test(\"should parse valid JSON-RPC response\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        result: { foo: \"bar\" },\n      });\n\n      const result = parseResponse&lt;JSONRPCResponse&lt;{ foo: string }&gt;&gt;(data);\n      expect(result).toEqual({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        result: { foo: \"bar\" },\n      });\n    });\n\n    test(\"should throw for empty data\", () =&gt; {\n      expect(() =&gt; parseResponse(\"\")).toThrow(SystemError);\n    });\n\n    test(\"should throw for JSON-RPC errors\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32601,\n          message: \"Method not found\",\n        },\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for JSON-RPC errors with data field\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32603,\n          message: \"Internal error\",\n          data: { details: \"Something went wrong\" },\n        },\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for invalid JSON-RPC structure\", () =&gt; {\n      const data = JSON.stringify({\n        not: \"jsonrpc\",\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for missing result\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for invalid JSON\", () =&gt; {\n      expect(() =&gt; parseResponse(\"invalid json\")).toThrow(SystemError);\n    });\n  });\n\n  describe(\"executeJsonRpcRequest\", () =&gt; {\n    test(\"should execute a JSON-RPC request and return the result\", async () =&gt; {\n      const result = await executeJsonRpcRequest(\n        new URL(\"https://example.com/api\"),\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        { \"Custom-Header\": \"value\" }\n      );\n\n      expect(result).toEqual({ foo: \"bar\" });\n    });\n\n    test(\"should handle errors\", async () =&gt; {\n      // Override the response for this specific test\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return HttpResponse.json(\n            {\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              error: {\n                code: -32603,\n                message: \"Internal error\",\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      try {\n        await executeJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/error\" as any,\n          {} as any\n        );\n        // If we got here, the test should only fail if we got a response\n        // when we expected it to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          throw new Error(\"Network error\");\n        })\n      );\n\n      try {\n        await executeJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/method\" as any,\n          {} as any\n        );\n        // If we got here, the test should only fail if we got a response\n        // when we expected it to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n\n    test(\"should accept different accept headers\", async () =&gt; {\n      const result = await executeJsonRpcRequest(\n        new URL(\"https://example.com/api\"),\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        { \"Custom-Header\": \"value\" },\n        \"application/json\"\n      );\n\n      expect(result).toEqual({ foo: \"bar\" });\n    });\n  });\n\n  describe(\"executeGetRequest\", () =&gt; {\n    test(\"should execute a GET request and return the parsed result\", async () =&gt; {\n      const result = await executeGetRequest&lt;{ success: boolean }&gt;(\n        new URL(\"https://example.com/api\"),\n        { \"Custom-Header\": \"value\" },\n        \"test-endpoint\"\n      );\n\n      expect(result).toEqual({ success: true });\n    });\n\n    test(\"should handle errors\", async () =&gt; {\n      await expect(\n        executeGetRequest&lt;any&gt;(\n          new URL(\"https://example.com/api/error\"),\n          {},\n          \"error-endpoint\"\n        )\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      server.use(\n        http.get(\"https://example.com/api\", () =&gt; {\n          throw new Error(\"Network error\");\n        })\n      );\n\n      await expect(\n        executeGetRequest&lt;any&gt;(\n          new URL(\"https://example.com/api\"),\n          {},\n          \"network-error-endpoint\"\n        )\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should work without optional parameters\", async () =&gt; {\n      const result = await executeGetRequest&lt;{ success: boolean }&gt;(\n        new URL(\"https://example.com/api\")\n      );\n\n      expect(result).toEqual({ success: true });\n    });\n  });\n\n  describe(\"handleEventStream\", () =&gt; {\n    test(\"should handle empty events array\", async () =&gt; {\n      const encoder = new TextEncoder();\n      const stream = new ReadableStream({\n        start(controller) {\n          // Send an event with valid structure but no data we care about\n          controller.enqueue(\n            encoder.encode(\n              `event: message\\ndata: ${JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"test-id\",\n                // Missing result property intentionally\n              })}\\n\\n`\n            )\n          );\n          controller.close();\n        },\n      });\n\n      const response = new Response(stream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n\n      const generator = handleEventStream&lt;JSONRPCResponse&gt;(response);\n      const results: any[] = [];\n\n      for await (const event of generator) {\n        results.push(event);\n      }\n\n      // Should not yield any events since the input had none\n      expect(results.length).toBe(0);\n    });\n\n    test(\"should handle parser errors in event data\", async () =&gt; {\n      const encoder = new TextEncoder();\n      const stream = new ReadableStream({\n        start(controller) {\n          // Send an invalid event (not proper JSON)\n          controller.enqueue(\n            encoder.encode(`event: message\\ndata: invalid-json\\n\\n`)\n          );\n          controller.close();\n        },\n      });\n\n      const response = new Response(stream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n\n      const generator = handleEventStream&lt;JSONRPCResponse&gt;(response);\n      const results: any[] = [];\n\n      for await (const event of generator) {\n        results.push(event);\n      }\n\n      // Should not yield any events since the input was invalid\n      expect(results.length).toBe(0);\n    });\n\n    test(\"should handle valid events with undefined result\", async () =&gt; {\n      const encoder = new TextEncoder();\n      const stream = new ReadableStream({\n        start(controller) {\n          // Send an event with null result to trigger the warning branch\n          controller.enqueue(\n            encoder.encode(\n              `event: message\\ndata: ${JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"test-id\",\n                result: undefined,\n              })}\\n\\n`\n            )\n          );\n          controller.close();\n        },\n      });\n\n      const response = new Response(stream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n\n      const generator = handleEventStream&lt;JSONRPCResponse&gt;(response);\n      const results: any[] = [];\n\n      for await (const event of generator) {\n        results.push(event);\n      }\n\n      // Should not yield any events since result was undefined\n      expect(results.length).toBe(0);\n    });\n  });\n\n  describe(\"executeStreamEvents\", () =&gt; {\n    test.skip(\"should execute a streaming request and yield events\", () =&gt; {});\n\n    test.skip(\"should handle errors in streaming requests\", () =&gt; {});\n  });\n\n  describe(\"createJsonRpcRequest\", () =&gt; {\n    test(\"should create a properly formatted JSON-RPC request with custom ID\", () =&gt; {\n      const request = createJsonRpcRequest(\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        \"custom-id\"\n      );\n      expect(request).toEqual({\n        jsonrpc: \"2.0\",\n        id: \"custom-id\",\n        method: \"test/method\",\n        params: {},\n      });\n    });\n\n    test(\"should create a properly formatted JSON-RPC request with auto-generated ID\", () =&gt; {\n      const request = createJsonRpcRequest(\n        \"test/method\" as any,\n        {} as any // Empty object to avoid type issues\n      );\n      expect(request).toEqual({\n        jsonrpc: \"2.0\",\n        id: expect.any(String), // UUID is auto-generated\n        method: \"test/method\",\n        params: {},\n      });\n    });\n  });\n\n  describe(\"sendJsonRpcRequest with network errors\", () =&gt; {\n    test(\"should handle network error that's not an Error instance\", async () =&gt; {\n      try {\n        await sendJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/method\" as any,\n          {} as any // Empty params to avoid type issues\n        );\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect(error.message).toContain(\"Network connection lost\");\n      }\n    });\n  });\n\n  describe(\"sendGetRequest with network errors\", () =&gt; {\n    test(\"should handle network error that's not an Error instance\", async () =&gt; {\n      try {\n        await sendGetRequest(new URL(\"https://example.com/api\"));\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect(error.message).toContain(\"Connection timeout\");\n      }\n    });\n  });\n\n  describe(\"parseResponse additional cases\", () =&gt; {\n    test(\"should handle error that's not an A2AError during parsing\", () =&gt; {\n      try {\n        parseResponse(\"invalid json\");\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect((error as SystemError).code).toBe(ErrorCodeParseError);\n      }\n    });\n  });\n\n  describe(\"handleJsonResponse additional cases\", () =&gt; {\n    test(\"should handle error that's not an Error instance\", async () =&gt; {\n      server.use(\n        http.get(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(\"\", {\n            status: 200,\n            headers: { \"Content-Type\": \"application/json\" },\n          });\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\");\n      try {\n        await handleJsonResponse(response, \"custom-endpoint\");\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect(error.message).toContain(\"Invalid JSON payload\");\n      }\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/http-utils.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest http-utils.test.ts</code></li> </ol>"},{"location":"sdk/tests/http-utils.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/integration.test.html","title":"integration.test","text":"<p>Simple echo task handler for testing</p>"},{"location":"sdk/tests/integration.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Client-Server Integration Tests</li> </ul>"},{"location":"sdk/tests/integration.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport express from \"express\";\nimport {\n  A2AClient,\n  A2AServer,\n  InMemoryTaskStore,\n  TaskContext,\n  TaskYieldUpdate,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n/**\n * Simple echo task handler for testing\n */\nasync function* echoHandler(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, void, unknown&gt; {\n  // Extract user text\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Send working status\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Processing...\" }],\n    },\n  };\n\n  // Check cancellation\n  if (context.isCancelled()) {\n    yield {\n      state: \"canceled\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task was canceled.\" }],\n      },\n    };\n    return;\n  }\n\n  // Create a response\n  const response = `You said: \"${userText}\"`;\n\n  // Create an artifact\n  yield {\n    name: \"echo.txt\",\n    parts: [{ type: \"text\", text: response }],\n  };\n\n  // Complete the task\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: response }],\n    },\n  };\n}\n\ndescribe(\"Client-Server Integration Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let expressServer: any;\n  let port: number;\n  let client: A2AClient;\n\n  beforeEach(async () =&gt; {\n    // Create a simple server\n    server = new A2AServer({\n      handler: echoHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0,\n    });\n    app = server.start();\n\n    // Get the actual port\n    expressServer = app.listen(0);\n    port = (expressServer.address() as any).port;\n\n    // Create client\n    client = new A2AClient(`http://localhost:${port}`);\n  });\n\n  afterEach(async () =&gt; {\n    // Force close any open connections\n    return new Promise&lt;void&gt;((resolve) =&gt; {\n      // Close the express server gracefully\n      server.stop().then(() =&gt; {\n        // Allow some time for connections to fully close\n        setTimeout(resolve, 100);\n      });\n      expressServer.close(() =&gt; {\n        resolve();\n      });\n    });\n  });\n\n  test(\"client can retrieve agent card\", async () =&gt; {\n    const card = await client.agentCard();\n\n    expect(card).toBeDefined();\n    expect(card.name).toBe(\"A2A Server\");\n    expect(card.capabilities.streaming).toBe(true);\n  });\n\n  test(\"client can send task and get response\", async () =&gt; {\n    const testMessage = \"Hello, A2A!\";\n    const task = await client.sendTask({\n      id: \"test-task-1\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: testMessage }],\n      },\n    });\n\n    expect(task).toBeDefined();\n    expect(task!.id).toBe(\"test-task-1\");\n    expect(task!.status.state).toBe(\"completed\");\n\n    // Check if the response message contains our echo\n    const responseText = task!.status.message?.parts\n      .filter((part) =&gt; part.type === \"text\")\n      .map((part) =&gt; (part as any).text)\n      .join(\" \");\n\n    expect(responseText).toContain(testMessage);\n\n    // Check if artifact was created\n    expect(task!.artifacts).toBeDefined();\n    expect(task!.artifacts!.length).toBe(1);\n    expect(task!.artifacts![0].name).toBe(\"echo.txt\");\n  });\n\n  test(\"client can stream task updates\", async () =&gt; {\n    const testMessage = \"Test streaming\";\n    const stream = client.sendTaskSubscribe({\n      id: \"test-stream-task\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: testMessage }],\n      },\n    });\n\n    const updates: any[] = [];\n    for await (const update of stream) {\n      updates.push(update);\n    }\n\n    // We should have at least 3 updates:\n    // 1. \"submitted\" status (initial state from server)\n    // 2. \"working\" status (from our handler)\n    // 3. artifact\n    // 4. \"completed\" status\n    expect(updates.length).toBeGreaterThanOrEqual(3);\n\n    // First update should be \"submitted\" status\n    expect(updates[0].status?.state).toBe(\"submitted\");\n\n    // Second update should be \"working\" status\n    if (updates.length &gt; 1) {\n      expect(updates[1].status?.state).toBe(\"working\");\n    }\n\n    // Check for artifact update\n    const artifactUpdate = updates.find((u) =&gt; u.artifact);\n    expect(artifactUpdate).toBeDefined();\n    expect(artifactUpdate.artifact.name).toBe(\"echo.txt\");\n\n    // Last update should be \"completed\" status\n    const lastUpdate = updates[updates.length - 1];\n    expect(lastUpdate.status?.state).toBe(\"completed\");\n\n    // Verify response text contains our message\n    const responseText = lastUpdate.status.message?.parts\n      .filter((part: any) =&gt; part.type === \"text\")\n      .map((part: any) =&gt; part.text)\n      .join(\" \");\n\n    expect(responseText).toContain(testMessage);\n  });\n\n  test(\"client can cancel a task\", async () =&gt; {\n    // First send a task to create it\n    const task = await client.sendTask({\n      id: \"cancel-task-test\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: \"Task to be canceled\" }],\n      },\n    });\n\n    try {\n      // Now try to cancel it (note: in a real scenario this would need to be a long-running task)\n      const canceledTask = await client.cancelTask({\n        id: \"cancel-task-test\",\n      });\n      console.log(\"canceledTask\", canceledTask);\n      expect(canceledTask).toBeDefined();\n      // Should be in canceled state\n      expect(canceledTask!.status.state).toBe(\"canceled\");\n    } catch (error: any) {\n      // The task might complete too quickly to be canceled, resulting in a \"cannot be canceled\" error\n      // This is also a valid test scenario\n\n      // The error message should contain the task cannot be canceled text\n      // Not checking the exact error code because it may be wrapped in an internal error\n      expect(error.code).toBe(-32002);\n      expect(error.message).toContain(\"Task cannot be canceled\");\n    }\n  });\n\n  test(\"client can get task by ID\", async () =&gt; {\n    // First create a task\n    await client.sendTask({\n      id: \"get-task-test\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: \"Task to be retrieved\" }],\n      },\n    });\n\n    // Now retrieve it\n    const task = await client.getTask({\n      id: \"get-task-test\",\n    });\n\n    expect(task).toBeDefined();\n    expect(task!.id).toBe(\"get-task-test\");\n    expect(task!.status.state).toBe(\"completed\");\n  });\n});\n</code></pre>"},{"location":"sdk/tests/integration.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest integration.test.ts</code></li> </ol>"},{"location":"sdk/tests/integration.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/register.test.html","title":"register.test","text":"<p>Tests for register.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/register.test.html#test-suites","title":"Test Suites","text":"<ul> <li>register Function</li> </ul>"},{"location":"sdk/tests/register.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest, describe, test, expect } from \"@jest/globals\";\nimport { register, convert, AgentCard, configureLogger } from \"../src/index.js\";\nimport { MetadataValidator } from \"@artinet/metadata-validator\";\n\nconfigureLogger({ level: \"silent\" });\n// Mock global fetch with proper typing for mock implementation\nglobal.fetch = jest.fn() as jest.MockedFunction&lt;typeof fetch&gt;;\nconst mockFetch = global.fetch as jest.MockedFunction&lt;typeof fetch&gt;;\n\ndescribe(\"register Function\", () =&gt; {\n  let sampleAgentCard: AgentCard;\n\n  beforeEach(() =&gt; {\n    // Reset all mocks before each test\n    jest.clearAllMocks();\n    mockFetch.mockClear();\n    mockFetch.mockResolvedValue({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: {\n            success: true,\n            registrationId: \"default-reg-id\",\n          },\n        }),\n      }),\n    } as Response); // Assert as Response type\n\n    // Define a basic AgentCard for testing\n    sampleAgentCard = {\n      name: \"Test Agent\",\n      description: \"A test agent card\",\n      url: \"https://agents.artinet.io/agent\",\n      version: \"1.0.0\",\n      capabilities: {\n        streaming: false,\n        pushNotifications: false,\n        stateTransitionHistory: false,\n      },\n      skills: [\n        { id: \"skill1\", name: \"Skill One\", description: \"Does one thing\" },\n        { id: \"skill2\", name: \"Skill Two\", description: \"Does another thing\" },\n      ],\n      defaultInputModes: [\"text\"],\n      defaultOutputModes: [\"text\"],\n      authentication: undefined, // Explicitly no auth for default test card\n      provider: { organization: \"Test Org\", url: \"http://test.org\" },\n      documentationUrl: \"http://docs.test.org\",\n    };\n  });\n\n  test(\"valid AgentCard should validate\", async () =&gt; {\n    const registration = await convert(sampleAgentCard);\n    const validator = new MetadataValidator();\n    const { isValid, errors } = await validator.validateMetadata(registration);\n    expect(isValid).toBe(true);\n    expect(errors.length).toBe(0);\n  });\n\n  test(\"invalid AgentCard should not validate\", async () =&gt; {\n    const registration = await convert(sampleAgentCard);\n    registration.version = \"invalid-version\";\n    const validator = new MetadataValidator();\n    const { isValid, errors } = await validator.validateMetadata(registration);\n    expect(isValid).toBe(false);\n    expect(errors.length).toBeGreaterThan(0);\n  });\n\n  test(\"should register successfully and return registrationId\", async () =&gt; {\n    const expectedRegId = \"test-success-id\";\n\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: {\n            success: true,\n            registrationId: expectedRegId,\n          },\n        }),\n      }),\n    } as Response);\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(expectedRegId);\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n  test(\"should return empty string and log warning on API call failure (success: false)\", async () =&gt; {\n    const apiErrorMsg = \"Failed to register with API\";\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: { success: false, error: apiErrorMsg },\n        }),\n      }),\n    } as Response);\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"should return empty string if API returns success but no registrationId\", async () =&gt; {\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: { success: true, registrationId: undefined },\n        }),\n      }),\n    } as Response);\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"should return empty string and log warning if fetch throws a network error\", async () =&gt; {\n    const fetchErrorMsg = \"Network Error\";\n    mockFetch.mockRejectedValueOnce(new Error(fetchErrorMsg));\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"should set endpoint authentication to true if AgentCard has auth schemes\", async () =&gt; {\n    sampleAgentCard.authentication = {\n      schemes: [\"bearer\"],\n      credentials: \"test-token\",\n    };\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: { success: true, registrationId: \"id-456\" },\n        }),\n      }),\n    } as Response);\n    await register(sampleAgentCard);\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n  test(\"should return empty string if URL is localhost\", async () =&gt; {\n    sampleAgentCard.url = \"http://localhost:8080/agent\";\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n  });\n  test(\"should return empty string if URL is 127.0.0.1\", async () =&gt; {\n    sampleAgentCard.url = \"http://127.0.0.1:8080/agent\";\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n  });\n  test(\"should return empty string if URL is empty\", async () =&gt; {\n    sampleAgentCard.url = \"\";\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n  });\n});\n</code></pre>"},{"location":"sdk/tests/register.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest register.test.ts</code></li> </ol>"},{"location":"sdk/tests/register.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/rpc-client.test.html","title":"rpc-client.test","text":"<p>Tests for rpc client.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/rpc-client.test.html#test-suites","title":"Test Suites","text":"<ul> <li>RPC Client</li> <li>createJsonRpcRequest</li> <li>executeJsonRpcRequest</li> <li>parseResponse</li> </ul>"},{"location":"sdk/tests/rpc-client.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport { http, HttpResponse } from \"msw\";\nimport { setupServer } from \"msw/node\";\nimport { configureLogger, SystemError } from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\n// Override the createJsonRpcRequest for testing to avoid type checking\nfunction createTestRequest(\n  method: string,\n  params: any,\n  id: string | number = \"test-\" + Math.random().toString(36).substring(2, 9)\n): any {\n  return {\n    jsonrpc: \"2.0\",\n    id,\n    method,\n    params,\n  };\n}\n\n// Define a simpler version of executeJsonRpcRequest for testing\nasync function executeJsonRpcRequestTest(\n  baseUrl: URL,\n  method: string,\n  params: any,\n  headers: Record&lt;string, string&gt; = {},\n  options: { timeout?: number } = {}\n): Promise&lt;any&gt; {\n  const requestBody = createTestRequest(method, params);\n\n  const controller = new AbortController();\n  let timeoutId: NodeJS.Timeout | undefined;\n\n  if (options.timeout) {\n    timeoutId = setTimeout(() =&gt; controller.abort(), options.timeout);\n  }\n\n  try {\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...headers,\n      },\n      body: JSON.stringify(requestBody),\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error ${response.status}`);\n    }\n\n    const textResponse = await response.text();\n    return parseResponseTest(textResponse);\n  } catch (error) {\n    if (error instanceof DOMException &amp;&amp; error.name === \"AbortError\") {\n      throw new Error(\"Request timeout\");\n    }\n    throw error;\n  } finally {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n  }\n}\n\n// Define a simpler version of parseResponse for testing\nfunction parseResponseTest(data: string): any {\n  if (!data) {\n    throw new Error(\"Empty response\");\n  }\n\n  const parsed = JSON.parse(data);\n\n  if (parsed.error) {\n    throw new SystemError(\n      parsed.error.message,\n      parsed.error.code,\n      parsed.error.data\n    );\n  }\n\n  if (\n    typeof parsed !== \"object\" ||\n    parsed === null ||\n    parsed.jsonrpc !== \"2.0\"\n  ) {\n    throw new Error(\"Invalid response format\");\n  }\n\n  if (parsed.result === undefined) {\n    throw new Error(\"Invalid response: missing result\");\n  }\n\n  return parsed.result;\n}\n\n// Define the structure of our expected request body\ninterface TestJsonRpcRequest {\n  jsonrpc: string;\n  id: string | number;\n  method: string;\n  params?: Record&lt;string, any&gt;;\n}\n\n// Setup MSW server for mocking HTTP requests\nconst server = setupServer(\n  // Mock successful JSON-RPC request\n  http.post(\"https://example.com/api\", async ({ request }) =&gt; {\n    const body = (await request.json()) as TestJsonRpcRequest;\n\n    if (typeof body === \"object\" &amp;&amp; body !== null) {\n      if (body.method === \"test/echo\") {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: body.id,\n          result: body.params,\n        });\n      }\n\n      if (body.method === \"test/error\") {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: body.id,\n          error: {\n            code: -32603,\n            message: \"Test error\",\n            data: { detail: \"This is a test error\" },\n          },\n        });\n      }\n\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id || \"unknown\",\n        error: {\n          code: -32601,\n          message: \"Method not found\",\n        },\n      });\n    }\n\n    // Return a generic error for invalid bodies\n    return HttpResponse.json({\n      jsonrpc: \"2.0\",\n      id: null,\n      error: {\n        code: -32700,\n        message: \"Parse error\",\n      },\n    });\n  }),\n\n  // Mock error response\n  http.post(\"https://example.com/api/error\", () =&gt; {\n    return new HttpResponse(null, { status: 500 });\n  }),\n\n  // Mock timeout\n  http.post(\"https://example.com/api/timeout\", () =&gt; {\n    return new Promise((resolve) =&gt; {\n      // Resolve after timeout to simulate network timeout\n      setTimeout(() =&gt; {\n        resolve(\n          HttpResponse.json({\n            jsonrpc: \"2.0\",\n            id: \"timeout-request\",\n            result: { message: \"Too late\" },\n          })\n        );\n      }, 2000);\n    });\n  })\n);\n\ndescribe(\"RPC Client\", () =&gt; {\n  beforeAll(() =&gt; {\n    server.listen();\n  });\n\n  afterAll(() =&gt; {\n    server.close();\n  });\n\n  beforeEach(() =&gt; {\n    server.resetHandlers();\n  });\n\n  describe(\"createJsonRpcRequest\", () =&gt; {\n    it(\"creates a valid JSON-RPC 2.0 request object\", () =&gt; {\n      // Use our test function instead of the actual one\n      const request = createTestRequest(\"test/method\", { param1: \"value1\" });\n\n      expect(request.jsonrpc).toBe(\"2.0\");\n      expect(request.method).toBe(\"test/method\");\n      expect(request.params).toEqual({ param1: \"value1\" });\n      expect(request.id).toBeDefined();\n      expect(typeof request.id).toBe(\"string\");\n    });\n\n    it(\"preserves the provided ID if supplied\", () =&gt; {\n      const customId = \"custom-request-id\";\n      // Use our test function instead of the actual one\n      const request = createTestRequest(\n        \"test/method\",\n        { param1: \"value1\" },\n        customId\n      );\n\n      expect(request.id).toBe(customId);\n    });\n  });\n\n  describe(\"executeJsonRpcRequest\", () =&gt; {\n    it(\"successfully executes a JSON-RPC request and returns the result\", async () =&gt; {\n      const params = { message: \"Hello, API!\" };\n      const result = await executeJsonRpcRequestTest(\n        new URL(\"https://example.com/api\"),\n        \"test/echo\",\n        params\n      );\n\n      expect(result).toEqual(params);\n    });\n\n    it(\"throws a SystemError on JSON-RPC error response\", async () =&gt; {\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api\"),\n          \"test/error\",\n          {}\n        )\n      ).rejects.toThrow(SystemError);\n\n      try {\n        await executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api\"),\n          \"test/error\",\n          {}\n        );\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect((error as SystemError).code).toBe(-32603);\n        expect((error as SystemError).message).toBe(\"Test error\");\n        expect((error as SystemError).data).toEqual({\n          detail: \"This is a test error\",\n        });\n      }\n    });\n\n    it(\"throws an error for non-existent methods\", async () =&gt; {\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api\"),\n          \"non/existent/method\",\n          {}\n        )\n      ).rejects.toThrow(\"Method not found\");\n    });\n\n    it(\"throws an error for HTTP error responses\", async () =&gt; {\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api/error\"),\n          \"test/method\",\n          {}\n        )\n      ).rejects.toThrow();\n    });\n\n    it(\"times out for long-running requests\", async () =&gt; {\n      // Set a short timeout for this test\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api/timeout\"),\n          \"test/method\",\n          {},\n          {},\n          { timeout: 500 } // 500ms timeout\n        )\n      ).rejects.toThrow(/timeout/i);\n    }, 2000); // Set a timeout for the test itself\n  });\n\n  describe(\"parseResponse\", () =&gt; {\n    it(\"parses a valid JSON-RPC response\", async () =&gt; {\n      const responseText = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        result: { success: true },\n      });\n\n      const parsedResult = parseResponseTest(responseText);\n      expect(parsedResult).toEqual({ success: true });\n    });\n\n    it(\"throws for invalid JSON responses\", async () =&gt; {\n      const responseText = \"This is not JSON\";\n\n      expect(() =&gt; parseResponseTest(responseText)).toThrow();\n    });\n\n    it(\"throws for missing result and error fields\", async () =&gt; {\n      const responseText = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        // Missing both result and error fields\n      });\n\n      expect(() =&gt; parseResponseTest(responseText)).toThrow(\"Invalid response\");\n    });\n\n    it(\"throws for error responses\", async () =&gt; {\n      const responseText = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32000,\n          message: \"Error message\",\n        },\n      });\n\n      expect(() =&gt; parseResponseTest(responseText)).toThrow(SystemError);\n\n      try {\n        parseResponseTest(responseText);\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect((error as SystemError).code).toBe(-32000);\n        expect((error as SystemError).message).toBe(\"Error message\");\n      }\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/rpc-client.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest rpc-client.test.ts</code></li> </ol>"},{"location":"sdk/tests/rpc-client.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/server-error-handling.test.html","title":"server-error-handling.test","text":"<p>Tests for server error handling.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/server-error-handling.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2AServer Error Handling</li> <li>Task Handler Errors</li> <li>Invalid JSON-RPC Request Handling</li> <li>Content Type Handling</li> </ul>"},{"location":"sdk/tests/server-error-handling.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  TaskContext,\n  TaskYieldUpdate,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Define an error-prone task handler for testing\nasync function* errorProneTaskHandler(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, void, unknown&gt; {\n  const text = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // If the message contains \"throw\", we'll simulate an error\n  if (text.includes(\"throw\")) {\n    throw new Error(\"Simulated task error\");\n  }\n\n  // If the message contains \"fail\", we'll yield a failed state\n  if (text.includes(\"fail\")) {\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task failed intentionally.\" }],\n      },\n    };\n    return;\n  }\n\n  // Otherwise, normal processing\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Working...\" }],\n    },\n  };\n\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Task completed successfully.\" }],\n    },\n  };\n}\n\ndescribe(\"A2AServer Error Handling\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    server = new A2AServer({\n      handler: errorProneTaskHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Task Handler Errors\", () =&gt; {\n    it(\"handles exceptions thrown by task handler\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"error-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"error-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This will throw an error\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      // The server should handle the error and return a failed task\n      expect(response.status).toBe(200);\n      // When the task handler throws, the server should return an error in the response\n      // or a task with failed state\n      if (response.body.result) {\n        expect(response.body.result.id).toBe(\"error-task-1\");\n        expect(response.body.result.status.state).toBe(\"failed\");\n      } else if (response.body.error) {\n        // Or it might return an internal error\n        expect(response.body.error).toBeDefined();\n        expect(response.body.error.code).toBe(-32603); // Internal error\n        expect(response.body.error.message).toBe(\"Internal error\");\n      }\n    });\n\n    it(\"correctly handles task failed state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"fail-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"fail-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This will fail\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"fail-task-1\");\n      expect(response.body.result.status.state).toBe(\"failed\");\n      expect(response.body.result.status.message).toBeDefined();\n      expect(response.body.result.status.message.parts[0].text).toBe(\n        \"Task failed intentionally.\"\n      );\n    });\n  });\n\n  describe(\"Invalid JSON-RPC Request Handling\", () =&gt; {\n    it.skip(\"handles invalid JSON in request body\", async () =&gt; {\n      const response = await trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Content-Type\", \"application/json\")\n          .send(\"this is not valid json\")\n      );\n\n      // The server might return either a 400 Bad Request or 200 with JSON-RPC error\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32700); // JSON parse error\n      expect(response.body.error.message).toBe(\"Invalid JSON payload\");\n    });\n\n    it(\"returns error for empty request body\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).post(\"/\").set(\"Content-Type\", \"application/json\").send(\"\")\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      // Should be parse error or invalid request\n      expect([-32700, -32600].includes(response.body.error.code)).toBe(true);\n    });\n\n    it.skip(\"returns error when request body is not an object\", async () =&gt; {\n      const response = await trackRequest(request(app).post(\"/\").send(\"42\"));\n\n      // The server might return various status codes for invalid content types\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect([-32700, -32600].includes(response.body.error.code)).toBe(true);\n    });\n  });\n\n  describe(\"Content Type Handling\", () =&gt; {\n    it(\"accepts JSON-RPC requests with application/json content type\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"content-type-test\",\n        method: \"tasks/send\",\n        params: {\n          id: \"content-type-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Testing content type\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Content-Type\", \"application/json\")\n          .send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"content-type-task-1\");\n    });\n\n    it(\"accepts JSON-RPC requests with application/json; charset=utf-8\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"charset-test\",\n        method: \"tasks/send\",\n        params: {\n          id: \"charset-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Testing charset\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Content-Type\", \"application/json; charset=utf-8\")\n          .send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"charset-task-1\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/server-error-handling.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest server-error-handling.test.ts</code></li> </ol>"},{"location":"sdk/tests/server-error-handling.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/server-impl.test.html","title":"server-impl.test","text":"<p>Tests for server impl.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/server-impl.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Server Implementation Tests</li> <li>Server Configuration</li> <li>Error Handling</li> <li>Task History Management</li> <li>Task Timestamps</li> </ul>"},{"location":"sdk/tests/server-impl.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  TaskContext,\n  TaskYieldUpdate,\n  INTERNAL_ERROR,\n  AgentCard,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Create a specialized task handler for more coverage testing\nasync function* serverImplTestHandler(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, void, unknown&gt; {\n  const text = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Need to specifically test error conditions\n  if (text.includes(\"throw-internal\")) {\n    throw INTERNAL_ERROR(new Error(\"Internal test error\"));\n  }\n\n  // Test for different state transitions in detail\n  if (text.includes(\"streaming\")) {\n    yield {\n      state: \"submitted\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task submitted...\" }],\n      },\n    };\n\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Working...\" }],\n      },\n    };\n\n    // Simulate a few more updates\n    for (let i = 1; i &lt;= 3; i++) {\n      yield {\n        state: \"working\",\n        message: {\n          role: \"agent\",\n          parts: [{ type: \"text\", text: `Still working (${i}/3)...` }],\n        },\n      };\n\n      // Small delay to simulate processing\n      await new Promise((resolve) =&gt; setTimeout(resolve, 50));\n    }\n\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task completed successfully!\" }],\n      },\n    };\n    return;\n  }\n\n  // Default case\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Working on it...\" }],\n    },\n  };\n\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Completed!\" }],\n    },\n  };\n}\n\ndescribe(\"Server Implementation Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    // Create a server with a custom agent card to test that code path\n    const customCard: AgentCard = {\n      name: \"Server Impl Test Agent\",\n      url: \"http://localhost:41241\",\n      version: \"1.0.0\",\n      capabilities: {\n        streaming: true,\n        pushNotifications: true,\n        stateTransitionHistory: true,\n      },\n      skills: [\n        {\n          id: \"test-skill\",\n          name: \"Test Skill\",\n        },\n      ],\n    };\n\n    server = new A2AServer({\n      handler: serverImplTestHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n      card: customCard,\n      // Use custom CORS options to test that code path\n      corsOptions: {\n        origin: [\"http://localhost:3000\"],\n        methods: [\"GET\", \"POST\", \"OPTIONS\"],\n        allowedHeaders: [\"Content-Type\", \"Authorization\"],\n      },\n      // Use custom base path to test that code path\n      basePath: \"/api\",\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Server Configuration\", () =&gt; {\n    it(\"uses custom base path\", async () =&gt; {\n      // Test that the API endpoint is available at the custom path\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"test-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"test-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Basic test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app)\n          .post(\"/api\") // Using custom path\n          .send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"test-task-1\");\n    });\n\n    it(\"uses custom agent card\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).get(\"/.well-known/agent.json\")\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.name).toBe(\"Server Impl Test Agent\");\n      expect(response.body.skills[0].id).toBe(\"test-skill\");\n    });\n\n    it(\"properly applies CORS settings\", async () =&gt; {\n      const response = await trackRequest(\n        request(app)\n          .options(\"/api\")\n          .set(\"Origin\", \"http://localhost:3000\")\n          .set(\"Access-Control-Request-Method\", \"POST\")\n      );\n\n      expect(response.status).toBe(204);\n      expect(response.header[\"access-control-allow-origin\"]).toBe(\n        \"http://localhost:3000\"\n      );\n      expect(response.header[\"access-control-allow-methods\"]).toContain(\"GET\");\n      expect(response.header[\"access-control-allow-methods\"]).toContain(\"POST\");\n    });\n  });\n\n  describe(\"Error Handling\", () =&gt; {\n    it(\"handles SystemError thrown by task handler\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"internal-error-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"internal-error-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"This will throw-internal error\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32603);\n      expect(response.body.error.message).toBe(\"Internal error\");\n    });\n\n    it(\"returns TASK_NOT_FOUND error for non-existent task\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\"); //todo not returning error message\n    });\n\n    it(\"returns METHOD_NOT_FOUND error for invalid method\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-method-request-1\",\n        method: \"invalid/method\",\n        params: {\n          id: \"invalid-method-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32601);\n      expect(response.body.error.message).toBe(\"Method not found\");\n    });\n\n    it(\"returns INVALID_PARAMS error for missing params\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-params-request-1\",\n        method: \"tasks/send\",\n        // Missing params\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n\n    it(\"returns INVALID_PARAMS error for invalid task ID\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-task-id-request-1\",\n        method: \"tasks/get\",\n        params: {\n          // Missing id\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n  });\n\n  describe(\"Task History Management\", () =&gt; {\n    it(\"requests task with history\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"history-create-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"history-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task for history test\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/api\").send(createBody));\n\n      // Now retrieve it with history\n      const retrieveBody = {\n        jsonrpc: \"2.0\",\n        id: \"history-retrieve-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"history-task-1\",\n          historyLength: 2,\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(retrieveBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"history-task-1\");\n      // History might or might not be included depending on implementation\n    });\n\n    it(\"includes session ID when provided\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"session-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"session-task-1\",\n          sessionId: \"test-session-123\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task with session ID\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"session-task-1\");\n      expect(response.body.result.sessionId).toBe(\"test-session-123\");\n    });\n\n    it(\"includes metadata when provided\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"metadata-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"metadata-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task with metadata\" }],\n          },\n          metadata: {\n            testKey: \"testValue\",\n            source: \"unit-test\",\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"metadata-task-1\");\n      // Metadata might be stored but not returned, depending on implementation\n    });\n  });\n\n  describe(\"Task Timestamps\", () =&gt; {\n    it(\"includes timestamps in task status\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"timestamp-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"timestamp-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task for timestamp test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.status.timestamp).toBeDefined();\n\n      // Verify it's a valid ISO date string\n      const timestamp = new Date(response.body.result.status.timestamp);\n      expect(timestamp.toString()).not.toBe(\"Invalid Date\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/server-impl.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest server-impl.test.ts</code></li> </ol>"},{"location":"sdk/tests/server-impl.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/server.test.html","title":"server.test","text":"<p>Tests for server.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/server.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2AServer</li> <li>Agent Card</li> <li>tasks/send</li> <li>tasks/get</li> <li>tasks/cancel</li> <li>Method not found</li> </ul>"},{"location":"sdk/tests/server.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  TaskContext,\n  TaskYieldUpdate,\n  TaskStore,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Define test task handler\nasync function* basicTaskHandler(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, void, unknown&gt; {\n  // Check if task already has status, if not, use \"working\"\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Working on it...\" }],\n    },\n  };\n\n  // Simulate some work\n  await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n\n  // Check for cancellation\n  if (context.isCancelled()) {\n    yield { state: \"canceled\" };\n    return;\n  }\n\n  // Generate a result artifact\n  yield {\n    name: \"result.txt\",\n    parts: [\n      { type: \"text\", text: `Task ${context.task.id} completed successfully.` },\n    ],\n  };\n\n  // Final completion status\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Task completed successfully!\" }],\n    },\n  };\n}\n\ndescribe(\"A2AServer\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let taskStore: TaskStore;\n  // Track any pending requests for cleanup\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    taskStore = new InMemoryTaskStore();\n    server = new A2AServer({\n      handler: basicTaskHandler,\n      taskStore,\n      port: 0, // Don't actually listen\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Agent Card\", () =&gt; {\n    it(\"serves agent card at /.well-known/agent.json\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).get(\"/.well-known/agent.json\")\n      );\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty(\"name\");\n      expect(response.body).toHaveProperty(\"capabilities\");\n    });\n\n    it(\"serves agent card at /agent-card\", async () =&gt; {\n      const response = await trackRequest(request(app).get(\"/agent-card\"));\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty(\"name\");\n      expect(response.body).toHaveProperty(\"capabilities\");\n    });\n  });\n\n  describe(\"tasks/send\", () =&gt; {\n    it(\"handles a valid task send request\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"test-request-1\",\n        method: \"tasks/send\",\n        params: {\n          id: \"test-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Hello, world!\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.jsonrpc).toBe(\"2.0\");\n      expect(response.body.id).toBe(\"test-request-1\");\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"test-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n      expect(response.body.result.artifacts).toHaveLength(1);\n      expect(response.body.result.artifacts[0].name).toBe(\"result.txt\");\n    });\n\n    it(\"returns an error for invalid request format\", async () =&gt; {\n      const invalidRequest = {\n        // Missing required jsonrpc field\n        id: \"invalid-req\",\n        method: \"tasks/send\",\n        params: {\n          id: \"task-id\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(invalidRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32600); // Invalid request error\n      expect(response.body.error.message).toBe(\"Invalid request\"); //todo expected \"Request payload validation error\" but may be caused by the jsonrpc middleware\n    });\n\n    it(\"returns an error for missing task ID\", async () =&gt; {\n      const requestWithoutId = {\n        jsonrpc: \"2.0\",\n        id: \"missing-id-req\",\n        method: \"tasks/send\",\n        params: {\n          // Missing id field\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestWithoutId)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n  });\n\n  describe(\"tasks/get\", () =&gt; {\n    it(\"retrieves a task after it has been created\", async () =&gt; {\n      // First create a task\n      const createRequest = {\n        jsonrpc: \"2.0\",\n        id: \"create-req\",\n        method: \"tasks/send\",\n        params: {\n          id: \"retrieve-task\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task to retrieve\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createRequest));\n\n      // Now try to retrieve it\n      const getRequest = {\n        jsonrpc: \"2.0\",\n        id: \"get-req\",\n        method: \"tasks/get\",\n        params: {\n          id: \"retrieve-task\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(getRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"retrieve-task\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n    });\n\n    it(\"returns an error for non-existent task\", async () =&gt; {\n      const getRequest = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-req\",\n        method: \"tasks/get\",\n        params: {\n          id: \"nonexistent-task\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(getRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n  });\n\n  describe(\"tasks/cancel\", () =&gt; {\n    it(\"successfully cancels a task\", async () =&gt; {\n      // First create a task\n      const createRequest = {\n        jsonrpc: \"2.0\",\n        id: \"create-cancel-req\",\n        method: \"tasks/send\",\n        params: {\n          id: \"cancel-task\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task to cancel\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createRequest));\n\n      // Now try to cancel it (note: the task may complete before cancellation in this test)\n      const cancelRequest = {\n        jsonrpc: \"2.0\",\n        id: \"cancel-req\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"cancel-task\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelRequest)\n      );\n\n      // It's possible the task completes before we can cancel it,\n      // in which case we'll get a \"task not cancelable\" error,\n      // but that's also a valid test result\n      if (response.body.error) {\n        expect(response.body.error.code).toBe(-32002);\n        expect(response.body.error.message).toBe(\"Task cannot be canceled\");\n      } else {\n        expect(response.status).toBe(200);\n        expect(response.body.result).toBeDefined();\n        expect(response.body.result.id).toBe(\"cancel-task\");\n        expect(response.body.result.status.state).toBe(\"canceled\");\n      }\n    });\n  });\n\n  describe(\"Method not found\", () =&gt; {\n    it(\"returns a method not found error for unknown methods\", async () =&gt; {\n      const unknownMethodRequest = {\n        jsonrpc: \"2.0\",\n        id: \"unknown-method-req\",\n        method: \"unknown/method\",\n        params: {},\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(unknownMethodRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32601);\n      expect(response.body.error.message).toBe(\"Method not found\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/server.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest server.test.ts</code></li> </ol>"},{"location":"sdk/tests/server.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/streaming.test.html","title":"streaming.test","text":"<p>Tests for streaming.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/streaming.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Streaming API Tests</li> <li>tasks/sendSubscribe</li> <li>tasks/resubscribe</li> </ul>"},{"location":"sdk/tests/streaming.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  TaskContext,\n  TaskYieldUpdate,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Specialized task handler for streaming tests\nasync function* streamingTestHandler(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, void, unknown&gt; {\n  const text = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Quick completion without streaming for non-streaming tests\n  if (text.includes(\"quick\")) {\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Quick completion\" }],\n      },\n    };\n    return;\n  }\n\n  // Test for resubscription\n  if (text.includes(\"resubscribe\")) {\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [\n          { type: \"text\", text: \"Starting work for resubscribe test...\" },\n        ],\n      },\n    };\n\n    // Add a small delay to allow for resubscription test\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Completed task for resubscribe test\" }],\n      },\n    };\n    return;\n  }\n\n  // Long running task with multiple updates\n  yield {\n    state: \"submitted\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Task submitted\" }],\n    },\n  };\n\n  // Progress updates\n  for (let i = 1; i &lt;= 3; i++) {\n    yield {\n      state: \"working\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: `Progress update ${i}/3` }],\n      },\n    };\n\n    // Small delay to simulate processing\n    await new Promise((resolve) =&gt; setTimeout(resolve, 50));\n  }\n\n  // Final completion\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Task completed successfully\" }],\n    },\n  };\n}\n\ndescribe(\"Streaming API Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    server = new A2AServer({\n      handler: streamingTestHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n      card: {\n        name: \"Streaming Test Agent\",\n        url: \"http://localhost:41241\",\n        version: \"1.0.0\",\n        capabilities: {\n          streaming: true,\n          pushNotifications: false,\n          stateTransitionHistory: true,\n        },\n        skills: [\n          {\n            id: \"streaming-test\",\n            name: \"Streaming Test Skill\",\n          },\n        ],\n      },\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Clear the pending requests array - we don't need to re-execute them\n    pendingRequests = [];\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 250));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  // Helper to collect streamed events\n  const collectStreamEvents = async (\n    req: request.Test,\n    timeout = 2000\n  ): Promise&lt;string[]&gt; =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      const events: string[] = [];\n      let responseEnded = false;\n      const timeoutId = setTimeout(() =&gt; {\n        if (!responseEnded) {\n          responseEnded = true;\n          resolve(events);\n        }\n      }, timeout);\n\n      req\n        .buffer(false)\n        .parse((res, callback) =&gt; {\n          res.setEncoding(\"utf8\");\n          let data = \"\";\n          res.on(\"data\", (chunk: string) =&gt; {\n            data += chunk;\n            // Server-Sent Events are separated by double newlines\n            const parts = data.split(\"\\n\\n\");\n            if (parts.length &gt; 1) {\n              data = parts.pop() || \"\";\n              for (const part of parts) {\n                if (part.trim()) {\n                  events.push(part);\n                }\n              }\n            }\n          });\n          res.on(\"end\", () =&gt; {\n            clearTimeout(timeoutId);\n            if (!responseEnded) {\n              responseEnded = true;\n              resolve(events);\n            }\n          });\n          res.on(\"error\", (err) =&gt; {\n            clearTimeout(timeoutId);\n            if (!responseEnded) {\n              responseEnded = true;\n              reject(err);\n            }\n          });\n          callback(null, res);\n        })\n        .end((err) =&gt; {\n          if (err &amp;&amp; !responseEnded) {\n            responseEnded = true;\n            reject(err);\n          }\n        });\n    });\n  };\n\n  describe(\"tasks/sendSubscribe\", () =&gt; {\n    it(\"establishes a stream and sends events until completion\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"stream-request-1\",\n        method: \"tasks/sendSubscribe\",\n        params: {\n          id: \"stream-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Test streaming updates\" }],\n          },\n        },\n      };\n\n      const req = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(requestBody)\n      );\n\n      const events = await collectStreamEvents(req);\n\n      // Check for all expected events\n      expect(events.length).toBeGreaterThanOrEqual(5); // submitted + 3 working + completed\n\n      // Verify events contain correct data\n      let foundSubmitted = false;\n      let workingCount = 0;\n      let foundCompleted = false;\n      let foundFinal = false;\n\n      for (const event of events) {\n        const lines = event.split(\"\\n\");\n        const dataLine = lines.find((line) =&gt; line.startsWith(\"data:\"));\n\n        if (dataLine) {\n          const data = JSON.parse(dataLine.substring(5).trim());\n\n          if (data.result?.status?.state === \"submitted\") {\n            foundSubmitted = true;\n          } else if (data.result?.status?.state === \"working\") {\n            workingCount++;\n          } else if (data.result?.status?.state === \"completed\") {\n            foundCompleted = true;\n          }\n\n          if (data.result?.final === true) {\n            foundFinal = true;\n          }\n        }\n      }\n\n      expect(foundSubmitted).toBe(true);\n      expect(workingCount).toBeGreaterThanOrEqual(3);\n      expect(foundCompleted).toBe(true);\n      expect(foundFinal).toBe(true);\n    });\n\n    it(\"returns error if task ID is missing\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-stream-1\",\n        method: \"tasks/sendSubscribe\",\n        params: {\n          // Missing id\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Missing task ID\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n      // Invalid params\n    });\n  });\n\n  describe(\"tasks/resubscribe\", () =&gt; {\n    it(\"allows resubscribing to an existing task stream\", async () =&gt; {\n      // First create a streaming task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"resubscribe-request-1\",\n        method: \"tasks/sendSubscribe\",\n        params: {\n          id: \"resubscribe-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Test for resubscribe\" }],\n          },\n        },\n      };\n\n      const req1 = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(createBody)\n      );\n\n      // Start collecting events from first request\n      const initialEventsPromise = collectStreamEvents(req1, 500);\n\n      // Wait a bit to ensure the task is started\n      await new Promise((resolve) =&gt; setTimeout(resolve, 200));\n\n      // Now resubscribe to the same task\n      const resubscribeBody = {\n        jsonrpc: \"2.0\",\n        id: \"resubscribe-stream-2\",\n        method: \"tasks/resubscribe\",\n        params: {\n          id: \"resubscribe-task-1\",\n        },\n      };\n\n      const req2 = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(resubscribeBody)\n      );\n\n      // Collect events from the resubscription request\n      const resubscribeEvents = await collectStreamEvents(req2);\n\n      // Wait for the initial events to complete\n      const initialEvents = await initialEventsPromise;\n\n      // Verify we received events from resubscription\n      expect(resubscribeEvents.length).toBeGreaterThan(0);\n\n      // Check for task completion event in at least one of the streams\n      const allEvents = [...initialEvents, ...resubscribeEvents];\n      let foundCompleted = false;\n\n      for (const event of allEvents) {\n        const lines = event.split(\"\\n\");\n        const dataLine = lines.find((line) =&gt; line.startsWith(\"data:\"));\n\n        if (dataLine) {\n          const data = JSON.parse(dataLine.substring(5).trim());\n          if (data.result?.status?.state === \"completed\") {\n            foundCompleted = true;\n            break;\n          }\n        }\n      }\n\n      expect(foundCompleted).toBe(true);\n    });\n\n    it(\"returns error when resubscribing to non-existent task\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-resubscribe-1\",\n        method: \"tasks/resubscribe\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n  });\n\n  describe.skip(\"Stream Management\", () =&gt; {\n    it(\"removes stream on connection close\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"close-stream-request-1\",\n        method: \"tasks/sendSubscribe\",\n        params: {\n          id: \"close-stream-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Test stream connection close\" }],\n          },\n        },\n      };\n\n      const req = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(requestBody)\n      );\n\n      // Get a few events\n      let eventsReceived = 0;\n      const timeoutPromise = new Promise&lt;void&gt;((resolve) =&gt;\n        setTimeout(resolve, 500)\n      );\n      const initialActiveStreams = server.getActiveStreams();\n      const initialTaskStreams = initialActiveStreams.get(\n        \"close-stream-task-1\"\n      );\n      console.log(\"Initial active streams\", initialActiveStreams);\n      console.log(\"Initial task streams\", initialTaskStreams);\n      expect(initialTaskStreams).toBeDefined();\n\n      req.buffer(false).parse((res, callback) =&gt; {\n        res.setEncoding(\"utf8\");\n        res.on(\"data\", () =&gt; {\n          eventsReceived++;\n          if (eventsReceived &gt;= 2) {\n            // Simulate client disconnection by destroying the response\n            (res as any).destroy();\n          }\n        });\n        callback(null, res);\n      });\n\n      await timeoutPromise;\n\n      // Explicitly abort the supertest request after destroying the response\n      req.abort();\n\n      // Get the number of active streams for this task\n      const activeStreams = server.getActiveStreams();\n      const taskStreams = activeStreams.get(\"close-stream-task-1\");\n\n      // The stream should have been removed after disconnection\n      expect(taskStreams).toBeUndefined();\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/streaming.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest streaming.test.ts</code></li> </ol>"},{"location":"sdk/tests/streaming.test.html#coverage","title":"Coverage","text":""}]}