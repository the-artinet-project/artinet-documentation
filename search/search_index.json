{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Artinet Documentation","text":"<p>Welcome to Artinet, the comprehensive platform for creating, testing, and deploying intelligent agents that work together to solve complex problems. Whether you're building simple conversational agents or orchestrating complex multi-agent workflows, Artinet provides the tools and framework you need.</p>"},{"location":"index.html#getting-started-with-agent-creation","title":"Getting Started with Agent Creation","text":"<p>Artinet's Hero Types system makes agent creation accessible to everyone, from business users to technical developers. Instead of writing complex code, you can create powerful agents by selecting from three specialized types optimized for different roles.</p>"},{"location":"index.html#hero-types-the-foundation-of-agent-creation","title":"\ud83c\udfad Hero Types: The Foundation of Agent Creation","text":"<p>Director Agents - Orchestrate and manage other agents - Coordinate complex multi-agent workflows - Make strategic decisions and delegate tasks - Perfect for project management and business process automation</p> <p>Worker Agents - Execute specialized tasks with tool access - Connect to external systems and APIs via MCP tools - Handle data processing, analysis, and system integrations - Ideal for technical operations and specialized computations</p> <p>Speaker Agents - Excel at communication and content creation - Natural language processing and conversation management - Content creation and user interaction - Perfect for customer service, writing, and user interfaces</p>"},{"location":"index.html#quick-start-guide","title":"Quick Start Guide","text":"<ol> <li>Create Your First Agent - Learn the Hero Types system and create agents optimized for specific roles</li> <li>Test and Deploy - Thoroughly test your agents and deploy them to production</li> <li>Build Workflows - Use the visual Grid interface to connect agents in powerful workflows</li> <li>Secure Access - Generate and manage API keys for secure agent interactions</li> </ol>"},{"location":"index.html#why-choose-artinets-hero-types","title":"Why Choose Artinet's Hero Types?","text":"<p>\u2705 No Coding Required: Create sophisticated agents using our intuitive interface and Hero Type templates</p> <p>\u2705 Optimized Performance: Each Hero Type is optimized for its specific role and use case</p> <p>\u2705 Better Collaboration: Agents understand each other's capabilities through standardized Hero Types</p> <p>\u2705 Scalable Architecture: Easily build from simple single-agent solutions to complex multi-agent ecosystems</p> <p>\u2705 Rapid Development: Go from concept to deployed agent in minutes, not days</p>"},{"location":"index.html#featured-workflows","title":"Featured Workflows","text":""},{"location":"index.html#business-process-automation","title":"Business Process Automation","text":"<p>Use a Director to coordinate: - Worker agents for data processing and system integration - Speaker agents for customer communication and notifications - Complete automation of complex business workflows</p>"},{"location":"index.html#content-production-pipeline","title":"Content Production Pipeline","text":"<p>Create sophisticated content workflows: - Director manages editorial calendar and assigns tasks - Worker agents research and gather data from various sources - Speaker agents create, edit, and publish content across channels</p>"},{"location":"index.html#customer-service-excellence","title":"Customer Service Excellence","text":"<p>Build comprehensive customer support: - Speaker agents handle initial customer interactions - Worker agents access customer data and process requests - Director escalates and coordinates complex issue resolution</p>"},{"location":"index.html#advanced-development","title":"Advanced Development","text":"<p>For developers who need complete control over agent behavior and want to build custom solutions from the ground up, Artinet provides a comprehensive SDK.</p>"},{"location":"index.html#custom-agent-development-advanced","title":"\ud83d\udd27 Custom Agent Development (Advanced)","text":"<p>The Artinet SDK is designed for advanced or custom agent creation scenarios where the Hero Types system doesn't fully meet your specific requirements. While Hero Types are recommended for most use cases, the SDK provides:</p> <p>Complete Customization: Build agents with exact specifications for unique requirements</p> <p>Low-Level Control: Direct access to the Agent2Agent protocol and communication layers</p> <p>Custom Integrations: Create specialized integrations beyond standard MCP tools</p> <p>Research and Experimentation: Prototype new agent behaviors and interaction patterns</p> <p>\ud83d\udca1 Recommendation: Most users should start with Hero Types, as they're likely to be better supported and more compatible with the broader Artinet ecosystem. Consider the SDK only when Hero Types cannot meet your specific requirements.</p> <p>Explore Advanced SDK Development \u2192</p>"},{"location":"index.html#platform-features","title":"Platform Features","text":""},{"location":"index.html#visual-grid-interface","title":"Visual Grid Interface","text":"<ul> <li>Drag-and-Drop Workflows: Create complex multi-agent systems visually</li> <li>Real-Time Testing: Test individual agents and complete workflows</li> <li>Save and Share: Store workflow templates and share with team members</li> </ul>"},{"location":"index.html#comprehensive-testing","title":"Comprehensive Testing","text":"<ul> <li>Sandbox Environment: Safe testing environment for all agent types</li> <li>End-to-End Validation: Test complete workflows before deployment</li> <li>Performance Monitoring: Track agent performance and optimize accordingly</li> </ul>"},{"location":"index.html#security-and-management","title":"Security and Management","text":"<ul> <li>API Key Management: Fine-grained access control and security</li> <li>Usage Analytics: Monitor agent performance and resource consumption</li> <li>Team Collaboration: Share agents and workflows across your organization</li> </ul>"},{"location":"index.html#integration-ecosystem","title":"Integration Ecosystem","text":"<ul> <li>MCP Tools: Extensive library of tools for Worker agents</li> <li>External APIs: Connect to any REST API or webhook</li> <li>Database Access: Direct integration with popular databases</li> <li>Cloud Services: Native integration with major cloud providers</li> </ul>"},{"location":"index.html#community-and-support","title":"Community and Support","text":""},{"location":"index.html#learning-resources","title":"Learning Resources","text":"<ul> <li>Hero Types Deep Dive - Comprehensive guide to all three Hero Types</li> <li>Best Practices - Learn from successful agent implementations</li> <li>Example Workflows - Ready-to-use workflow templates</li> </ul>"},{"location":"index.html#getting-help","title":"Getting Help","text":"<ul> <li>Documentation Search: Find answers in our comprehensive documentation</li> <li>Community Forums: Connect with other Artinet developers and users</li> <li>Support Channels: Get help from our technical support team</li> <li>Video Tutorials: Step-by-step video guides for common tasks</li> </ul>"},{"location":"index.html#architecture-overview","title":"Architecture Overview","text":"<p>Artinet is built on the Agent2Agent (A2A) protocol, enabling secure, efficient communication between agents regardless of their implementation or location. This architecture provides:</p> <ul> <li>Decentralized Operation: Agents can run anywhere while maintaining coordination</li> <li>Secure Communication: Built-in authentication and encryption</li> <li>Scalable Infrastructure: From single agents to thousands of coordinated agents</li> <li>Standard Protocols: Open standards enable interoperability and extensibility</li> </ul>"},{"location":"index.html#ready-to-begin","title":"Ready to Begin?","text":""},{"location":"index.html#for-business-users-and-content-creators","title":"For Business Users and Content Creators","text":"<p>Start with Agent Creation to learn about Hero Types and create your first agents using our intuitive interface.</p>"},{"location":"index.html#for-developers-and-technical-users","title":"For Developers and Technical Users","text":"<p>Begin with Hero Types Overview to understand the three agent types, then proceed to Grid Management for workflow creation.</p>"},{"location":"index.html#for-advanced-developers","title":"For Advanced Developers","text":"<p>Explore SDK Development for complete customization and advanced agent development scenarios.</p> <p>\ud83d\ude80 Start Building: The future of work is collaborative intelligence between humans and agents. Artinet makes that future accessible today, whether you're automating simple tasks or building sophisticated multi-agent systems.</p> <p>Ready to create your first agent? Get started with Hero Types \u2192</p>"},{"location":"versions.html","title":"Version History","text":"<p>This page documents the version history of the Artinet SDK, highlighting breaking changes and important updates that may affect your integration.</p>"},{"location":"versions.html#migration-guides","title":"Migration Guides","text":""},{"location":"versions.html#05x-to-054-migration","title":"0.5.x to 0.5.4 Migration","text":"<p>If you're upgrading to 0.5.4, be aware of the following breaking changes:</p> <ol> <li>Method Name Changes: Core methods have been renamed to align with message-based approach:</li> <li><code>sendTask</code> \u2192 <code>sendMessage</code></li> <li><code>sendTaskSubscribe</code> \u2192 <code>sendStreamingMessage</code></li> <li> <p>Update push notification config methods to <code>tasks/pushNotificationConfig/set</code> and <code>tasks/pushNotificationConfig/get</code></p> </li> <li> <p>Schema Import Paths: Import paths have been refactored to use new schema structure under <code>schemas/a2a</code></p> </li> <li> <p>Deprecated Submodules: The <code>a2a-samples</code> and <code>mcp-use</code> submodules have been removed</p> </li> </ol>"},{"location":"versions.html#03x-to-050-migration","title":"0.3.x to 0.5.0 Migration","text":"<p>If you're upgrading from 0.3.x to 0.5.0, be aware of the following breaking changes:</p> <ol> <li> <p>SystemError Constructor: The <code>data</code> parameter in the <code>SystemError</code> constructor and all specific error factory functions (e.g., <code>PARSE_ERROR()</code>, <code>INVALID_PARAMS()</code>, <code>TASK_NOT_FOUND()</code>) is now mandatory.</p> </li> <li> <p>Express Server Refactoring: The <code>createExpressServer</code> utility has been refactored:</p> </li> <li>No longer accepts a <code>port</code> parameter.</li> <li>No longer creates or returns an <code>http.Server</code> instance.</li> <li> <p>Server starting is now handled within <code>A2AServer.start()</code> only.</p> </li> <li> <p>Type Definition Changes: Optional properties are now defined using <code>type?</code> instead of <code>type | null</code>.</p> </li> <li> <p>Task Status Initialization: When a task is initiated, the initial task status no longer includes a <code>message: null</code> field.</p> </li> <li> <p>Error Messaging: Generic <code>METHOD_NOT_FOUND()</code> errors have been replaced with more specific <code>PUSH_NOTIFICATION_NOT_SUPPORTED()</code> errors.</p> </li> </ol>"},{"location":"versions.html#detailed-version-history","title":"Detailed Version History","text":""},{"location":"versions.html#changelog","title":"Changelog","text":"<p>All notable changes to the @artinet/sdk package will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"versions.html#054-2025-06-12","title":"[0.5.4] - 2025-06-12","text":""},{"location":"versions.html#added","title":"Added","text":"<ul> <li>New <code>ExecutionContext</code> interface for enhanced parameter management across services</li> <li><code>MCPExecutionContext</code> and <code>NLWebExecutionContext</code> interfaces for protocol-specific request handling</li> <li>New schema organization under <code>schemas/a2a</code> directory for improved code structure</li> </ul>"},{"location":"versions.html#changed","title":"Changed","text":"<ul> <li>BREAKING: Renamed core methods to align with message-based approach:</li> <li><code>sendTask</code> \u2192 <code>sendMessage</code></li> <li><code>sendTaskSubscribe</code> \u2192 <code>sendStreamingMessage</code></li> <li>Updated push notification config methods to <code>tasks/pushNotificationConfig/set</code> and <code>tasks/pushNotificationConfig/get</code></li> <li>Refactored import paths to use new schema structure under <code>schemas/a2a</code></li> <li>Enhanced error handling and validation for message parameters across the codebase</li> <li>Updated documentation to reflect new method names and functionalities</li> </ul>"},{"location":"versions.html#removed","title":"Removed","text":"<ul> <li>Deprecated submodules for <code>a2a-samples</code> and <code>mcp-use</code></li> </ul>"},{"location":"versions.html#052-2025-05-25","title":"[0.5.2] - 2025-05-25","text":""},{"location":"versions.html#added_1","title":"Added","text":"<ul> <li>New <code>artinet.v0</code> namespace in <code>src/utils/deployment/agents.ts</code> providing <code>taskManager</code>, <code>connect</code>, and <code>agent</code> utilities. These are designed for agents running in sandboxed or managed environments, offering a standardized way to interact with the host system for task execution, inter-agent communication, and external API calls.</li> <li>Corresponding types for the new agent utilities in <code>src/types/proxy.ts</code>: <code>TaskProxy</code>, <code>TaskManagerProps</code>, <code>TaskManager</code>, <code>ConnectProps</code>, <code>ConnectAPICallback</code>, <code>ClientProxy</code>, <code>ClientProps</code>, <code>ClientFactory</code>.</li> <li>New <code>exports</code> path <code>./agents</code> in <code>package.json</code> to expose the <code>artinet.v0</code> utilities.</li> <li>New example file <code>examples/nested-deployment.ts</code> demonstrating how to use <code>artinet.v0.agent</code> for an agent to call another agent, and <code>artinet.v0.taskManager</code> for managing the agent's lifecycle.</li> <li>New <code>dev-pack</code> script in <code>package.json</code> for easier local development and packaging.</li> </ul>"},{"location":"versions.html#changed_1","title":"Changed","text":"<ul> <li>Refactoring:<ul> <li><code>src/client/interfaces/client.ts</code> has been moved to <code>src/types/client.ts</code>.</li> <li><code>src/server/interfaces/context.ts</code> has been moved to <code>src/types/context.ts</code>.</li> <li>Internal type imports throughout the codebase have been updated to reflect these changes.</li> </ul> </li> <li>Examples <code>examples/code-deployment.js</code> and <code>examples/code-deployment.ts</code> have been updated to use the new <code>artinet.v0.taskManager</code> and <code>artinet.v0.connect</code> utilities instead of the deprecated proxy functions.</li> <li>Updated <code>@types/node</code> dependency to <code>^20.17.50</code>.</li> </ul>"},{"location":"versions.html#deprecated","title":"Deprecated","text":"<ul> <li>The <code>taskHandlerProxy</code> and <code>fetchResponseProxy</code> functions in <code>src/utils/deployment/task-wrapper.ts</code> are now deprecated. Developers should migrate to the new <code>artinet.v0.taskManager</code> and <code>artinet.v0.connect</code> utilities respectively.</li> </ul>"},{"location":"versions.html#removed_1","title":"Removed","text":"<ul> <li>Removed <code>json-schema-to-typescript</code> from <code>devDependencies</code> as it's no longer directly used.</li> </ul>"},{"location":"versions.html#fixed","title":"Fixed","text":"<ul> <li>Minor wording update in the \"QUICK-AGENT FAQs\" section of <code>README.md</code> for clarity on searching by <code>registrationId/agentId</code>.</li> </ul>"},{"location":"versions.html#051-2025-05-12","title":"[0.5.1] - 2025-05-12","text":""},{"location":"versions.html#added_2","title":"Added","text":"<ul> <li><code>fullDeployment</code> utility (<code>src/utils/deployment/full-deployment.ts</code>): Enables direct deployment of bundled agent code and its <code>AgentCard</code> to the Artinet platform. Requires an <code>ARTINET_API_KEY</code>.</li> <li>New comprehensive test suite for deployment features (<code>tests/deployment.test.ts</code>), covering <code>testDeployment</code> and <code>fullDeployment</code>.</li> <li>Agents registered via <code>A2AServer.registerServer()</code> or <code>register: true</code> now include <code>tags: [\"a2a\"]</code> in their registration payload.</li> </ul>"},{"location":"versions.html#changed_2","title":"Changed","text":"<ul> <li>The <code>handler</code> property in <code>A2AServerParams</code> (used to pass the agent's core logic) was previously documented and used in some examples as <code>taskHandler</code>. This has been corrected to <code>handler</code> consistently. While <code>taskHandler</code> might have worked due to object flexibility, <code>handler</code> is the intended property name.</li> <li>Clarified type description for <code>ServerDeploymentRequestParams.dependencies</code> to note it is \"currently unsupported\".</li> <li>Clarified type description for <code>BaseServerDeploymentResponseParams.deploymentId</code> regarding its value in full deployments.</li> </ul>"},{"location":"versions.html#fixed_1","title":"Fixed","text":"<ul> <li>Improved error handling in <code>A2AClient</code> during <code>agentCard()</code> fetching:<ul> <li>Validates parsed URLs before use.</li> <li>Ensures <code>AgentCard</code> objects contain a <code>name</code> property.</li> </ul> </li> <li>Enhanced error logging in <code>src/transport/rpc/parser.ts</code> to include <code>error.message</code> for <code>SystemError</code> instances.</li> <li>Prevented agent registration via <code>register()</code> utility if the <code>AgentCard.url</code> is localhost, 127.0.0.1, or empty, returning an empty string instead of attempting registration.</li> <li>Corrected an issue in an example in <code>README.md</code> where <code>taskHandler</code> was used instead of <code>handler</code> for the <code>A2AServer</code> constructor (matches the breaking change clarification above).</li> <li>Minor stability improvement in <code>testDeployment</code> utility's event handling logic.</li> </ul>"},{"location":"versions.html#050-2025-05-10","title":"[0.5.0] - 2025-05-10","text":""},{"location":"versions.html#added_3","title":"Added","text":"<ul> <li><code>A2AServer.getExpressApp()</code>: New method to access the underlying Express application instance, allowing for more flexible server customization and middleware integration.</li> <li>More specific error messages for various RPC errors (e.g., <code>TASK_NOT_FOUND</code>, <code>INVALID_PARAMS</code>, <code>PARSE_ERROR</code>), providing better debugging information and context.</li> </ul>"},{"location":"versions.html#changed_3","title":"Changed","text":"<ul> <li>BREAKING: The <code>data</code> parameter in the <code>SystemError</code> constructor and all specific error factory functions (e.g., <code>PARSE_ERROR()</code>, <code>INVALID_PARAMS()</code>, <code>TASK_NOT_FOUND()</code>) is now mandatory. This change aims to enhance error reporting by ensuring contextual information is always provided with errors.</li> <li>BREAKING: Refactored the <code>createExpressServer</code> utility (<code>src/server/lib/express-server.ts</code>):<ul> <li>It no longer accepts a <code>port</code> parameter.</li> <li>It no longer creates or returns an <code>http.Server</code> instance (i.e., it doesn't call <code>app.listen()</code>). It now solely configures and returns the Express <code>app</code> instance.</li> <li>The responsibility of starting the HTTP server is now fully handled within the <code>A2AServer.start()</code> method, which uses the <code>app</code> configured by <code>createExpressServer</code>.</li> </ul> </li> <li>Updated numerous TypeScript type definitions in <code>src/types/schema.ts</code> to more strictly define optional properties. Many properties that were previously <code>type | null</code> are now just <code>type?</code>, and JSDoc <code>@default null</code> comments have been removed. This aligns with standard TypeScript practices where optional properties are either present with a value or absent (undefined), rather than being explicitly <code>null</code>.</li> <li>When a task is initiated via <code>A2AServer.sendTaskAndStore()</code>, the initial task status (<code>Task.status</code>) no longer includes a <code>message: null</code> field.</li> <li>In <code>src/server/lib/state.ts</code>, when creating a new task object during <code>loadState</code>, <code>sessionId</code> and <code>metadata</code> properties are assigned directly if provided, without defaulting to <code>null</code> if they are undefined.</li> <li>Replaced generic <code>METHOD_NOT_FOUND()</code> errors with more specific <code>PUSH_NOTIFICATION_NOT_SUPPORTED()</code> errors in <code>defaultSetTaskPushNotificationMethod</code> and <code>defaultGetTaskPushNotificationMethod</code> when the agent's card indicates that push notifications are not supported.</li> </ul>"},{"location":"versions.html#removed_2","title":"Removed","text":"<ul> <li>The test file <code>tests/deployment.test.ts</code> has been removed. The <code>testDeployment</code> utility and related \"Quick-Agents\" features remain.</li> </ul>"},{"location":"versions.html#improved","title":"Improved","text":"<ul> <li>The documentation section in <code>README.md</code> regarding agent code deployment has been renamed from \"Agent Code Deployment (Beta)\" to \"Quick-Agents (Alpha)\". This section includes updated descriptions, code examples for bundling and testing agents, and a new FAQ.</li> <li>Server startup logging in <code>A2AServer</code> now consistently uses <code>logInfo</code> for messages like \"A2A Server started and listening\".</li> </ul>"},{"location":"versions.html#041-2025-05-08","title":"[0.4.1] - 2025-05-08","text":""},{"location":"versions.html#added_4","title":"Added","text":"<ul> <li>Utility for bundling agent code using <code>esbuild</code> (<code>src/utils/deployment/bundler.ts</code>).</li> <li>Task handler wrapper (<code>taskHandlerProxy</code>) and <code>fetchResponseProxy</code> for streamlined agent deployment logic (<code>src/utils/deployment/task-wrapper.ts</code>, <code>examples/task-wrapper.js</code>).</li> <li>Test deployment functionality (<code>testDeployment</code>) to test agent deployments in a sandboxed environment (<code>src/utils/deployment/test-deployment.ts</code>).</li> <li>New types for server deployment requests and responses (<code>ServerDeploymentRequestParams</code>, <code>ServerDeploymentResponse</code>, etc. in <code>src/types/extended-schema.ts</code>).</li> <li>Comprehensive tests for the new bundler and deployment features (<code>tests/bundler.test.ts</code>, <code>tests/deployment.test.ts</code>).</li> <li>Example agents demonstrating code deployment: <code>examples/code-deployment.js</code> and <code>examples/code-deployment.ts</code>.</li> <li><code>esbuild</code> dependency for bundling.</li> </ul>"},{"location":"versions.html#changed_4","title":"Changed","text":"<ul> <li>BREAKING: Updated <code>rootDir</code> in <code>tsconfig.json</code> to <code>src</code> and <code>declarationDir</code> to <code>./dist/types</code>. This changes the output structure for type declarations.</li> <li>Type declaration paths in <code>package.json</code> updated to <code>dist/types/index.d.ts</code> to reflect <code>tsconfig.json</code> changes.</li> <li>Deprecated <code>JSONRPCSuccessResponse</code>, <code>JSONRPCErrorResponse</code> in <code>src/types/extended-schema.ts</code> in favor of the more general <code>JSONRPCResponse</code>.</li> <li>Enhanced error logging in <code>src/transport/rpc/parser.ts</code> by adding response data to parse errors.</li> </ul>"},{"location":"versions.html#030-2025-04-28","title":"[0.3.0] - 2025-04-28","text":""},{"location":"versions.html#added_5","title":"Added","text":"<ul> <li>Server option <code>register: boolean</code> in <code>A2AServerParams</code> to automatically register the agent with the A2A Registry on startup (default: <code>false</code>).</li> <li><code>A2AServer.registerServer()</code> method to manually trigger agent registration.</li> <li>Server option <code>fallbackPath: string</code> in <code>A2AServerParams</code> to customize the fallback endpoint for serving the Agent Card (defaults to <code>/agent-card</code>). The standard <code>/.well-known/agent.json</code> endpoint remains.</li> <li>Client constructor option <code>fallbackPath: string</code> in <code>A2AClient</code> to specify a custom path when fetching the Agent Card if the standard paths fail.</li> </ul>"},{"location":"versions.html#changed_5","title":"Changed","text":"<ul> <li>BREAKING: Renamed server configuration type from <code>A2AServerOptions</code> to <code>A2AServerParams</code> for consistency.</li> <li>Updated dependencies to latest versions:<ul> <li><code>eventsource-parser</code> to <code>^3.0.1</code>. Adapted streaming logic (<code>handleEventStream</code>) to use <code>EventSourceMessage</code> type from this library.</li> <li><code>express</code> to <code>^5.1.0</code>.</li> <li><code>jayson</code> to <code>^4.2.0</code>.</li> <li><code>node:16</code> to <code>node:22</code></li> <li><code>ES2020</code> to <code>ES2022</code></li> </ul> </li> <li>Updated various code examples in documentation for improved clarity and consistency (<code>README.md</code>, <code>examples/</code>).</li> </ul>"},{"location":"versions.html#improved_1","title":"Improved","text":"<ul> <li>Refactored server JSON-RPC method handling:<ul> <li>Introduced <code>createJSONRPCMethod</code> helper for wrapping A2A method logic with dependency injection and error handling.</li> <li>Exported default implementations for standard A2A methods (e.g., <code>defaultSendTaskMethod</code>) from <code>lib/middleware/a2a-methods.js</code>.</li> <li>Provided <code>defaultCreateJSONRPCServer</code> factory demonstrating standard server setup. This simplifies advanced server customization.</li> </ul> </li> <li>Significantly revised and expanded <code>README.md</code> documentation:<ul> <li>Updated Features, Class Documentation, and Usage sections.</li> <li>Added detailed section on Server Registration &amp; Discovery.</li> <li>Corrected and clarified Advanced Server Customization examples.</li> </ul> </li> <li>Updated test suite to incorporate tests for new server registration and fallback path functionalities.</li> </ul>"},{"location":"versions.html#020-2025-04-25","title":"0.2.0 - 2025-04-25","text":""},{"location":"versions.html#fixed_2","title":"Fixed","text":"<ul> <li>Fixed TypeScript errors related to the <code>eventsource-parser</code> package imports</li> <li>Updated imports to use the correct types from <code>eventsource-parser</code> v1.1.1</li> <li>Properly typed the <code>EventSourceMessage</code> as <code>ParsedEvent</code></li> <li>Refactored <code>createParser</code> implementation to match the package's API</li> <li>Fixed streaming response handler to use the correct event type checking</li> </ul>"},{"location":"versions.html#changed_6","title":"Changed","text":"<ul> <li>Updated <code>tsconfig.json</code> to add <code>isolatedModules: true</code> for better compatibility with <code>ts-jest</code></li> <li>Modified <code>package.json</code> test scripts to include <code>NODE_OPTIONS=--experimental-vm-modules</code> flag to support ES modules in Jest tests</li> </ul>"},{"location":"versions.html#improved_2","title":"Improved","text":"<ul> <li>Expanded test suite to achieve 80% code coverage</li> <li>Added tests for all client methods</li> <li>Added robust error handling tests</li> <li>Added tests for streaming functionality</li> <li>Added tests for push notification configuration</li> <li>Added tests for edge cases in agent card fetching and capability detection</li> </ul>"},{"location":"versions.html#010-2025-04-22","title":"0.1.0 - 2025-04-22","text":""},{"location":"versions.html#added_6","title":"Added","text":"<ul> <li>Initial release of the @artinet/sdk package</li> <li>Implementation of the Agent2Agent (A2A) Protocol client</li> <li>Support for sending tasks, retrieving statuses, and canceling operations</li> <li>Support for streaming responses and push notifications</li> <li>Comprehensive test suite and documentation</li> </ul>"},{"location":"agents/agent-creation.html","title":"Agent Creation Guide","text":"<p>Welcome to the comprehensive guide for creating agents with Artinet. This guide will walk you through creating powerful, autonomous agents using our Hero Types system, designed to make agent creation intuitive and effective.</p>"},{"location":"agents/agent-creation.html#overview","title":"Overview","text":"<p>Agent creation in Artinet focuses on three core Hero Types, each designed for specific roles and capabilities. Understanding these types is crucial for creating agents that perform optimally in their intended roles.</p>"},{"location":"agents/agent-creation.html#hero-types","title":"Hero Types","text":""},{"location":"agents/agent-creation.html#director-agent","title":"Director Agent","text":"<p>Role: Agent used to orchestrate and manage other agents</p> <p>Directors are the conductors of the agent ecosystem. They coordinate workflows, delegate tasks, and ensure smooth collaboration between multiple agents.</p> <p>Key Characteristics: - High-level decision making - Task orchestration and delegation - Multi-agent workflow management - Strategic planning and execution - Resource allocation and optimization</p> <p>Best Use Cases: - Complex multi-step projects - Team coordination scenarios - Workflow automation - Project management tasks - Strategic business processes</p>"},{"location":"agents/agent-creation.html#worker-agent","title":"Worker Agent","text":"<p>Role: Agent with access to tools (MCP)</p> <p>Workers are the hands-on agents that execute specific tasks using tools and integrations. They have access to Model Control Protocol (MCP) tools to interact with external systems.</p> <p>Key Characteristics: - Direct tool and system integration - Specialized task execution - Data processing and manipulation - API interactions and external service calls - Focused, single-domain expertise</p> <p>Best Use Cases: - Data analysis and processing - System integrations - File management operations - API-based workflows - Specialized computational tasks</p>"},{"location":"agents/agent-creation.html#speaker-agent","title":"Speaker Agent","text":"<p>Role: Basic text-generation/conversational agent</p> <p>Speakers excel at communication, content creation, and conversational interfaces. They focus on natural language processing and generation.</p> <p>Key Characteristics: - Natural language conversation - Content creation and writing - Communication facilitation - Information presentation - User interaction and support</p> <p>Best Use Cases: - Customer service and support - Content generation - Conversational interfaces - Documentation creation - Educational and training scenarios</p>"},{"location":"agents/agent-creation.html#creating-your-agent","title":"Creating Your Agent","text":""},{"location":"agents/agent-creation.html#required-fields","title":"Required Fields","text":"<p>When creating an agent, you'll encounter several fields. Most are explanatory, but Agent Skills and Description deserve special attention as they function as prompts that other agents will use to understand and leverage your agent.</p>"},{"location":"agents/agent-creation.html#agent-skills-and-description","title":"Agent Skills and Description","text":"<p>\u26a0\ufe0f Important: These fields are not just metadata - they serve as prompts that other agents will see and use to understand how to interact with your agent. Think of them as your agent's public interface.</p> <p>Agent Skills should include: - Specific capabilities your agent possesses - Types of tasks it can handle - Tools and integrations it has access to - Domain expertise areas - Input/output formats it works with</p> <p>Example for a Data Analysis Worker: <pre><code>Data processing and visualization, SQL query generation, statistical analysis, \nCSV/JSON file handling, chart creation, trend analysis, data validation, \nreporting automation\n</code></pre></p> <p>Agent Description should be written like a clear, actionable prompt: - Explain the agent's primary purpose - Define its role in workflows - Specify how other agents should interact with it - Include any important constraints or guidelines</p> <p>Example for a Content Director: <pre><code>I am a content strategy director that coordinates content creation workflows. \nI analyze content requirements, delegate writing tasks to specialist agents, \nensure brand consistency, and manage editorial calendars. Send me content \nbriefs or strategic questions, and I'll orchestrate the appropriate team \nof content creators to deliver comprehensive results.\n</code></pre></p>"},{"location":"agents/agent-creation.html#agent-configuration-fields","title":"Agent Configuration Fields","text":""},{"location":"agents/agent-creation.html#basic-information","title":"Basic Information","text":"<ul> <li>Name: Choose a clear, descriptive name</li> <li>Hero Type: Select Director, Worker, or Speaker based on intended role</li> <li>Description: Write as a clear prompt for other agents (detailed above)</li> <li>Skills: List specific capabilities (detailed above)</li> </ul>"},{"location":"agents/agent-creation.html#advanced-configuration","title":"Advanced Configuration","text":"<ul> <li>Model Selection: Choose the appropriate LLM for your agent's complexity</li> <li>Temperature: Adjust creativity vs. consistency (0.1 for precise tasks, 0.7 for creative work)</li> <li>Context Window: Set based on expected input complexity</li> <li>Response Length: Configure appropriate output limits</li> </ul>"},{"location":"agents/agent-creation.html#integration-settings","title":"Integration Settings","text":"<ul> <li>MCP Tools (Worker agents): Select relevant tools and integrations</li> <li>API Connections: Configure external service access</li> <li>File Access: Set permissions for data and document handling</li> </ul>"},{"location":"agents/agent-creation.html#best-practices","title":"Best Practices","text":""},{"location":"agents/agent-creation.html#prompt-engineering-for-agent-discovery","title":"Prompt Engineering for Agent Discovery","text":"<p>Since other agents will use your Skills and Description to understand your agent:</p> <ol> <li>Be Specific: Avoid vague terms like \"helpful\" or \"smart\"</li> <li>Use Action Words: Include verbs that describe what your agent does</li> <li>Include Context: Mention the types of inputs your agent expects</li> <li>Set Boundaries: Clearly state what your agent cannot or should not do</li> </ol>"},{"location":"agents/agent-creation.html#hero-type-selection-guide","title":"Hero Type Selection Guide","text":"<p>Choose Director if: - Your agent needs to coordinate multiple other agents - The task involves complex multi-step workflows - Decision-making and planning are primary functions - You need to manage resources or prioritize tasks</p> <p>Choose Worker if: - Your agent performs specific, tool-based tasks - Integration with external systems is required - The work involves data processing or manipulation - Specialized domain expertise is needed</p> <p>Choose Speaker if: - Primary function is communication or content creation - User interaction is the main interface - Natural language processing is the core capability - The agent serves as a conversational interface</p>"},{"location":"agents/agent-creation.html#getting-started","title":"Getting Started","text":"<ol> <li>Define Your Use Case: Clearly identify what problem your agent will solve</li> <li>Select Hero Type: Choose based on the role analysis above</li> <li>Write Clear Prompts: Craft Skills and Description as if talking to another agent</li> <li>Configure Appropriately: Set model parameters based on task complexity</li> <li>Test Thoroughly: Use the testing features before deployment</li> </ol>"},{"location":"agents/agent-creation.html#next-steps","title":"Next Steps","text":"<p>After creating your agent: - Test Your Agent - Learn how to thoroughly test your agent - Deploy to Grid - Understand workflow integration - API Key Management - Set up secure access</p> <p>\ud83d\udca1 Pro Tip: Remember that in Artinet's ecosystem, agents work together. Design your agent not just to solve problems, but to collaborate effectively with other agents in the network. </p>"},{"location":"agents/api-keys.html","title":"API Key Management","text":"<p>API keys are essential for securing access to your agents and workflows in the Artinet ecosystem. This guide covers everything you need to know about generating, managing, and securing API keys for optimal agent operation.</p>"},{"location":"agents/api-keys.html#overview","title":"Overview","text":"<p>API keys in Artinet serve multiple purposes: - Agent Authentication: Secure access to your deployed agents - Workflow Integration: Connect external systems to your agent workflows - Resource Protection: Control who can use your computational resources - Usage Tracking: Monitor API consumption and billing - Access Control: Fine-grained permissions for different use cases</p>"},{"location":"agents/api-keys.html#generating-api-keys","title":"Generating API Keys","text":""},{"location":"agents/api-keys.html#creating-your-first-api-key","title":"Creating Your First API Key","text":"<ol> <li>Navigate to API Management: Go to your dashboard and select \"API Keys\"</li> <li>Click \"Generate New Key\": Start the key creation process</li> <li>Configure Key Settings: Set permissions, expiration, and scope</li> <li>Copy and Secure: Save the key immediately - it won't be shown again</li> <li>Test Integration: Verify the key works with a simple API call</li> </ol>"},{"location":"agents/api-keys.html#api-key-configuration-options","title":"API Key Configuration Options","text":""},{"location":"agents/api-keys.html#key-permissions","title":"Key Permissions","text":"<p>Set specific permissions for each API key:</p> <p>Agent Access Levels: - Read Only: Query agent status and retrieve results - Execute: Send tasks to agents and trigger workflows - Manage: Modify agent configurations and settings - Full Access: Complete control including deployment and deletion</p> <p>Resource Scope: - Single Agent: Access limited to one specific agent - Agent Group: Access to a defined set of agents - All Agents: Access to your entire agent ecosystem - Workflow Specific: Access limited to specific workflows</p>"},{"location":"agents/api-keys.html#security-settings","title":"Security Settings","text":"<p>Expiration Options: - 30 Days: Short-term keys for temporary integrations - 90 Days: Medium-term keys for project-based work - 1 Year: Long-term keys for production systems - No Expiration: Permanent keys (use with caution)</p> <p>IP Restrictions: - Any IP: Allow access from any location (default) - Specific IPs: Restrict to defined IP addresses - IP Ranges: Allow access from specific network ranges - Dynamic IPs: Support for changing IP addresses with validation</p> <p>Usage Limits: - Rate Limiting: Requests per minute/hour/day - Resource Quotas: Computational resource consumption limits - Bandwidth Limits: Data transfer restrictions - Concurrent Connections: Maximum simultaneous connections</p>"},{"location":"agents/api-keys.html#key-types-and-use-cases","title":"Key Types and Use Cases","text":""},{"location":"agents/api-keys.html#development-keys","title":"Development Keys","text":"<p>Purpose: Testing and development environments - Permissions: Limited access to test agents - Expiration: Short-term (30 days) - Rate Limits: Low limits to prevent accidental overuse - IP Restrictions: Development environment IPs only</p>"},{"location":"agents/api-keys.html#production-keys","title":"Production Keys","text":"<p>Purpose: Live applications and services - Permissions: Specific to production requirements - Expiration: Long-term or no expiration - Rate Limits: Higher limits based on expected usage - IP Restrictions: Production server IPs only</p>"},{"location":"agents/api-keys.html#integration-keys","title":"Integration Keys","text":"<p>Purpose: Third-party service connections - Permissions: Minimal required permissions - Expiration: Based on integration lifecycle - Rate Limits: Moderate limits - IP Restrictions: Service provider IP ranges</p>"},{"location":"agents/api-keys.html#emergency-keys","title":"Emergency Keys","text":"<p>Purpose: Backup access and incident response - Permissions: Full access for emergency situations - Expiration: Short-term with regular rotation - Rate Limits: High limits for rapid response - IP Restrictions: Authorized personnel IPs only</p>"},{"location":"agents/api-keys.html#api-key-security-best-practices","title":"API Key Security Best Practices","text":""},{"location":"agents/api-keys.html#key-generation-security","title":"Key Generation Security","text":"<p>Strong Key Generation: - Keys are generated using cryptographically secure random number generators - Minimum 256-bit entropy for all production keys - Unique keys with no predictable patterns - Immediate encryption of keys in our systems</p>"},{"location":"agents/api-keys.html#storage-and-handling","title":"Storage and Handling","text":"<p>Secure Storage: - Environment Variables: Store keys as environment variables, not in code - Secrets Management: Use dedicated secrets management systems - Encryption at Rest: Encrypt stored keys with additional encryption - Access Logging: Monitor and log all key access attempts</p> <p>Code Security: <pre><code># \u2705 Good - Using environment variable\nexport ARTINET_API_KEY=\"your-api-key-here\"\n\n# \u274c Bad - Hardcoded in code\napi_key = \"ak_1234567890abcdef\"\n</code></pre></p> <p>Version Control: - Never commit keys: Add API keys to .gitignore - Environment files: Keep .env files out of repositories - Key scanning: Use tools to scan for accidentally committed keys - Immediate rotation: Rotate any keys that may have been exposed</p>"},{"location":"agents/api-keys.html#key-rotation","title":"Key Rotation","text":"<p>Regular Rotation Schedule: - Production Keys: Rotate every 90 days - Development Keys: Rotate every 30 days - High-privilege Keys: Rotate every 30 days - Emergency Keys: Rotate after each use</p> <p>Rotation Process: 1. Generate new key with same permissions 2. Update applications to use new key 3. Test all integrations with new key 4. Deactivate old key after verification 5. Monitor for any failed authentications</p>"},{"location":"agents/api-keys.html#monitoring-and-alerts","title":"Monitoring and Alerts","text":"<p>Key Usage Monitoring: - Unusual Patterns: Alert on unexpected usage patterns - Failed Authentications: Monitor failed API key attempts - Rate Limit Violations: Track keys hitting rate limits - Geographic Anomalies: Alert on access from unusual locations</p> <p>Security Alerts: - Key Compromise: Immediate alerts for suspected key theft - Privilege Escalation: Monitor for unusual permission usage - Bulk Operations: Alert on mass operations that could indicate misuse - New Key Creation: Notify on new key generation</p>"},{"location":"agents/api-keys.html#api-key-management-interface","title":"API Key Management Interface","text":""},{"location":"agents/api-keys.html#dashboard-features","title":"Dashboard Features","text":"<p>Key Overview: - Active Keys: List of all active API keys - Key Status: Health and usage status of each key - Permission Summary: Quick view of key permissions - Usage Statistics: Recent usage patterns and metrics</p> <p>Key Details: - Creation Date: When the key was generated - Last Used: Most recent API call timestamp - Usage Stats: Detailed usage analytics - Security Events: Log of security-related events</p>"},{"location":"agents/api-keys.html#bulk-operations","title":"Bulk Operations","text":"<p>Multi-Key Management: - Batch Rotation: Rotate multiple keys simultaneously - Group Permissions: Apply permission changes to key groups - Bulk Deactivation: Quickly deactivate multiple keys - Export Configuration: Export key settings for backup</p>"},{"location":"agents/api-keys.html#audit-and-compliance","title":"Audit and Compliance","text":"<p>Audit Logging: - Key Generation: Log all key creation events - Permission Changes: Track modifications to key permissions - Access Patterns: Detailed logs of API key usage - Security Events: Comprehensive security event logging</p> <p>Compliance Reports: - Access Reports: Who has access to what resources - Usage Reports: Resource consumption by API key - Security Reports: Security events and responses - Compliance Dashboards: Real-time compliance status</p>"},{"location":"agents/api-keys.html#integration-examples","title":"Integration Examples","text":""},{"location":"agents/api-keys.html#basic-authentication","title":"Basic Authentication","text":"<pre><code># Basic API call with authentication\ncurl -H \"Authorization: Bearer YOUR_API_KEY\" \\\n     -H \"Content-Type: application/json\" \\\n     \"https://api.artinet.io/v1/agents/your-agent-id/execute\"\n</code></pre>"},{"location":"agents/api-keys.html#python-integration","title":"Python Integration","text":"<pre><code>import os\nimport requests\n\n# Secure key retrieval from environment\napi_key = os.getenv('ARTINET_API_KEY')\n\nheaders = {\n    'Authorization': f'Bearer {api_key}',\n    'Content-Type': 'application/json'\n}\n\nresponse = requests.post(\n    'https://api.artinet.io/v1/agents/execute',\n    headers=headers,\n    json={'task': 'your task here'}\n)\n</code></pre>"},{"location":"agents/api-keys.html#javascript-integration","title":"JavaScript Integration","text":"<pre><code>// Secure API key usage in Node.js\nconst apiKey = process.env.ARTINET_API_KEY;\n\nconst response = await fetch('https://api.artinet.io/v1/agents/execute', {\n    method: 'POST',\n    headers: {\n        'Authorization': `Bearer ${apiKey}`,\n        'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n        task: 'your task here'\n    })\n});\n</code></pre>"},{"location":"agents/api-keys.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"agents/api-keys.html#common-issues","title":"Common Issues","text":"<p>Authentication Failures: - Invalid Key: Verify the key is copied correctly - Expired Key: Check expiration date and rotate if needed - Wrong Permissions: Ensure key has required permissions - IP Restrictions: Verify request is from authorized IP</p> <p>Rate Limit Issues: - Exceeded Limits: Monitor usage and adjust limits if needed - Burst Traffic: Implement proper request queuing - Multiple Keys: Distribute load across multiple keys - Usage Optimization: Optimize requests to reduce API calls</p> <p>Integration Problems: - Header Format: Ensure proper Authorization header format - HTTPS Requirements: All API calls must use HTTPS - Request Format: Verify JSON formatting and content types - Response Handling: Implement proper error response handling</p>"},{"location":"agents/api-keys.html#support-and-recovery","title":"Support and Recovery","text":"<p>Key Recovery: - Lost Keys: Cannot be recovered - generate new keys - Compromised Keys: Immediately deactivate and rotate - Access Issues: Contact support with account verification - Emergency Access: Use emergency key procedures</p>"},{"location":"agents/api-keys.html#advanced-features","title":"Advanced Features","text":""},{"location":"agents/api-keys.html#key-hierarchies","title":"Key Hierarchies","text":"<p>Parent-Child Relationships: - Master Keys: Full access keys for system administration - Derived Keys: Limited keys derived from master keys - Inheritance: Permission inheritance from parent keys - Revocation: Cascading revocation of child keys</p>"},{"location":"agents/api-keys.html#integration-webhooks","title":"Integration Webhooks","text":"<p>Key Event Notifications: - Key Creation: Notify when new keys are generated - Usage Anomalies: Alert on unusual usage patterns - Security Events: Immediate notification of security issues - Expiration Warnings: Advance warning of key expiration</p>"},{"location":"agents/api-keys.html#custom-permissions","title":"Custom Permissions","text":"<p>Advanced Permission Models: - Time-based Access: Keys that only work during specific hours - Geographic Restrictions: Location-based access control - Resource Quotas: Fine-grained resource usage limits - Conditional Access: Context-aware permission evaluation</p>"},{"location":"agents/api-keys.html#next-steps","title":"Next Steps","text":"<p>Master API key management and explore: - Agent Creation - Return to agent creation guide - Grid Management - Build visual workflows with your agents - Test and Deploy - Deploy and monitor your agents</p> <p>\ud83d\udd10 Security First: Proper API key management is the foundation of secure agent operations. Always follow security best practices and regularly audit your key usage patterns. </p>"},{"location":"agents/create-quick-agent.html","title":"Create Quick Agent","text":"<p>A tool to create a Quick-Agent project via the CLI.</p>"},{"location":"agents/create-quick-agent.html#overview","title":"Overview","text":"<p><code>create-quick-agent</code> streamlines the initial setup process for building AI agents with the Artinet SDK, allowing you to get your new agent project up and running in minutes.</p> <p>Key Features: - \ud83d\ude80 Quick project scaffolding with predefined templates - \ud83c\udfaf Multiple agent types (basic, coder, orchestrator) - \ud83d\udce6 Automatic dependency installation - \ud83d\udee0\ufe0f Ready-to-use project structure - \ud83d\udd27 Pre-configured build and deployment scripts</p>"},{"location":"agents/create-quick-agent.html#installation-usage","title":"Installation &amp; Usage","text":""},{"location":"agents/create-quick-agent.html#quick-start","title":"Quick Start","text":"<pre><code># Using npx (recommended)\nnpx @artinet/create-quick-agent@latest\n\n# Or install globally\nnpm install -g @artinet/create-quick-agent\ncreate-quick-agent\n</code></pre>"},{"location":"agents/create-quick-agent.html#interactive-workflow","title":"Interactive Workflow","text":"<ol> <li>Run the command</li> <li>Select a template from the available options</li> <li>Enter your project name</li> <li>The tool creates your project directory</li> <li>Dependencies are automatically installed</li> <li>Follow the generated instructions to start developing</li> </ol>"},{"location":"agents/create-quick-agent.html#available-templates","title":"Available Templates","text":"<p>The tool provides several pre-built templates to jumpstart your agent development:</p>"},{"location":"agents/create-quick-agent.html#echo-agent","title":"echo agent","text":"<ul> <li>Template ID: <code>basic</code></li> <li>Description: a simple echo agent that returns your original message. (best for beginners)</li> </ul>"},{"location":"agents/create-quick-agent.html#coding-agent","title":"coding agent","text":"<ul> <li>Template ID: <code>coder</code></li> <li>Description: a coding agent that will return code snippets based on your requests.</li> </ul>"},{"location":"agents/create-quick-agent.html#orchestrator-agent","title":"orchestrator agent","text":"<ul> <li>Template ID: <code>orchestrator</code></li> <li>Description: an orchestrator agent that can call other agents to get the information it needs.</li> </ul>"},{"location":"agents/create-quick-agent.html#template-structure","title":"Template Structure","text":"<p>Each generated project includes:</p> <ul> <li><code>agent.js</code> - Main agent logic and task handler</li> <li><code>package.json</code> - Project configuration and dependencies  </li> <li><code>launch.js</code> - Local development server</li> <li><code>deploy.js</code> - Production deployment script</li> <li><code>test-deploy.js</code> - Test deployment functionality</li> <li><code>lib/</code> - Configuration files (card.js, deployment.js, etc.)</li> </ul>"},{"location":"agents/create-quick-agent.html#example-project-structure","title":"Example Project Structure","text":"<pre><code>my-agent-project/\n\u251c\u2500\u2500 agent.js              # Main agent implementation\n\u251c\u2500\u2500 package.json          # Project dependencies\n\u251c\u2500\u2500 launch.js             # Development server\n\u251c\u2500\u2500 deploy.js             # Production deployment\n\u251c\u2500\u2500 test-deploy.js        # Test runner\n\u2514\u2500\u2500 lib/\n    \u251c\u2500\u2500 card.js           # Agent card configuration\n    \u251c\u2500\u2500 deployment.js     # Deployment configuration\n    \u2514\u2500\u2500 artinet-agent.js  # Artinet platform integration\n</code></pre>"},{"location":"agents/create-quick-agent.html#template-details","title":"Template Details","text":""},{"location":"agents/create-quick-agent.html#basic-template","title":"Basic Template","text":"<p>Files included: agent.js, deploy.js, launch.js, lib, package.json, test-deploy.js</p> <p>Description: a simple echo agent that returns your original message.</p> <p>Agent Preview: <pre><code>/**\n * Basic Agent Example\n *\n * This example demonstrates how to create a simple agent\n * that responds to incoming tasks.\n */\n\nexport async function* demoAgent(context) {\n  // Extract the user's message\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  console.log(`Processing request: ${userText}`);\n\n  // Send a \"working\" status update\n  yield {\n    state: \"working\",\n    message: {\n// ... (truncated for brevity)\n</code></pre></p>"},{"location":"agents/create-quick-agent.html#coder-template","title":"Coder Template","text":"<p>Files included: agent.js, deploy.js, lib, package.json, test-deploy.js</p> <p>Description: a coding agent that will return code snippets based on your requests.</p> <p>Agent Preview: <pre><code>import { artinet } from \"@artinet/sdk/agents\";\n\nexport async function* demoAgent({ task, history }) {\n  history = [...history, ...(task.status.message ? [task.status.message] : [])];\n  const messages = (history ?? [])\n    .map((m) =&gt; ({\n      role: m.role === \"agent\" ? \"model\" : \"user\",\n      content: m.parts\n        .filter((p) =&gt; !!p.text)\n        .map((p) =&gt; p.text)\n        .join(\"\\n\"),\n    }))\n    .filter((m) =&gt; m.content.length &gt; 0);\n\n  if (messages.length === 0) {\n    console.warn(`[CoderAgent] No history/messages found for task ${task.id}`);\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n// ... (truncated for brevity)\n</code></pre></p>"},{"location":"agents/create-quick-agent.html#orchestrator-template","title":"Orchestrator Template","text":"<p>Files included: agent.js, deploy.js, lib, package.json, test-deploy.js</p> <p>Description: an orchestrator agent that can call other agents to get the information it needs.</p> <p>Agent Preview: <pre><code>import { artinet } from \"@artinet/sdk/agents\";\n\nexport async function* demoAgent({ userMessage, isCancelled }) {\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: \"Thinking about your request...\", type: \"text\" }],\n    },\n  };\n\n  const userText = userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  // Create a response\n  let response = `Failed to send task`;\n\n  try {\n// ... (truncated for brevity)\n</code></pre></p>"},{"location":"agents/create-quick-agent.html#development-workflow","title":"Development Workflow","text":"<p>After creating your project:</p> <ol> <li> <p>Navigate to your project:    <pre><code>cd your-project-name\n</code></pre></p> </li> <li> <p>Test your agent locally:    <pre><code>npm test\n</code></pre></p> </li> <li> <p>Start development server:    <pre><code>npm start\n</code></pre></p> </li> <li> <p>Deploy to production:    <pre><code>npm run deploy\n</code></pre></p> </li> </ol>"},{"location":"agents/create-quick-agent.html#configuration","title":"Configuration","text":""},{"location":"agents/create-quick-agent.html#agent-card","title":"Agent Card","text":"<p>Update the <code>./lib/card.js</code> file to customize your agent's metadata:</p> <pre><code>export const agentCard = {\n  name: \"your-agent-name\",\n  description: \"Your agent description\",\n  url: \"https://your-agent.example.com/api\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: false,\n    pushNotifications: false,\n    stateTransitionHistory: false,\n  },\n  skills: [\n    {\n      id: \"your-skill\",\n      name: \"Your Skill\",\n      description: \"What your agent can do\",\n    },\n  ],\n};\n</code></pre>"},{"location":"agents/create-quick-agent.html#environment-variables","title":"Environment Variables","text":"<p>For deployment, ensure you have:</p> <pre><code>ARTINET_API_KEY=your_api_key_here\n</code></pre>"},{"location":"agents/create-quick-agent.html#requirements","title":"Requirements","text":"<ul> <li>Node.js: &gt;=22.0.0</li> <li>npm: Comes with Node.js</li> </ul>"},{"location":"agents/create-quick-agent.html#package-information","title":"Package Information","text":"<ul> <li>Version: 0.0.6</li> <li>License: Apache-2.0</li> <li>Repository: https://github.com/the-artinet-project/create-quick-agent</li> </ul>"},{"location":"agents/create-quick-agent.html#links","title":"Links","text":"<ul> <li>Artinet SDK Documentation</li> <li>GitHub Repository</li> <li>npm Package</li> </ul>"},{"location":"agents/create-quick-agent.html#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please see the repository for guidelines on:</p> <ul> <li>Submitting bug reports</li> <li>Requesting new features  </li> <li>Contributing template improvements</li> <li>Adding new agent templates</li> </ul> <p>Generated automatically from create-quick-agent source code</p>"},{"location":"agents/grid-management.html","title":"Grid Management","text":"<p>The Agent Grid is Artinet's visual workflow builder that allows you to create complex, multi-agent systems by connecting agents in sophisticated workflows. This guide covers everything you need to know about managing agents within the grid environment.</p>"},{"location":"agents/grid-management.html#overview","title":"Overview","text":"<p>The Agent Grid provides a drag-and-drop interface for: - Adding existing agents to workflows - Creating new agents directly in workflows - Connecting agents through visual relationships - Testing complex multi-agent scenarios - Saving and loading workflow configurations</p>"},{"location":"agents/grid-management.html#adding-agents-to-the-grid","title":"Adding Agents to the Grid","text":""},{"location":"agents/grid-management.html#adding-existing-agents","title":"Adding Existing Agents","text":"<p>You can add any of your deployed agents to the grid workflow:</p> <ol> <li>Access Agent Library: Click the \"Add Agent\" button in the grid interface</li> <li>Browse Available Agents: View all your deployed agents from \"My Agents\"</li> <li>Filter by Type: Use filters to find specific hero types (Director, Worker, Speaker)</li> <li>Drag to Grid: Simply drag the desired agent onto the grid canvas</li> <li>Position and Configure: Place the agent node where you want it in your workflow</li> </ol> <p>Agent Information Display: - Agent name and type - Current status (active/inactive) - Available connections - Resource usage indicators</p>"},{"location":"agents/grid-management.html#adding-new-agents","title":"Adding New Agents","text":"<p>Create new agents directly within the grid environment:</p> <ol> <li>Click \"New Agent\": Select the new agent option in the grid</li> <li>Quick Creation Form: Fill out essential fields (name, type, basic skills)</li> <li>Rapid Configuration: Set up basic parameters optimized for grid use</li> <li>Immediate Integration: Agent becomes available in the current workflow</li> <li>Refine Later: Access full configuration options from the agent's context menu</li> </ol> <p>Grid-Optimized Creation: - Streamlined form with essential fields only - Pre-configured settings for common workflow patterns - Automatic connection suggestions based on grid context - Immediate testing capabilities</p>"},{"location":"agents/grid-management.html#connecting-agents","title":"Connecting Agents","text":""},{"location":"agents/grid-management.html#drag-connection-system","title":"Drag Connection System","text":"<p>The grid uses an intuitive drag-and-drop system for creating agent connections:</p>"},{"location":"agents/grid-management.html#for-director-agents","title":"For Director Agents","text":"<p>Directors can manage multiple Worker and Speaker agents:</p> <ol> <li>Connection Points: Director agents show multiple output connection points</li> <li>Drag to Connect: Drag from Director's output to target agent's input</li> <li>Connection Types: Different connection types for different interaction patterns</li> <li>Validation: System validates connection compatibility automatically</li> </ol> <p>Connection Types for Directors: - Task Delegation: Send specific tasks to Worker agents - Information Request: Query agents for status or results - Coordination: Manage multi-agent collaborations - Resource Allocation: Distribute resources among connected agents</p>"},{"location":"agents/grid-management.html#agent-to-agent-connections","title":"Agent-to-Agent Connections","text":"<p>Create direct connections between any compatible agents:</p> <ol> <li>Output Ports: Each agent shows available output connection points</li> <li>Input Ports: Compatible agents show matching input points</li> <li>Smart Suggestions: System highlights potential connection targets</li> <li>Connection Rules: Visual feedback for valid/invalid connections</li> </ol> <p>Connection Validation: - Data type compatibility checking - Hero type relationship validation - Circular dependency prevention - Resource conflict detection</p>"},{"location":"agents/grid-management.html#connection-management","title":"Connection Management","text":"<p>Editing Connections: - Right-click connection: Access connection properties - Connection Settings: Configure data flow parameters - Connection Labels: Add descriptions for complex workflows - Conditional Logic: Set up conditional connection rules</p> <p>Connection Monitoring: - Data Flow Indicators: Visual representation of information flow - Performance Metrics: Connection throughput and latency - Error Indicators: Visual alerts for connection problems - Traffic Analytics: Historical data flow analysis</p>"},{"location":"agents/grid-management.html#testing-within-grid","title":"Testing Within Grid","text":""},{"location":"agents/grid-management.html#grid-testing-capabilities","title":"Grid Testing Capabilities","text":"<p>The grid provides comprehensive testing for multi-agent workflows:</p>"},{"location":"agents/grid-management.html#director-testing-requirements","title":"Director Testing Requirements","text":"<p>Important: Directors can only be fully tested if their connected child agents are deployed:</p> <ul> <li>Deployment Check: System verifies all connected agents are deployed</li> <li>Warning System: Clear indicators when child agents are not ready</li> <li>Partial Testing: Test Director logic with simulated responses</li> <li>Full Integration: Complete testing once all agents are deployed</li> </ul>"},{"location":"agents/grid-management.html#testing-modes","title":"Testing Modes","text":"<p>Individual Agent Testing: - Test single agents within grid context - Validate agent responses with grid-specific inputs - Monitor performance in workflow environment - Debug agent behavior in isolation</p> <p>Workflow Testing: - End-to-End Testing: Test complete workflows from start to finish - Step-by-Step Testing: Execute workflows in stages for debugging - Load Testing: Simulate high-volume scenarios - Error Scenario Testing: Test error handling and recovery</p> <p>Test Scenarios: - Happy Path: Test normal workflow execution - Edge Cases: Test with boundary conditions and unusual inputs - Failure Recovery: Test agent failure and recovery scenarios - Performance Limits: Test with maximum expected loads</p>"},{"location":"agents/grid-management.html#test-execution","title":"Test Execution","text":"<ol> <li>Select Test Mode: Choose individual agent or full workflow testing</li> <li>Configure Test Data: Set up test inputs and expected outcomes</li> <li>Run Tests: Execute tests with real-time monitoring</li> <li>Review Results: Analyze test outcomes and performance metrics</li> <li>Debug Issues: Use built-in debugging tools to resolve problems</li> </ol>"},{"location":"agents/grid-management.html#saving-and-loading-workflows","title":"Saving and Loading Workflows","text":""},{"location":"agents/grid-management.html#workflow-management","title":"Workflow Management","text":"<p>Saving Workflows: - Auto-Save: Workflows automatically save as you build - Manual Save: Use Ctrl+S or Save button for immediate saves - Version Control: Multiple versions maintained automatically - Save States: Create named save points for major milestones</p> <p>Workflow Properties: - Workflow Name: Descriptive names for easy identification - Description: Detailed explanation of workflow purpose - Tags: Categorization for easy searching - Sharing Settings: Control who can access and modify workflows</p>"},{"location":"agents/grid-management.html#loading-workflows","title":"Loading Workflows","text":"<p>Accessing Saved Workflows: 1. Workflow Library: Browse all saved workflows 2. Recent Workflows: Quick access to recently modified workflows 3. Shared Workflows: Access workflows shared by team members 4. Template Library: Pre-built workflow templates</p> <p>Loading Options: - Replace Current: Replace current grid with loaded workflow - Merge: Add loaded workflow elements to current grid - Import as Template: Use as starting point for new workflow</p>"},{"location":"agents/grid-management.html#workflow-sharing","title":"Workflow Sharing","text":"<p>Collaboration Features: - Share Links: Generate secure links for workflow sharing - Permission Management: Control view/edit permissions - Team Libraries: Shared repositories for team workflows - Export/Import: Package workflows for distribution</p>"},{"location":"agents/grid-management.html#advanced-grid-features","title":"Advanced Grid Features","text":""},{"location":"agents/grid-management.html#workflow-optimization","title":"Workflow Optimization","text":"<p>Performance Analysis: - Bottleneck Detection: Identify performance constraints - Resource Usage: Monitor computational resource consumption - Optimization Suggestions: AI-powered workflow improvement recommendations - Scaling Recommendations: Guidance for handling increased loads</p> <p>Grid Analytics: - Execution Metrics: Track workflow performance over time - Success Rates: Monitor workflow reliability - Error Analysis: Detailed breakdown of failure patterns - Usage Patterns: Understand how workflows are being used</p>"},{"location":"agents/grid-management.html#integration-features","title":"Integration Features","text":"<p>External Integrations: - API Endpoints: Expose workflows as API services - Webhook Triggers: Start workflows from external events - Scheduled Execution: Time-based workflow automation - Event-Driven Workflows: React to system or external events</p>"},{"location":"agents/grid-management.html#best-practices","title":"Best Practices","text":""},{"location":"agents/grid-management.html#grid-design-principles","title":"Grid Design Principles","text":"<p>Workflow Organization: - Clear Flow Direction: Left-to-right or top-to-bottom flows - Logical Grouping: Group related agents together - Minimal Crossing: Reduce connection line crossings - Consistent Spacing: Maintain uniform spacing between elements</p> <p>Connection Management: - Minimal Connections: Avoid over-connecting agents - Clear Dependencies: Make workflow dependencies obvious - Error Paths: Include error handling in workflow design - Documentation: Use labels and descriptions liberally</p>"},{"location":"agents/grid-management.html#testing-strategy","title":"Testing Strategy","text":"<p>Comprehensive Testing: - Start with individual agent testing - Progress to partial workflow testing - Complete with full end-to-end testing - Regular regression testing for changes</p> <p>Version Management: - Save major milestones as named versions - Test before saving critical versions - Maintain rollback capabilities - Document changes between versions</p>"},{"location":"agents/grid-management.html#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues:</p> <p>Connection Problems: - Check agent deployment status - Verify connection compatibility - Review security permissions - Check for circular dependencies</p> <p>Testing Failures: - Ensure all required agents are deployed - Check test data validity - Review agent configuration - Monitor resource availability</p> <p>Performance Issues: - Analyze workflow complexity - Check for resource bottlenecks - Review connection efficiency - Consider workflow optimization</p>"},{"location":"agents/grid-management.html#next-steps","title":"Next Steps","text":"<p>Master grid management and explore: - API Key Management - Secure workflow access - Test and Deploy - Deploy your workflows to production - Agent Creation - Create more specialized agents for your workflows</p> <p>\ud83d\udca1 Grid Mastery: The Agent Grid transforms complex multi-agent coordination from code-heavy implementations into visual, manageable workflows that anyone can understand and modify. </p>"},{"location":"agents/hero-types.html","title":"Hero Types: Director, Worker, and Speaker","text":"<p>Artinet's Hero Types system provides a powerful framework for creating specialized agents designed for specific roles within multi-agent workflows. Understanding these types is essential for building effective agent ecosystems.</p>"},{"location":"agents/hero-types.html#understanding-hero-types","title":"Understanding Hero Types","text":"<p>Hero Types represent different operational paradigms that determine how your agent functions, interacts with other agents, and handles tasks. Each type is optimized for specific use cases and comes with unique capabilities and characteristics.</p>"},{"location":"agents/hero-types.html#why-use-hero-types","title":"Why Use Hero Types?","text":"<p>Simplified Agent Creation: Instead of building agents from scratch, Hero Types provide pre-configured templates optimized for specific roles.</p> <p>Better Agent Discovery: Other agents can easily understand your agent's capabilities by identifying its Hero Type.</p> <p>Optimized Performance: Each type is optimized for its intended use case, providing better performance and resource utilization.</p> <p>Seamless Integration: Hero Types are designed to work together in complex workflows with minimal configuration.</p>"},{"location":"agents/hero-types.html#director-agent","title":"Director Agent","text":""},{"location":"agents/hero-types.html#overview","title":"Overview","text":"<p>Directors are the orchestrators of the agent ecosystem. They coordinate complex workflows, manage multiple agents, and make high-level strategic decisions. Think of them as project managers or conductors who don't necessarily do the detailed work themselves but ensure everything runs smoothly.</p>"},{"location":"agents/hero-types.html#core-characteristics","title":"Core Characteristics","text":"<p>Strategic Decision Making - Analyzes complex scenarios and breaks them down into manageable tasks - Makes routing decisions about which agents should handle specific work - Prioritizes tasks and manages resource allocation - Handles escalation and exception management</p> <p>Multi-Agent Coordination - Maintains awareness of connected agents and their capabilities - Delegates tasks based on agent specializations and current workload - Monitors progress and ensures workflow completion - Manages dependencies between different tasks and agents</p> <p>Workflow Management - Understands complex business processes and workflows - Sequences operations for optimal efficiency - Handles parallel processing coordination - Manages state across multiple operations</p>"},{"location":"agents/hero-types.html#technical-capabilities","title":"Technical Capabilities","text":"<p>Agent Communication - Direct integration with other agents via standardized protocols - Ability to query agent status and capabilities - Task delegation with clear success criteria - Result aggregation from multiple sources</p> <p>Process Intelligence - Built-in workflow logic and decision trees - Conditional routing based on data and context - Loop and iteration handling for complex processes - Error handling and recovery strategies</p> <p>Resource Management - Load balancing across connected agents - Queue management for high-volume scenarios - Resource optimization and conflict resolution - Performance monitoring and adjustment</p>"},{"location":"agents/hero-types.html#best-use-cases","title":"Best Use Cases","text":"<p>Complex Project Management <pre><code>Example: Content Production Director\n- Receives content brief from client\n- Analyzes requirements and breaks down into tasks\n- Delegates writing to Speaker agents\n- Assigns research to Worker agents\n- Coordinates review and editing processes\n- Manages timeline and quality control\n</code></pre></p> <p>Business Process Automation - Order processing workflows - Customer onboarding sequences - Financial approval processes - Compliance and audit workflows</p> <p>Multi-Step Data Processing - ETL pipeline coordination - Data validation and quality assurance - Report generation and distribution - System integration workflows</p> <p>Strategic Analysis - Market research coordination - Competitive analysis management - Investment decision processes - Risk assessment workflows</p>"},{"location":"agents/hero-types.html#configuration-guidelines","title":"Configuration Guidelines","text":"<p>Prompt Design for Directors Focus on strategic thinking and coordination:</p> <pre><code>You are a strategic project director responsible for coordinating complex \nmulti-agent workflows. You excel at breaking down complex requirements into \nactionable tasks, selecting the right agents for each job, and ensuring \nsmooth collaboration between team members. You make decisions based on \nagent capabilities, current workload, and project priorities.\n\nWhen given a complex task:\n1. Analyze and break down requirements\n2. Identify the best agents for each sub-task\n3. Coordinate execution with clear success criteria\n4. Monitor progress and handle any issues\n5. Aggregate results and ensure quality\n\nYou delegate detailed work to specialist agents but maintain oversight \nand strategic control throughout the process.\n</code></pre> <p>Skills and Capabilities - Project management and coordination - Strategic analysis and decision making - Multi-agent workflow orchestration - Resource allocation and optimization - Quality assurance and process improvement</p>"},{"location":"agents/hero-types.html#worker-agent","title":"Worker Agent","text":""},{"location":"agents/hero-types.html#overview_1","title":"Overview","text":"<p>Workers are the hands-on specialists of the agent ecosystem. They excel at specific tasks, have access to tools and integrations, and focus on executing detailed operations. They are the subject matter experts who handle the technical, analytical, or specialized work.</p>"},{"location":"agents/hero-types.html#core-characteristics_1","title":"Core Characteristics","text":"<p>Tool Integration - Direct access to Model Control Protocol (MCP) tools - Integration with external APIs and services - File system operations and data manipulation - Database queries and data processing capabilities</p> <p>Specialized Expertise - Deep knowledge in specific domains or technologies - Optimized for particular types of tasks or data - Consistent execution of detailed operations - High accuracy and reliability in their specialty area</p> <p>Focused Execution - Single-task focus for optimal performance - Detailed processing of specific data types - Thorough analysis within their domain - Comprehensive output with detailed results</p>"},{"location":"agents/hero-types.html#technical-capabilities_1","title":"Technical Capabilities","text":"<p>MCP Tool Access - File operations (read, write, process various formats) - API integrations (REST, GraphQL, webhooks) - Database operations (SQL queries, data analysis) - System operations (monitoring, deployment, automation)</p> <p>Data Processing - Advanced data manipulation and transformation - Statistical analysis and computational operations - Format conversion and data validation - Batch processing and bulk operations</p> <p>External System Integration - CRM and business system connections - Cloud service integrations - Third-party tool coordination - Real-time data synchronization</p>"},{"location":"agents/hero-types.html#best-use-cases_1","title":"Best Use Cases","text":"<p>Data Analysis and Processing <pre><code>Example: Financial Analysis Worker\n- Connects to financial databases and APIs\n- Processes transaction data and market information\n- Performs statistical analysis and trend detection\n- Generates detailed reports and visualizations\n- Integrates with Excel, databases, and reporting tools\n</code></pre></p> <p>System Integration - API data synchronization - Database management and queries - File processing and conversion - System monitoring and maintenance</p> <p>Specialized Computations - Statistical analysis and modeling - Image and video processing - Text analysis and NLP operations - Mathematical calculations and simulations</p> <p>Technical Operations - Code analysis and review - System deployment and management - Security scanning and compliance checks - Performance optimization and monitoring</p>"},{"location":"agents/hero-types.html#configuration-guidelines_1","title":"Configuration Guidelines","text":"<p>Prompt Design for Workers Focus on detailed execution and tool usage:</p> <pre><code>You are a specialized data analysis worker with expertise in financial \ndata processing and statistical analysis. You have access to database \nconnections, API integrations, and analytical tools. You excel at:\n\n- Processing large datasets with accuracy and efficiency\n- Performing complex statistical analysis and modeling\n- Generating detailed reports and visualizations\n- Integrating data from multiple sources and systems\n\nWhen given a task:\n1. Clarify data requirements and sources\n2. Gather and validate necessary data\n3. Apply appropriate analytical methods\n4. Generate comprehensive results with supporting details\n5. Provide actionable insights and recommendations\n\nAlways use available tools to provide accurate, data-driven results.\n</code></pre> <p>Skills and Capabilities - Specific tool proficiencies (databases, APIs, processing tools) - Domain expertise (finance, marketing, operations, etc.) - Data analysis and manipulation - System integration and automation - Quality assurance and validation</p>"},{"location":"agents/hero-types.html#speaker-agent","title":"Speaker Agent","text":""},{"location":"agents/hero-types.html#overview_2","title":"Overview","text":"<p>Speakers are the communication specialists of the agent ecosystem. They excel at natural language processing, content creation, and user interaction. They serve as the interface between technical systems and human users, translating complex information into understandable communication.</p>"},{"location":"agents/hero-types.html#core-characteristics_2","title":"Core Characteristics","text":"<p>Natural Language Excellence - Advanced language understanding and generation - Context-aware conversation management - Tone and style adaptation based on audience - Multi-language capabilities where needed</p> <p>Content Creation - High-quality writing and editing - Creative content development - Educational content and explanations - Marketing and promotional materials</p> <p>User Interaction - Conversational interface management - User needs assessment and clarification - Feedback processing and response - Escalation handling for complex issues</p>"},{"location":"agents/hero-types.html#technical-capabilities_2","title":"Technical Capabilities","text":"<p>Communication Optimization - Audience-specific language adaptation - Format optimization (emails, documents, presentations) - Brand voice and style consistency - Accessibility and clarity optimization</p> <p>Content Intelligence - Context-aware content generation - Research synthesis and summarization - Information organization and presentation - Creative ideation and brainstorming</p> <p>Interactive Features - Real-time conversation management - Multi-turn dialogue handling - Context retention across interactions - Personalization and user preference learning</p>"},{"location":"agents/hero-types.html#best-use-cases_2","title":"Best Use Cases","text":"<p>Customer Service and Support <pre><code>Example: Customer Support Speaker\n- Handles customer inquiries with empathy and expertise\n- Provides clear explanations of products and policies\n- Escalates complex issues to appropriate specialists\n- Maintains brand voice and customer satisfaction\n- Follows up on resolutions and gathers feedback\n</code></pre></p> <p>Content Creation - Blog posts and articles - Marketing copy and advertisements - Educational materials and tutorials - Documentation and user guides</p> <p>Communication Management - Email communication and responses - Social media management - Internal communications and announcements - Meeting facilitation and note-taking</p> <p>User Interface and Experience - Chatbot and virtual assistant interactions - Onboarding and user guidance - Help system and FAQ management - User feedback collection and processing</p>"},{"location":"agents/hero-types.html#configuration-guidelines_2","title":"Configuration Guidelines","text":"<p>Prompt Design for Speakers Focus on communication excellence and user experience:</p> <pre><code>You are an expert communication specialist focused on creating clear, \nengaging, and helpful interactions with users. You excel at understanding \nuser needs, explaining complex concepts simply, and maintaining a \nprofessional yet approachable tone.\n\nYour core strengths:\n- Clear, concise communication adapted to your audience\n- Empathetic understanding of user concerns and questions\n- Creative content creation that engages and informs\n- Professional customer service with problem-solving focus\n\nWhen interacting with users:\n1. Listen carefully and ask clarifying questions\n2. Provide clear, helpful responses in appropriate language\n3. Offer additional resources and next steps\n4. Maintain a positive, professional tone throughout\n5. Escalate complex issues to appropriate specialists\n\nAlways prioritize user satisfaction and clear communication.\n</code></pre> <p>Skills and Capabilities - Advanced language processing and generation - Customer service and communication - Content creation and editing - User experience optimization - Brand voice and style management</p>"},{"location":"agents/hero-types.html#choosing-the-right-hero-type","title":"Choosing the Right Hero Type","text":""},{"location":"agents/hero-types.html#decision-framework","title":"Decision Framework","text":"<p>Choose Director When: - Your task involves coordinating multiple steps or agents - Strategic decision-making is required - You need to manage workflows and processes - Resource allocation and prioritization are important - The solution requires orchestrating different specialists</p> <p>Choose Worker When: - Your task requires specific tools or integrations - Detailed, specialized work is the primary function - You need to process data or interact with external systems - Technical expertise in a specific domain is crucial - Consistent, reliable execution of specific operations is needed</p> <p>Choose Speaker When: - Communication and user interaction are primary functions - Content creation and natural language processing are key - You need to interface between technical systems and users - Creative or educational content development is required - Customer service and support are the main use cases</p>"},{"location":"agents/hero-types.html#multi-type-considerations","title":"Multi-Type Considerations","text":"<p>Hybrid Scenarios Sometimes your use case might seem to fit multiple types. Consider:</p> <ul> <li>Primary Function: What is the agent's main responsibility?</li> <li>User Interface: How will other agents or users interact with it?</li> <li>Tool Requirements: Does it need specialized integrations?</li> <li>Communication Needs: Is natural language interaction crucial?</li> </ul> <p>Team Composition The most powerful Artinet implementations often combine all three types: - Directors coordinate overall strategy and workflow - Workers handle specialized technical operations - Speakers manage communication and user interaction</p>"},{"location":"agents/hero-types.html#best-practices","title":"Best Practices","text":""},{"location":"agents/hero-types.html#agent-design-principles","title":"Agent Design Principles","text":"<p>Single Responsibility Each agent should excel at one primary function aligned with its Hero Type.</p> <p>Clear Interfaces Agent skills and descriptions should clearly indicate how other agents can interact with them.</p> <p>Type-Appropriate Optimization Configure model parameters, integrations, and capabilities based on the Hero Type requirements.</p> <p>Collaborative Design Design agents to work well with other types in multi-agent workflows.</p>"},{"location":"agents/hero-types.html#common-pitfalls","title":"Common Pitfalls","text":"<p>Type Misalignment - Don't use a Speaker for data processing tasks - Avoid using Workers for strategic coordination - Don't burden Directors with detailed execution work</p> <p>Over-Engineering - Keep each agent focused on its Hero Type strengths - Don't try to make one agent do everything - Use multiple specialized agents rather than one complex agent</p> <p>Under-Specification - Provide clear, detailed skills and descriptions - Configure appropriate tools and integrations - Set realistic performance expectations</p>"},{"location":"agents/hero-types.html#migration-and-evolution","title":"Migration and Evolution","text":""},{"location":"agents/hero-types.html#from-custom-agents","title":"From Custom Agents","text":"<p>If you have existing custom agents, consider which Hero Type they most closely align with and refactor accordingly.</p>"},{"location":"agents/hero-types.html#scaling-strategies","title":"Scaling Strategies","text":"<p>As your agent ecosystem grows: - Use Directors to manage increasing complexity - Add specialized Workers for new domains or tools - Deploy Speakers for improved user experience</p>"},{"location":"agents/hero-types.html#performance-optimization","title":"Performance Optimization","text":"<p>Monitor agent performance and adjust Hero Type selection and configuration based on real-world usage patterns.</p> <p>\ud83c\udfad Hero Types Mastery: The Hero Types system transforms agent development from complex custom coding into strategic role selection, enabling anyone to build sophisticated multi-agent systems with minimal technical complexity. </p>"},{"location":"agents/test-and-deploy.html","title":"Test and Deploy","text":"<p>Once you've created your agent, thorough testing is essential before deployment. This guide covers the complete testing and deployment process, ensuring your agent performs reliably in production environments.</p>"},{"location":"agents/test-and-deploy.html#testing-your-agent","title":"Testing Your Agent","text":""},{"location":"agents/test-and-deploy.html#pre-deployment-testing","title":"Pre-Deployment Testing","text":"<p>Before deploying your agent to the live environment, use Artinet's built-in testing features to validate functionality and performance.</p>"},{"location":"agents/test-and-deploy.html#test-environment-access","title":"Test Environment Access","text":"<p>Navigate to your agent's dashboard and select \"Test Mode\" to access the sandboxed testing environment. This provides: - Isolated testing environment - Safe space for validation without affecting production - Access to simulated tools and integrations - Performance monitoring during tests</p>"},{"location":"agents/test-and-deploy.html#testing-different-scenarios","title":"Testing Different Scenarios","text":"<p>For Director Agents: - Test multi-agent coordination scenarios - Validate task delegation capabilities - Check decision-making logic with various inputs - Ensure proper workflow orchestration</p> <p>For Worker Agents: - Test all configured MCP tools and integrations - Validate data processing with sample datasets - Check API connections and error handling - Ensure tool authentication is working properly</p> <p>For Speaker Agents: - Test conversational flows with various user inputs - Validate content generation quality and consistency - Check response appropriateness and tone - Test edge cases and unexpected inputs</p>"},{"location":"agents/test-and-deploy.html#testing-best-practices","title":"Testing Best Practices","text":""},{"location":"agents/test-and-deploy.html#input-validation-testing","title":"Input Validation Testing","text":"<ol> <li>Valid Inputs: Test with expected input formats and content</li> <li>Edge Cases: Test with boundary conditions and unusual but valid inputs</li> <li>Invalid Inputs: Ensure graceful handling of incorrect or malformed inputs</li> <li>Empty/Null Inputs: Verify behavior with missing or empty data</li> </ol>"},{"location":"agents/test-and-deploy.html#integration-testing","title":"Integration Testing","text":"<ul> <li>Tool Connectivity: Verify all MCP tools are accessible and functional</li> <li>API Responses: Test with real API responses and simulated failures</li> <li>Data Flow: Ensure data passes correctly between agent and external systems</li> <li>Authentication: Validate all security tokens and access permissions</li> </ul>"},{"location":"agents/test-and-deploy.html#performance-testing","title":"Performance Testing","text":"<ul> <li>Response Time: Monitor agent response times under various loads</li> <li>Resource Usage: Check memory and processing requirements</li> <li>Concurrent Operations: Test handling of multiple simultaneous requests</li> <li>Timeout Handling: Ensure proper behavior when external services are slow</li> </ul>"},{"location":"agents/test-and-deploy.html#deployment-process","title":"Deployment Process","text":""},{"location":"agents/test-and-deploy.html#pre-deployment-checklist","title":"Pre-Deployment Checklist","text":"<p>Before deploying your agent, ensure:</p> <ul> <li>[ ] All tests pass successfully</li> <li>[ ] Agent Skills and Description are clear and actionable</li> <li>[ ] Required integrations are properly configured</li> <li>[ ] Security settings are appropriate for the intended use</li> <li>[ ] Performance metrics meet expected requirements</li> <li>[ ] Error handling is implemented for all failure scenarios</li> </ul>"},{"location":"agents/test-and-deploy.html#deployment-steps","title":"Deployment Steps","text":""},{"location":"agents/test-and-deploy.html#1-review-configuration","title":"1. Review Configuration","text":"<p>Double-check all agent settings: - Hero Type is appropriate for intended role - Model settings match performance requirements - Integration access is properly configured - Security permissions follow principle of least privilege</p>"},{"location":"agents/test-and-deploy.html#2-deploy-to-production","title":"2. Deploy to Production","text":"<ol> <li>Navigate to your agent's dashboard</li> <li>Click \"Deploy to Production\"</li> <li>Review deployment summary</li> <li>Confirm deployment settings</li> <li>Monitor deployment progress</li> </ol>"},{"location":"agents/test-and-deploy.html#3-post-deployment-verification","title":"3. Post-Deployment Verification","text":"<p>After deployment: - Verify agent appears in \"My Agents\" section - Test basic functionality in production environment - Monitor initial performance metrics - Check integration connectivity</p>"},{"location":"agents/test-and-deploy.html#my-agents-dashboard","title":"My Agents Dashboard","text":"<p>After successful deployment, your agent will be visible in the \"My Agents\" section of your dashboard. Here you can:</p>"},{"location":"agents/test-and-deploy.html#agent-management","title":"Agent Management","text":"<ul> <li>Status Monitoring: View agent health and availability</li> <li>Performance Metrics: Monitor response times and success rates</li> <li>Usage Statistics: Track agent interactions and workload</li> <li>Error Logs: Review any issues or failures</li> </ul>"},{"location":"agents/test-and-deploy.html#configuration-updates","title":"Configuration Updates","text":"<ul> <li>Settings Modification: Update agent parameters without redeployment</li> <li>Integration Management: Add, remove, or modify tool connections</li> <li>Access Control: Manage who can interact with your agent</li> <li>Version Control: Track changes and rollback if needed</li> </ul>"},{"location":"agents/test-and-deploy.html#workflow-integration","title":"Workflow Integration","text":"<ul> <li>Grid Visibility: Your deployed agents become available for grid workflows</li> <li>Connection Status: Monitor connections to other agents</li> <li>Collaboration Metrics: Track multi-agent interactions</li> </ul>"},{"location":"agents/test-and-deploy.html#post-deployment-best-practices","title":"Post-Deployment Best Practices","text":""},{"location":"agents/test-and-deploy.html#monitoring-and-maintenance","title":"Monitoring and Maintenance","text":""},{"location":"agents/test-and-deploy.html#performance-monitoring","title":"Performance Monitoring","text":"<ul> <li>Set up alerts for performance degradation</li> <li>Monitor resource usage trends</li> <li>Track error rates and response times</li> <li>Review usage patterns regularly</li> </ul>"},{"location":"agents/test-and-deploy.html#regular-updates","title":"Regular Updates","text":"<ul> <li>Keep agent skills and descriptions current</li> <li>Update integrations as APIs change</li> <li>Refine prompts based on real-world usage</li> <li>Apply security patches promptly</li> </ul>"},{"location":"agents/test-and-deploy.html#user-feedback","title":"User Feedback","text":"<ul> <li>Collect feedback from agent interactions</li> <li>Monitor satisfaction scores</li> <li>Identify areas for improvement</li> <li>Iterate based on real usage patterns</li> </ul>"},{"location":"agents/test-and-deploy.html#scaling-considerations","title":"Scaling Considerations","text":"<p>As your agent usage grows: - Resource Allocation: Monitor and adjust compute resources - Rate Limiting: Implement appropriate usage limits - Load Distribution: Consider deploying multiple instances - Caching: Implement caching for frequently requested operations</p>"},{"location":"agents/test-and-deploy.html#troubleshooting-common-issues","title":"Troubleshooting Common Issues","text":""},{"location":"agents/test-and-deploy.html#agent-not-appearing-in-my-agents","title":"Agent Not Appearing in My Agents","text":"<ul> <li>Check deployment completion status</li> <li>Verify account permissions</li> <li>Refresh browser cache</li> <li>Contact support if issue persists</li> </ul>"},{"location":"agents/test-and-deploy.html#integration-failures","title":"Integration Failures","text":"<ul> <li>Verify API keys and authentication tokens</li> <li>Check network connectivity and firewall settings</li> <li>Review integration logs for specific error messages</li> <li>Test integrations individually in test mode</li> </ul>"},{"location":"agents/test-and-deploy.html#performance-issues","title":"Performance Issues","text":"<ul> <li>Monitor resource usage during peak times</li> <li>Check for inefficient operations or queries</li> <li>Review model settings and adjust if necessary</li> <li>Consider optimizing prompts for better performance</li> </ul>"},{"location":"agents/test-and-deploy.html#advanced-deployment-options","title":"Advanced Deployment Options","text":""},{"location":"agents/test-and-deploy.html#blue-green-deployment","title":"Blue-Green Deployment","text":"<p>For critical agents, consider blue-green deployments: 1. Deploy new version alongside existing version 2. Test new version with limited traffic 3. Gradually shift traffic to new version 4. Retire old version after validation</p>"},{"location":"agents/test-and-deploy.html#staged-rollout","title":"Staged Rollout","text":"<ul> <li>Deploy to test environment first</li> <li>Limited production rollout to subset of users</li> <li>Monitor metrics and gather feedback</li> <li>Full rollout after validation</li> </ul>"},{"location":"agents/test-and-deploy.html#rollback-procedures","title":"Rollback Procedures","text":"<p>Always have a rollback plan: - Keep previous working version available - Document rollback procedures - Set up automated rollback triggers for critical failures - Test rollback procedures regularly</p>"},{"location":"agents/test-and-deploy.html#next-steps","title":"Next Steps","text":"<p>After successful deployment: - Grid Management - Learn about workflow integration - API Key Management - Secure your agent access - Hero Types - Deep dive into the three agent types</p> <p>\ud83d\ude80 Deployment Success: Once deployed, your agent becomes part of the broader Artinet ecosystem and can collaborate with other agents to solve complex problems. </p>"},{"location":"api/index.html","title":"API Reference","text":"<p>This section provides a comprehensive reference for the Artinet SDK Core API components. The SDK implements the Agent2Agent (A2A) Protocol and provides enhanced functionality for building interoperable AI agents.</p>"},{"location":"api/index.html#overview","title":"Overview","text":"<p>The Artinet SDK API is organized into several key component categories:</p> Client APIServer APIStorage APIAdvanced <ul> <li><code>A2AClient</code> - For sending tasks to and receiving responses from agents</li> <li>Task submission and streaming</li> <li>Push notification handling</li> </ul> <ul> <li><code>A2AServer</code> - For hosting and implementing agent behavior</li> <li>Task processing and state management</li> <li>Server registration</li> </ul> <ul> <li><code>InMemoryTaskStore</code> - For development</li> <li><code>FileTaskStore</code> - For production</li> <li>Custom store implementations</li> </ul> <ul> <li>Task handling customization</li> <li>Express middleware integration</li> <li>Runtime configuration</li> </ul> <p>TypeScript Support</p> <p>The Artinet SDK is fully written in TypeScript with comprehensive type definitions for a robust developer experience.</p>"},{"location":"api/index.html#client-api","title":"Client API","text":""},{"location":"api/index.html#a2aclient","title":"A2AClient","text":"<p>The primary class for interacting with A2A-compliant agent servers.</p> <pre><code>class A2AClient {\n  /**\n   * Creates a new A2AClient instance.\n   * @param baseUrl The base URL of the A2A-compliant server\n   * @param headers Optional custom headers to include in requests\n   * @param fallbackPath Optional path for retrieving the agent card if the standard path fails\n   */\n  constructor(\n    baseUrl: string | URL,\n    headers?: Record&lt;string, string&gt;,\n    fallbackPath?: string\n  );\n\n  /**\n   * Adds a single HTTP header to requests.\n   * @param key The header name\n   * @param value The header value\n   */\n  addHeader(key: string, value: string): void;\n\n  /**\n   * Sets multiple HTTP headers, replacing any existing headers.\n   * @param headers Key-value pairs of headers\n   */\n  setHeaders(headers: Record&lt;string, string&gt;): void;\n\n  /**\n   * Removes a specific HTTP header.\n   * @param name The header name to remove\n   */\n  removeHeader(name: string): void;\n\n  /**\n   * Clears all custom HTTP headers.\n   */\n  clearHeaders(): void;\n\n  /**\n   * Sends a task and returns the final result.\n   * @param params The task parameters\n   * @returns A Promise resolving to the completed task\n   */\n  async sendMessage(params: MessageSendParams): Promise&lt;Task | null&gt;;\n\n  /**\n   * Retrieves information about an existing task.\n   * @param params The task parameters including task ID\n   * @returns A Promise resolving to the task\n   */\n  async getTask(params: TaskQueryParams): Promise&lt;Task | null&gt;;\n\n  /**\n   * Cancels an in-progress task.\n   * @param params The task parameters including task ID\n   */\n  async cancelTask(params: TaskIdParams): Promise&lt;Task | null&gt;;\n\n  /**\n   * Sends a task and subscribes to streaming updates.\n   * @param params The task parameters\n   * @returns An AsyncIterable yielding status and artifact updates\n   */\n  sendStreamingMessage(params: MessageSendParams): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\n\n  /**\n   * Resubscribes to updates for an existing task.\n   * @param params The resubscribe parameters including task ID\n   * @returns An AsyncIterable yielding status and artifact updates\n   */\n  resubscribeTask(params: TaskQueryParams): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\n\n  /**\n   * Configures push notifications for a task.\n   * @param params The push notification parameters\n   */\n  async setTaskPushNotification(params: TaskPushNotificationConfig): Promise&lt;TaskPushNotificationConfig | null&gt;;\n\n  /**\n   * Retrieves push notification configuration for a task.\n   * @param params The parameters including task ID\n   * @returns The push notification configuration\n   */\n  async getTaskPushNotification(params: TaskIdParams): Promise&lt;TaskPushNotificationConfig | null&gt;;\n\n  /**\n   * Retrieves the agent card describing the server's capabilities.\n   * @returns A Promise resolving to the agent card\n   */\n  async agentCard(): Promise&lt;AgentCard&gt;;\n\n  /**\n   * Refreshes the cached agent card.\n   * @returns A Promise resolving to the refreshed agent card\n   */\n  async refreshAgentCard(): Promise&lt;AgentCard&gt;;\n\n  /**\n   * Checks if the server supports a specific capability.\n   * @param capability The capability to check\n   * @returns A Promise resolving to a boolean indicating support\n   */\n  async supports(capability: \"streaming\" | \"pushNotifications\" | \"stateTransitionHistory\"): Promise&lt;boolean&gt;;\n}\n</code></pre>"},{"location":"api/index.html#rpcerror","title":"RpcError","text":"<p>Represents client-side errors encountered during A2A communication.</p> <pre><code>class SystemError&lt;ErrorData = unknown, C extends number = number&gt; extends Error {\n  /**\n   * The error code (typically a JSON-RPC error code)\n   */\n  code: C;\n\n  /**\n   * Additional error data, if any\n   */\n  data: ErrorData;\n\n  /**\n   * Creates a new SystemError.\n   * @param message The error message\n   * @param code The error code\n   * @param data Additional error data\n   */\n  constructor(message: string, code: C, data: ErrorData);\n}\n</code></pre>"},{"location":"api/index.html#server-api","title":"Server API","text":""},{"location":"api/index.html#a2aserver","title":"A2AServer","text":"<p>The core server class for hosting A2A-compliant agents.</p> <pre><code>class A2AServer {\n  /**\n   * Creates a new A2AServer instance.\n   * @param params Configuration parameters\n   */\n  constructor(params: A2AServerParams);\n\n  /**\n   * Starts the server, making it available to accept requests.\n   * @returns The Express application instance\n   */\n  start(): express.Express;\n\n  /**\n   * Stops the server, closing all connections.\n   * @returns A Promise that resolves when the server is stopped\n   */\n  stop(): Promise&lt;void&gt;;\n\n  /**\n   * Gets the underlying Express application instance.\n   * Useful for advanced customization.\n   * @returns The Express application\n   */\n  getExpressApp(): express.Express;\n\n  /**\n   * Registers the server with the A2A registry.\n   * @returns A Promise resolving to the registration ID\n   */\n  registerServer(): Promise&lt;string&gt;;\n\n  /**\n   * Gets the base path for the server.\n   * @returns The base path\n   */\n  getBasePath(): string;\n\n  /**\n   * Gets the CORS options for the server.\n   * @returns The CORS options\n   */\n  getCorsOptions(): CorsOptions;\n\n  /**\n   * Gets the agent card for the server.\n   * @returns The agent card\n   */\n  getCard(): AgentCard;\n\n  /**\n   * Gets the task store.\n   * @returns The task store\n   */\n  getTaskStore(): TaskStore;\n\n  /**\n   * Gets the task handler.\n   * @returns The task handler\n   */\n  getTaskHandler(): TaskHandler;\n\n  /**\n   * Gets the active cancellations set.\n   * @returns The set of active cancellations\n   */\n  getActiveCancellations(): Set&lt;string&gt;;\n\n  /**\n   * Gets the active streams map.\n   * @returns The map of active streams\n   */\n  getActiveStreams(): Map&lt;string, Response[]&gt;;\n\n  /**\n   * Gets the port number.\n   * @returns The port number\n   */\n  getPort(): number;\n}\n</code></pre>"},{"location":"api/index.html#a2aserverparams","title":"A2AServerParams","text":"<p>Configuration interface for the A2AServer constructor.</p> <pre><code>interface A2AServerParams {\n  /**\n   * The task handler function that implements agent logic\n   */\n  handler: TaskHandler;\n\n  /**\n   * The storage implementation for persisting tasks\n   */\n  taskStore?: TaskStore;\n\n  /**\n   * Metadata about the agent's capabilities\n   */\n  card?: AgentCard;\n\n  /**\n   * Port number to listen on (default: 41241)\n   */\n  port?: number;\n\n  /**\n   * Host address to bind to (default: '0.0.0.0')\n   */\n  host?: string;\n\n  /**\n   * Base URL path for API endpoints (default: '/')\n   */\n  basePath?: string;\n\n  /**\n   * Alternative path for agent card (default: '/agent-card')\n   */\n  fallbackPath?: string;\n\n  /**\n   * Whether to register this agent with the Artinet registry (default: false)\n   */\n  register?: boolean;\n\n  /**\n   * Custom JSON-RPC server factory for advanced usage\n   */\n  createJSONRPCServer?: JSONRPCServerFactory;\n\n  /**\n   * CORS options for the server\n   */\n  corsOptions?: CorsOptions;\n\n  /**\n   * Logging verbosity level (default: LogLevel.info)\n   */\n  logLevel?: LogLevel;\n}\n</code></pre>"},{"location":"api/index.html#task-handling-api","title":"Task Handling API","text":""},{"location":"api/index.html#taskhandler","title":"TaskHandler","text":"<p>The core type for defining agent logic.</p> <pre><code>/**\n * An asynchronous generator function that processes tasks and yields updates.\n * @param context The context containing task information\n * @returns An AsyncGenerator that yields status and artifact updates\n */\ntype TaskHandler = (\n  context: TaskContext\n) =&gt; AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt;;\n</code></pre>"},{"location":"api/index.html#taskcontext","title":"TaskContext","text":"<p>Provides task details to the TaskHandler.</p> <pre><code>interface TaskContext {\n  /**\n   * The Task being processed\n   */\n  readonly task: Task;\n\n  /**\n   * The message from the user that initiated this task\n   */\n  readonly userMessage: Message;\n\n  /**\n   * Message history for this task (if available)\n   */\n  readonly history: Message[];\n\n  /**\n   * Function to check if the task has been cancelled\n   * @returns true if the task is cancelled, false otherwise\n   */\n  isCancelled(): boolean;\n}\n</code></pre>"},{"location":"api/index.html#taskyieldupdate","title":"TaskYieldUpdate","text":"<p>Union type for updates yielded by a TaskHandler.</p> <pre><code>/**\n * Represents either a status update or an artifact creation\n */\ntype TaskYieldUpdate = \n  /**\n   * Status update with optional message\n   */\n  | { state: TaskStatus[\"state\"]; message?: Message }\n\n  /**\n   * Artifact creation\n   */\n  | { name: string; parts: Part[]; mimeType?: string };\n</code></pre>"},{"location":"api/index.html#storage-api","title":"Storage API","text":""},{"location":"api/index.html#taskstore","title":"TaskStore","text":"<p>Interface for task persistence implementations.</p> <pre><code>interface TaskStore {\n  /**\n   * Saves a task and its associated message history.\n   * @param data An object containing the task and its history\n   * @returns A promise resolving when the save operation is complete\n   */\n  save(data: TaskAndHistory): Promise&lt;void&gt;;\n\n  /**\n   * Loads a task and its history by task ID.\n   * @param taskId The ID of the task to load\n   * @returns A promise resolving to an object containing the Task and its history, or null if not found\n   */\n  load(taskId: string): Promise&lt;TaskAndHistory | null&gt;;\n}\n</code></pre>"},{"location":"api/index.html#taskandhistory","title":"TaskAndHistory","text":"<p>Interface representing a task and its associated message history.</p> <pre><code>interface TaskAndHistory {\n  /**\n   * The task object\n   */\n  task: Task;\n\n  /**\n   * The complete message history associated with the task\n   */\n  history: Message[];\n}\n</code></pre>"},{"location":"api/index.html#inmemorytaskstore","title":"InMemoryTaskStore","text":"<p>Simple in-memory task persistence for development/testing.</p> <pre><code>class InMemoryTaskStore implements TaskStore {\n  /**\n   * Creates a new InMemoryTaskStore\n   */\n  constructor();\n\n  /**\n   * Saves a task and its associated message history.\n   * @param data An object containing the task and its history\n   */\n  save(data: TaskAndHistory): Promise&lt;void&gt;;\n\n  /**\n   * Loads a task and its history by task ID.\n   * @param taskId The ID of the task to load\n   * @returns A promise resolving to the task and history, or null if not found\n   */\n  load(taskId: string): Promise&lt;TaskAndHistory | null&gt;;\n}\n</code></pre>"},{"location":"api/index.html#filestore","title":"FileStore","text":"<p>File-based task persistence that stores task data in the filesystem.</p> <pre><code>class FileStore implements TaskStore {\n  /**\n   * Creates a new FileStore\n   * @param dataDirectory Path to the directory for storing task files\n   */\n  constructor(dataDirectory: string);\n\n  /**\n   * Saves a task and its associated message history.\n   * @param data An object containing the task and its history\n   */\n  save(data: TaskAndHistory): Promise&lt;void&gt;;\n\n  /**\n   * Loads a task and its history by task ID.\n   * @param taskId The ID of the task to load\n   * @returns A promise resolving to the task and history, or null if not found\n   */\n  load(taskId: string): Promise&lt;TaskAndHistory | null&gt;;\n}\n</code></pre>"},{"location":"api/index.html#logging-api","title":"Logging API","text":""},{"location":"api/index.html#logger","title":"logger","text":"<p>Built-in structured logger based on Pino.</p> <pre><code>/**\n * The main logger instance for the SDK\n */\nconst logger: Logger;\n</code></pre>"},{"location":"api/index.html#configurelogger","title":"configureLogger","text":"<p>Function to configure the logging level and other options.</p> <pre><code>/**\n * Configures the global logger's settings\n * @param options Configuration options\n */\nfunction configureLogger(options: { level?: LogLevel, name?: string, prettyPrint?: boolean }): Logger;\n</code></pre>"},{"location":"api/index.html#log-helper-functions","title":"Log Helper Functions","text":"<pre><code>/**\n * Logs a message at DEBUG level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param data Optional data to include\n */\nfunction logDebug(context: string, message: string, data?: unknown): void;\n\n/**\n * Logs a message at INFO level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param data Optional data to include\n */\nfunction logInfo(context: string, message: string, data?: unknown): void;\n\n/**\n * Logs a message at WARN level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param data Optional data to include\n */\nfunction logWarn(context: string, message: string, data?: unknown): void;\n\n/**\n * Logs a message at ERROR level with context\n * @param context Name of the component generating the log\n * @param message The log message\n * @param error The error object\n * @param data Optional additional data\n */\nfunction logError(context: string, message: string, error: unknown, data?: unknown): void;\n</code></pre>"},{"location":"api/index.html#loglevel","title":"LogLevel","text":"<p>Type defining logging levels.</p> <pre><code>type LogLevel = \"silent\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\";\n</code></pre>"},{"location":"api/index.html#advanced-customization-api","title":"Advanced Customization API","text":""},{"location":"api/index.html#jsonrpcserverfactory","title":"JSONRPCServerFactory","text":"<p>Function signature for providing custom JSON-RPC server creation logic.</p> <pre><code>/**\n * Factory function for creating a custom JSON-RPC server\n * @param params Parameters with dependencies needed for server creation\n * @returns A configured JSON-RPC server\n */\ntype JSONRPCServerFactory = (\n  params: CreateJSONRPCServerParams\n) =&gt; JSONRPCServerType;\n</code></pre>"},{"location":"api/index.html#createjsonrpcserverparams","title":"CreateJSONRPCServerParams","text":"<p>Object containing dependencies provided to a JSONRPCServerFactory function.</p> <pre><code>interface CreateJSONRPCServerParams {\n  /**\n   * The task handler function\n   */\n  taskHandler: TaskHandler;\n\n  /**\n   * The storage implementation\n   */\n  taskStore: TaskStore;\n\n  /**\n   * The agent's metadata\n   */\n  card: AgentCard;\n\n  /**\n   * Set of active task cancellations\n   */\n  activeCancellations: Set&lt;string&gt;;\n\n  /**\n   * Function to create a TaskContext for a task\n   */\n  createTaskContext: (task: Task, message: Message, history: Message[]) =&gt; TaskContext;\n\n  /**\n   * Function to close all streams for a task\n   */\n  closeStreamsForTask: (taskId: string) =&gt; void;\n}\n</code></pre>"},{"location":"api/index.html#method-type-definitions","title":"Method Type Definitions","text":"<pre><code>/**\n * Type definition for the tasks/send method handler\n */\ntype SendTaskMethod = A2AMethodHandler&lt;\n  SendTaskRequest[\"params\"],\n  SendTaskResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/get method handler\n */\ntype GetTaskMethod = A2AMethodHandler&lt;\n  GetTaskRequest[\"params\"],\n  GetTaskResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/cancel method handler\n */\ntype CancelTaskMethod = A2AMethodHandler&lt;\n  CancelTaskRequest[\"params\"],\n  CancelTaskResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/pushNotification/set method handler\n */\ntype SetTaskPushNotificationMethod = A2AMethodHandler&lt;\n  SetTaskPushNotificationRequest[\"params\"],\n  SetTaskPushNotificationResponse | null\n&gt;;\n\n/**\n * Type definition for the tasks/pushNotification/get method handler\n */\ntype GetTaskPushNotificationMethod = A2AMethodHandler&lt;\n  GetTaskPushNotificationRequest[\"params\"],\n  GetTaskPushNotificationResponse | null\n&gt;;\n</code></pre>"},{"location":"api/index.html#createjsonrpcmethod","title":"createJSONRPCMethod","text":"<p>Helper function for creating JSON-RPC method handlers.</p> <pre><code>/**\n * Creates a JSON-RPC method with dependency injection and error handling\n * @param deps The dependency parameters\n * @param methodImpl The method implementation\n * @param methodName The name of the method\n * @returns A configured JSON-RPC method handler\n */\nfunction createJSONRPCMethod&lt;\n  Params extends RequestParams,\n  Result extends A2AResponse | null,\n&gt;(\n  deps: CreateJSONRPCServerParams,\n  methodImpl: A2AMethodHandler&lt;Params, Result&gt;,\n  methodName: string\n): (params: Params, callback: JSONRPCCallback&lt;Result&gt;) =&gt; void;\n</code></pre>"},{"location":"api/index.html#quick-agent-api","title":"Quick Agent API","text":""},{"location":"api/index.html#bundle","title":"bundle","text":"<p>Bundles agent code for deployment.</p> <pre><code>/**\n * Bundles an agent's code and dependencies into a single file\n * @param fileUrl URL to the agent's main file\n * @returns A Promise resolving to the bundled code as a string\n */\nfunction bundle(fileUrl: URL): Promise&lt;string&gt;;\n</code></pre>"},{"location":"api/index.html#taskhandlerproxy","title":"taskHandlerProxy","text":"<p>Simplifies agent implementation for quick agents.</p> <pre><code>/**\n * Wraps agent logic for use in managed environments\n * @param agentLogic The agent's main function\n * @returns A Promise that resolves when the agent completes\n */\nfunction taskHandlerProxy(\n  agentLogic: (context: TaskContext) =&gt; AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt;\n): Promise&lt;void&gt;;\n</code></pre>"},{"location":"api/index.html#fetchresponseproxy","title":"fetchResponseProxy","text":"<p>Enables communication between quick agents.</p> <pre><code>/**\n * Fetches a response from another agent in the Artinet ecosystem\n * @param agentID Name of the agent to call\n * @param messages Array of message objects to send to the target agent\n * @returns A Promise resolving to the agent's response string\n */\nfunction fetchResponseProxy(\n  agentID: string,\n  messages: { role: string; content: string }[]\n): Promise&lt;string&gt;;\n</code></pre>"},{"location":"api/index.html#testdeployment","title":"testDeployment","text":"<p>Tests a deployment in a temporary sandbox environment.</p> <pre><code>/**\n * Tests an agent deployment in a sandboxed environment\n * @param params Deployment parameters including the agent code\n * @param requests Test requests to send to the deployed agent\n * @returns An AsyncGenerator yielding deployment responses\n */\nfunction testDeployment(\n  params: ServerDeploymentRequestParams,\n  requests: SendTaskRequest[]\n): AsyncGenerator&lt;Task | ServerDeploymentResponse | null&gt;;\n</code></pre>"},{"location":"api/index.html#deployment-types","title":"Deployment Types","text":"<pre><code>/**\n * Parameters for agent deployment\n */\ninterface ServerDeploymentRequestParams {\n  /**\n   * The bundled agent code\n   */\n  code: string;\n\n  /**\n   * Name of the agent\n   */\n  name: string;\n\n  /**\n   * The agent card defining capabilities and metadata\n   */\n  agentCard: AgentCard;\n\n  /**\n   * Optional NPM dependencies\n   */\n  dependencies?: string[];\n}\n\n/**\n * Response from a deployment test\n */\ninterface ServerDeploymentResponse {\n  /**\n   * The deployment ID\n   */\n  deploymentId: string;\n\n  /**\n   * Whether the deployment was successful \n   */\n  success: boolean;\n\n  /**\n   * The name of the server (if successful)\n   */\n  name?: string;\n\n  /**\n   * The URL of the server (if successful)\n   */\n  url?: string;\n\n  /**\n   * The base path of the server (if successful)\n   */\n  basePath?: string;\n}\n</code></pre>"},{"location":"api/index.html#core-types","title":"Core Types","text":"<p>The SDK includes comprehensive TypeScript definitions for all A2A Protocol types. Here are the most important ones:</p>"},{"location":"api/index.html#agentcard","title":"AgentCard","text":"<p>Describes the agent's capabilities, metadata, skills, and endpoint URL.</p> <pre><code>interface AgentCard {\n  /**\n   * The name of the agent\n   */\n  name: string;\n\n  /**\n   * The URL where the agent can be reached\n   */\n  url: string;\n\n  /**\n   * The agent's version\n   */\n  version: string;\n\n  /**\n   * Description of the agent's purpose\n   */\n  description?: string;\n\n  /**\n   * The agent's capabilities\n   */\n  capabilities: {\n    /**\n     * Whether the agent supports streaming\n     */\n    streaming?: boolean;\n\n    /**\n     * Whether the agent supports push notifications\n     */\n    pushNotifications?: boolean;\n\n    /**\n     * Whether the agent supports state transition history\n     */\n    stateTransitionHistory?: boolean;\n  };\n\n  /**\n   * Skills the agent provides\n   */\n  skills: Array&lt;{\n    /**\n     * Unique identifier for the skill\n     */\n    id: string;\n\n    /**\n     * Human-readable name for the skill\n     */\n    name: string;\n\n    /**\n     * Description of what the skill does\n     */\n    description?: string;\n  }&gt;;\n}\n</code></pre>"},{"location":"api/index.html#task","title":"Task","text":"<p>Represents the state and metadata of an A2A task.</p> <pre><code>interface Task {\n  /**\n   * Unique identifier for the task\n   */\n  id: string;\n\n  /**\n   * Current status of the task\n   */\n  status: TaskStatus;\n\n  /**\n   * Optional message that initiated this task\n   */\n  message?: Message;\n\n  /**\n   * Optional session identifier\n   */\n  sessionId?: string;\n\n  /**\n   * Custom metadata associated with the task\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n\n  /**\n   * Artifacts generated during task execution\n   */\n  artifacts?: Artifact[];\n}\n</code></pre>"},{"location":"api/index.html#message","title":"Message","text":"<p>Represents a message in the A2A protocol.</p> <pre><code>interface Message {\n  /**\n   * Who sent the message\n   */\n  role: \"user\" | \"agent\";\n\n  /**\n   * Content parts of the message\n   */\n  parts: Part[];\n\n  /**\n   * Optional metadata about the message\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"api/index.html#part","title":"Part","text":"<p>Represents a part of a message in the A2A protocol.</p> <pre><code>type Part = TextPart | FilePart | DataPart;\n\ninterface TextPart {\n  /**\n   * Type identifier\n   */\n  type: \"text\";\n\n  /**\n   * Text content\n   */\n  text: string;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n\ninterface FilePart {\n  /**\n   * Type identifier\n   */\n  type: \"file\";\n\n  /**\n   * File content\n   */\n  file: FileContent;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n\ninterface DataPart {\n  /**\n   * Type identifier\n   */\n  type: \"data\";\n\n  /**\n   * Structured data\n   */\n  data: Record&lt;string, unknown&gt;;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"api/index.html#artifact","title":"Artifact","text":"<p>Represents an artifact generated during a task.</p> <pre><code>interface Artifact {\n  /**\n   * Name of the artifact\n   */\n  name?: string;\n\n  /**\n   * Description of the artifact\n   */\n  description?: string;\n\n  /**\n   * MIME type of the artifact\n   */\n  mimeType?: string;\n\n  /**\n   * Content parts of the artifact\n   */\n  parts: Part[];\n\n  /**\n   * Optional index for ordering\n   */\n  index?: number;\n\n  /**\n   * Whether to append to existing content\n   */\n  append?: boolean;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n\n  /**\n   * Whether this is the last chunk\n   */\n  lastChunk?: boolean;\n}\n</code></pre>"},{"location":"api/index.html#taskstatus","title":"TaskStatus","text":"<p>Represents the status of an A2A task.</p> <pre><code>interface TaskStatus {\n  /**\n   * Current state of the task\n   */\n  state: TaskState;\n\n  /**\n   * Optional message describing the status\n   */\n  message?: Message;\n\n  /**\n   * Timestamp when the status was recorded\n   */\n  timestamp?: string;\n}\n</code></pre>"},{"location":"api/index.html#stream-event-types","title":"Stream Event Types","text":"<pre><code>/**\n * Event emitted when a task's status changes\n */\ninterface TaskStatusUpdateEvent {\n  /**\n   * Task ID\n   */\n  id: string;\n\n  /**\n   * The new status\n   */\n  status: TaskStatus;\n\n  /**\n   * Whether this is the final update\n   */\n  final?: boolean;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n\n/**\n * Event emitted when a task generates an artifact\n */\ninterface TaskArtifactUpdateEvent {\n  /**\n   * Task ID\n   */\n  id: string;\n\n  /**\n   * The generated artifact\n   */\n  artifact: Artifact;\n\n  /**\n   * Whether this is the final update\n   */\n  final?: boolean;\n\n  /**\n   * Optional metadata\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"api/bundler.html","title":"Agent Bundler","text":""},{"location":"api/bundler.html#bundle","title":"bundle","text":"<p>Bundles a given JavaScript or TypeScript file into a single minified ES module string. This utility leverages <code>esbuild</code> for efficient bundling, minification, and sourcemap generation. It's designed to prepare agent code for deployment by packaging it and its local dependencies.</p> <p>@param filePath - The URL of the entry point file to bundle. @returns A promise that resolves to a string containing the bundled and minified code. @throws An error if the file path does not exist, is not a file, or if bundling fails for any reason.</p> <pre><code>(filePath: URL): Promise&lt;string&gt; {\n  const entryPath = fileURLToPath(filePath);\n  logDebug(\n    `bundler: `,\n    `Attempting to recursively read imports starting from:`,\n    entryPath\n  );\n  try {\n    const fs = await import(\"node:fs\");\n    const stats = fs.statSync(entryPath);\n    if (!stats.isFile()) {\n      logError(`bundler: `, `Filepath is not a file:`, entryPath);\n      throw new Error(\n        `// BUNDLING FAILED: Filepath is not a file: ${entryPath}`\n      );\n    }\n    logDebug(`bundler: `, `Filepath exists:`, entryPath);\n  } catch (err: any) {\n    logError(`bundler: `, `Filepath does not exist:`, entryPath);\n    throw new Error(\n      `// BUNDLING FAILED: Filepath does not exist: ${entryPath}`\n    );\n  }\n\n  try {\n    const result = await esbuild.build({\n      entryPoints: [entryPath],\n      bundle: true,\n      minify: true,\n      sourcemap: false,\n      platform: \"node\",\n      format: \"esm\",\n      write: false,\n    });\n    const output = result?.outputFiles?.[0]?.text ?? \"\";\n    logDebug(\n      `bundler: Successfully read and bundled code:`,\n      output.length.toString()\n    );\n    return output;\n  } catch (err: any) {\n    logError(`bundler: `, `Error during recursive read:`, err.message);\n    throw new Error(`// BUNDLING FAILED: ${err.message}`);\n  }\n}\n</code></pre>"},{"location":"api/client.html","title":"A2AClient","text":""},{"location":"api/client.html#a2aclient_1","title":"A2AClient","text":"<p>A2AClient is the main client class for interacting with Agent2Agent (A2A) protocol-compliant services. It provides methods for sending tasks, retrieving statuses, canceling operations, and handling streaming responses.</p> <pre><code>export class A2AClient implements Client {\n  private baseUrl: URL;\n  private cachedAgentCard: AgentCard | null = null;\n  private customHeaders: Record&lt;string, string&gt; = {};\n  private fallbackPath: string;\n  /**\n   * Creates a new A2AClient instance.\n   * @param baseUrl The base URL for the A2A server.\n   * @param headers Optional custom headers to include in all requests.\n   */\n  constructor(\n    baseUrl: URL | string,\n    headers: Record&lt;string, string&gt; = {},\n    fallbackPath?: string\n  ) {\n    this.baseUrl = typeof baseUrl === \"string\" ? new URL(baseUrl) : baseUrl;\n    this.customHeaders = headers;\n    this.fallbackPath = fallbackPath ?? \"/agent-card\";\n  }\n\n  /**\n   * Retrieves the AgentCard from the A2A server.\n   * Caches the result after the first successful fetch.\n   * @returns A promise resolving to the AgentCard.\n   */\n  async agentCard(): Promise&lt;AgentCard&gt; {\n    if (this.cachedAgentCard) {\n      return this.cachedAgentCard;\n    }\n\n    // Standard location for agent cards\n    const wellKnownUrl = new URL(\"/.well-known/agent.json\", this.baseUrl);\n    try {\n      try {\n        if (!URL.canParse(wellKnownUrl)) {\n          throw new Error(\"Invalid well-known URL\");\n        }\n        const card: AgentCard = await executeGetRequest&lt;AgentCard&gt;(\n          wellKnownUrl,\n          this.customHeaders,\n          \"agent card (well-known)\"\n        );\n        if (!card.name || card.name === null || card.name === undefined) {\n          throw new Error(\"No agent card found\");\n        }\n\n        this.cachedAgentCard = card as AgentCard;\n        return this.cachedAgentCard;\n      } catch (error) {\n        const fallbackUrl = new URL(this.fallbackPath, this.baseUrl);\n        const fallbackCard: AgentCard = await executeGetRequest&lt;AgentCard&gt;(\n          fallbackUrl,\n          this.customHeaders,\n          \"agent card (fallback)\"\n        );\n\n        if (\n          !fallbackCard.name ||\n          fallbackCard.name === null ||\n          fallbackCard.name === undefined\n        ) {\n          throw new Error(\"No fallback agent card found\");\n        }\n        this.cachedAgentCard = fallbackCard;\n\n        return this.cachedAgentCard;\n      }\n    } catch (error) {\n      logError(\n        \"A2AClient:agentCard\",\n        \"Failed to fetch or parse agent card:\",\n        error\n      );\n\n      throw INTERNAL_ERROR(\n        `Could not retrieve agent card: ${\n          error instanceof Error ? error.message : String(error)\n        }`\n      );\n    }\n  }\n\n  /**\n   * Refreshes the cached AgentCard by fetching it again from the server.\n   * @returns A promise resolving to the updated AgentCard.\n   */\n  async refreshAgentCard(): Promise&lt;AgentCard&gt; {\n    this.cachedAgentCard = null;\n    return this.agentCard();\n  }\n\n  /**\n   * Sends a task request to the agent (non-streaming).\n   * @param params The parameters for the message/send method.\n   * @returns A promise resolving to the Task object or null.\n   */\n  async sendMessage(params: MessageSendParams): Promise&lt;Message | Task | null&gt; {\n    return await executeJsonRpcRequest&lt;SendMessageRequest, SendMessageResponse&gt;(\n      this.baseUrl,\n      \"message/send\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * @deprecated Use sendMessage instead.\n   * Sends a task request to the agent (non-streaming).\n   * @param params The parameters for the message/send method.\n   * @returns A promise resolving to the Task object or null.\n   */\n  async sendTask(params: MessageSendParams): Promise&lt;Message | Task | null&gt; {\n    return await this.sendMessage(params);\n  }\n\n  /**\n   * Sends a task and returns a subscription to status and artifact updates.\n   * @param params Task parameters for the request\n   * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.\n   */\n  sendStreamingMessage(params: MessageSendParams): AsyncIterable&lt;UpdateEvent&gt; {\n    return executeStreamEvents&lt;\n      SendStreamingMessageRequest,\n      SendStreamingMessageResponse\n    &gt;(this.baseUrl, \"message/stream\", params, this.customHeaders);\n  }\n\n  /**\n   * @deprecated Use sendStreamingMessage instead.\n   * Sends a task and returns a subscription to status and artifact updates.\n   * @param params Task parameters for the request\n   * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.\n   */\n  sendTaskSubscribe(params: MessageSendParams): AsyncIterable&lt;UpdateEvent&gt; {\n    return this.sendStreamingMessage(params);\n  }\n\n  /**\n   * Retrieves the current state of a task.\n   * @param params The parameters for the tasks/get method.\n   * @returns A promise resolving to the Task object or null.\n   */\n  async getTask(params: TaskQueryParams): Promise&lt;Task | null&gt; {\n    return await executeJsonRpcRequest&lt;GetTaskRequest, GetTaskResponse&gt;(\n      this.baseUrl,\n      \"tasks/get\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Cancels a currently running task.\n   * @param params The parameters for the tasks/cancel method.\n   * @returns A promise resolving to the updated Task object (usually canceled state) or null.\n   */\n  async cancelTask(params: TaskIdParams): Promise&lt;Task | null&gt; {\n    return await executeJsonRpcRequest&lt;CancelTaskRequest, CancelTaskResponse&gt;(\n      this.baseUrl,\n      \"tasks/cancel\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Sets or updates the push notification config for a task.\n   * @param params The parameters for the tasks/pushNotificationConfig/set method (which is TaskPushNotificationConfig).\n   * @returns A promise resolving to the confirmed TaskPushNotificationConfig or null.\n   */\n  async setTaskPushNotification(\n    params: TaskPushNotificationConfig\n  ): Promise&lt;TaskPushNotificationConfig | null&gt; {\n    return await executeJsonRpcRequest&lt;\n      SetTaskPushNotificationConfigRequest,\n      SetTaskPushNotificationConfigResponse\n    &gt;(\n      this.baseUrl,\n      \"tasks/pushNotificationConfig/set\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Retrieves the currently configured push notification config for a task.\n   * @param params The parameters for the tasks/pushNotificationConfig/get method.\n   * @returns A promise resolving to the TaskPushNotificationConfig or null.\n   */\n  async getTaskPushNotification(\n    params: TaskIdParams\n  ): Promise&lt;TaskPushNotificationConfig | null&gt; {\n    return await executeJsonRpcRequest&lt;\n      GetTaskPushNotificationConfigRequest,\n      GetTaskPushNotificationConfigResponse\n    &gt;(\n      this.baseUrl,\n      \"tasks/pushNotificationConfig/get\",\n      params,\n      this.customHeaders\n    );\n  }\n\n  /**\n   * Resubscribes to an existing task's update stream.\n   * @param params Parameters identifying the task to resubscribe to\n   * @returns An AsyncIterable that yields TaskStatusUpdateEvent or TaskArtifactUpdateEvent payloads.\n   */\n  resubscribeTask(params: TaskQueryParams): AsyncIterable&lt;UpdateEvent&gt; {\n    return executeStreamEvents&lt;\n      TaskResubscriptionRequest,\n      SendStreamingMessageResponse\n    &gt;(this.baseUrl, \"tasks/resubscribe\", params, this.customHeaders);\n  }\n\n  /**\n   * Checks if the server supports a specific capability based on the agent card.\n   * @param capability The capability to check (e.g., 'streaming', 'pushNotifications').\n   * @returns A promise resolving to true if the capability is supported.\n   */\n  async supports(\n    capability: \"streaming\" | \"pushNotifications\" | \"stateTransitionHistory\"\n  ): Promise&lt;boolean&gt; {\n    try {\n      const card = await this.agentCard();\n\n      if (!card.capabilities) {\n        return false;\n      }\n\n      switch (capability) {\n        case \"streaming\":\n          return !!card.capabilities.streaming;\n        case \"pushNotifications\":\n          return !!card.capabilities.pushNotifications;\n        case \"stateTransitionHistory\":\n          return !!card.capabilities.stateTransitionHistory;\n        default:\n          return false;\n      }\n    } catch (error) {\n      logError(\n        \"A2AClient:supports\",\n        `Failed to determine support for capability '${capability}':`,\n        error\n      );\n      return false; // Assume not supported if card fetch fails\n    }\n  }\n\n  /**\n   * Sets custom headers to be included in all requests.\n   * @param headers A record of header name/value pairs.\n   */\n  setHeaders(headers: Record&lt;string, string&gt;): void {\n    this.customHeaders = { ...headers };\n  }\n\n  /**\n   * Adds a single custom header to be included in all requests.\n   * @param name The header name.\n   * @param value The header value.\n   */\n  addHeader(name: string, value: string): void {\n    this.customHeaders[name] = value;\n  }\n\n  /**\n   * Removes a custom header.\n   * @param name The header name to remove.\n   */\n  removeHeader(name: string): void {\n    delete this.customHeaders[name];\n  }\n\n  /**\n   * Clears all custom headers.\n   */\n  clearHeaders(): void {\n    this.customHeaders = {};\n  }\n}\n</code></pre>"},{"location":"api/server.html","title":"A2AServer","text":""},{"location":"api/server.html#a2aserver_1","title":"A2AServer","text":"<p>@deprecated Use ExpressServer instead. Implements an A2A protocol compliant server using Express. Handles task creation, streaming, cancellation and more. Uses Jayson for JSON-RPC handling.</p> <pre><code>implements Server {\n  protected expressServer: ExpressServer;\n  /**\n   * Returns the base path for the server\n   */\n  getBasePath(): string {\n    return this.expressServer.basePath;\n  }\n\n  /**\n   * Returns the CORS options for the server\n   */\n  getCorsOptions(): CorsOptions {\n    return this.expressServer.corsOptions;\n  }\n\n  /**\n   * Returns the agent card for the server\n   */\n  getCard(): AgentCard {\n    return this.expressServer.card;\n  }\n\n  /**\n   * Returns the task store\n   */\n  getTaskStore(): TaskStore {\n    return (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.getTaskStore();\n  }\n\n  /**\n   * Returns the task handler\n   */\n  getTaskHandler(): TaskHandler {\n    return this.expressServer.engine;\n  }\n\n  /**\n   * Returns the set of active cancellations\n   */\n  getActiveCancellations(): Set&lt;string&gt; {\n    return (this.expressServer.getService(Protocol.A2A) as A2AService)?.state\n      .activeCancellations;\n  }\n\n  /**\n   * Returns the map of active streams\n   */\n  getActiveStreams(): Map&lt;string, Response[]&gt; {\n    return (this.expressServer.getService(Protocol.A2A) as A2AService)?.state\n      .activeStreams;\n  }\n\n  /**\n   * Returns the port number\n   */\n  getPort(): number {\n    return this.expressServer.port;\n  }\n\n  /**\n   * Returns the JSON-RPC server\n   */\n  getRpcServer(): JSONRPCServerType {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Returns the server instance\n   */\n  getServerInstance(): http.Server | undefined {\n    return this.expressServer.serverInstance;\n  }\n\n  /**\n   * Returns the Express app\n   */\n  getExpressApp(): express.Express {\n    return this.expressServer.getApp();\n  }\n\n  /**\n   * Returns a task context for the specified task and messages\n   */\n  getTaskContext(\n    task: Task,\n    userMessage: Message,\n    history: Message[]\n  ): TaskContext {\n    return this.createTaskContext(task, userMessage, history);\n  }\n\n  /**\n   * Returns the default agent card\n   */\n  defaultAgentCard(): AgentCard {\n    return A2AServer.defaultAgentCard();\n  }\n\n  /**\n   * Creates a new A2AServer.\n   * @param handler The task handler function that will process tasks\n   * @param options Options for configuring the server\n   */\n  constructor(params: A2AServerParams) {\n    this.expressServer = new ExpressServer({\n      card: params.card ?? A2AServer.defaultAgentCard(),\n      storage: params.taskStore ?? new InMemoryTaskStore(),\n      corsOptions: params.corsOptions,\n      basePath: params.basePath,\n      port: params.port,\n      fallbackPath: params.fallbackPath,\n      register: params.register,\n      engine: params.handler,\n    });\n\n    logDebug(\"A2AServer\", \"Server initialized\", {\n      basePath: this.expressServer.basePath,\n      port: this.expressServer.port,\n      corsEnabled: !!this.expressServer.corsOptions,\n    });\n  }\n\n  /**\n   * Starts the Express server listening on the specified port.\n   * @returns The running Express application instance.\n   */\n  start(): express.Express {\n    if (this.expressServer.serverInstance) {\n      throw new Error(\"Server already started\");\n    }\n\n    this.expressServer.start();\n\n    //lazily register your server with the A2A registry on startup\n    //this is so that you can start the server without having to wait for registration\n    //you can call also call this.registerServer() later to register your server\n    if (this.expressServer.register) {\n      this.registerServer();\n    }\n    return this.expressServer.getApp();\n  }\n\n  /**\n   * Stops the server and closes all connections.\n   * @returns A promise that resolves when the server is stopped.\n   */\n  async stop(): Promise&lt;void&gt; {\n    if (!this.expressServer.serverInstance) {\n      return;\n    }\n\n    await this.expressServer.stop();\n  }\n\n  /**\n   * Registers the server with the A2A registry.\n   * @returns A promise that resolves to the registration ID or an empty string if registration fails.\n   */\n  public async registerServer(): Promise&lt;string&gt; {\n    if (this.expressServer.card) {\n      return await register(this.expressServer.card);\n    }\n    return \"\";\n  }\n\n  /**\n   * Handles task cancellation\n   * @param data Task and history data\n   * @param res Response object\n   */\n  public async onCancel(\n    context: TaskContext,\n    data: TaskAndHistory,\n    res: Response\n  ): Promise&lt;void&gt; {\n    await (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.onCancel(context, data, res);\n  }\n\n  /**\n   * Handles cleanup when a task stream ends\n   * @param taskId The task ID\n   * @param res Response object\n   */\n  public async onEnd(taskId: string, res: Response): Promise&lt;void&gt; {\n    await (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.onEnd(taskId, res);\n  }\n\n  /**\n   * Handles the message/stream method.\n   * @param req The SendTaskRequest object\n   * @param res The Express Response object\n   */\n  public async handleTaskSendSubscribe(\n    req: SendStreamingMessageRequest,\n    res: Response\n  ): Promise&lt;void&gt; {\n    await (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.handleSendStreamingMessage(req, res);\n  }\n\n  /**\n   * Handles the tasks/resubscribe method.\n   * @param req The TaskResubscriptionRequest object\n   * @param res The Express Response object\n   */\n  public async handleTaskResubscribe(\n    req: TaskResubscriptionRequest,\n    res: Response\n  ): Promise&lt;void&gt; {\n    await (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.handleTaskResubscribe(req, res);\n  }\n\n  /**\n   * Adds a response stream to the tracking map for a task.\n   * @param taskId The task ID\n   * @param res The response stream\n   */\n  public addStreamForTask(taskId: string, res: Response): void {\n    (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.addStreamForTask(taskId, res);\n  }\n\n  /**\n   * Removes a response stream from the tracking map for a task.\n   * @param taskId The task ID\n   * @param res The response stream\n   */\n  public removeStreamForTask(taskId: string, res: Response): void {\n    (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.removeStreamForTask(taskId, res);\n  }\n\n  /**\n   * Initializes the default agent card\n   */\n  public static defaultAgentCard(): AgentCard {\n    return {\n      name: \"A2A Server\",\n      description: \"A general-purpose A2A protocol server\",\n      version: \"0.1.0\",\n      url: \"http://localhost\",\n      capabilities: {\n        streaming: true,\n        pushNotifications: false,\n        stateTransitionHistory: true,\n      },\n      skills: [],\n      defaultInputModes: [\"text\"],\n      defaultOutputModes: [\"text\"],\n    };\n  }\n\n  /**\n   * Creates a TaskContext object for a task handler.\n   * @param task The task\n   * @param userMessage The user message\n   * @param history The message history\n   * @returns A TaskContext object\n   */\n  public createTaskContext(\n    task: Task,\n    userMessage: Message,\n    history: Message[],\n    configuration?: MessageSendConfiguration\n  ): TaskContext {\n    return (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.createTaskContext(task, userMessage, history, configuration);\n  }\n\n  /**\n   * Closes any active streams for a task.\n   * @param taskId The task ID\n   */\n  public closeStreamsForTask(taskId: string): void {\n    (\n      this.expressServer.getService(Protocol.A2A) as A2AService\n    )?.state.closeStreamsForTask(taskId);\n  }\n}\n</code></pre>"},{"location":"api/task-context.html","title":"Task Context","text":""},{"location":"api/task-context.html#basecontext","title":"BaseContext","text":"<p>@description The base context.</p> <pre><code>{\n  /**\n   * @description The id.\n   * @type {string}\n   */\n  id: string;\n  /**\n   * @description The protocol.\n   * @type {Protocol}\n   */\n  protocol: Protocol;\n}\n</code></pre>"},{"location":"api/task-context.html#mcpcontext","title":"MCPContext","text":"<p>@description The id. @type {string} /   id: string;   /** @description The protocol. @type {Protocol} /   protocol: Protocol; }</p> <p>/** @description The MCP context.</p> <pre><code>{\n  /**\n   * @description The message.\n   * @type {string}\n   */\n  message: string;\n}\n</code></pre>"},{"location":"api/task-context.html#contextparams","title":"ContextParams","text":"<p>@description The message. @type {string} /   message: string; }</p> <p>/** @description The context params. @type {A2AContext[\"params\"] | MCPContext}</p> <pre><code>= A2AContext[\"params\"] | MCPContext;\n\n/**\n * @description The base execution context.\n */\nexport interface BaseExecutionContext&lt;T extends ContextParams = ContextParams&gt;\n  extends BaseContext {\n  /**\n   * @description The method.\n   * @type {string}\n   */\n  method: string;\n  /**\n   * @description The params.\n   * @type {T}\n   */\n  params: T;\n}\n</code></pre>"},{"location":"api/task-context.html#baseexecutioncontext","title":"BaseExecutionContext","text":"<p>@description The base execution context.</p> <pre><code>&lt;T extends ContextParams = ContextParams&gt;\n  extends BaseContext {\n  /**\n   * @description The method.\n   * @type {string}\n   */\n  method: string;\n  /**\n   * @description The params.\n   * @type {T}\n   */\n  params: T;\n}\n</code></pre>"},{"location":"api/task-context.html#a2aexecutioncontext","title":"A2AExecutionContext","text":"<p>@description The method. @type {string} /   method: string;   /** @description The params. @type {T} /   params: T; }</p> <p>/** Represents a request specific to the A2A (Agent-to-Agent) protocol. The <code>protocol</code> field is narrowed to <code>Protocol.A2A</code>.</p> <pre><code>&lt;\n  RequestType extends A2AContext = A2AContext,\n&gt; extends BaseExecutionContext&lt;RequestType[\"params\"]&gt; {\n  protocol: Protocol.A2A;\n  /**\n   * @description The task.\n   * @type {Task}\n   */\n  task: Task;\n  /**\n   * @description The request.\n   * @type {any}\n   */\n  request: any;\n  /**\n   * @description The response.\n   * @type {any}\n   */\n  response: any;\n}\n</code></pre>"},{"location":"api/task-context.html#mcpexecutioncontext","title":"MCPExecutionContext","text":"<p>@description The task. @type {Task} /   task: Task;   / @description The request. @type {any} /   request: any;   / @description The response. @type {any} /   response: any; }</p> <p>/** @description Represents a request specific to the MCP (Model Context Protocol) protocol. The <code>protocol</code> field is narrowed to <code>Protocol.MCP</code>.</p> <pre><code>extends BaseExecutionContext&lt;MCPContext&gt; {\n  protocol: Protocol.MCP;\n  /**\n   * @description The request.\n   * @type {any}\n   */\n  request: any;\n  /**\n   * @description The response.\n   * @type {any}\n   */\n  response: any;\n  /**\n   * @description The transport.\n   * @type {any}\n   */\n  transport: any;\n  /**\n   * @description The skills.\n   * @type {AgentSkill[]}\n   */\n  skills?: AgentSkill[];\n}\n</code></pre>"},{"location":"api/task-context.html#nlwebexecutioncontext","title":"NLWebExecutionContext","text":"<p>@description The request. @type {any} /   request: any;   / @description The response. @type {any} /   response: any;   / @description The transport. @type {any} /   transport: any;   /** @description The skills. @type {AgentSkill[]} /   skills?: AgentSkill[]; }</p> <p>/** @description Represents a request specific to the NLWeb protocol. The <code>protocol</code> field is narrowed to <code>Protocol.NLWEB</code>.</p> <pre><code>extends Omit&lt;MCPExecutionContext, \"protocol\"&gt; {\n  protocol: Protocol.NLWEB;\n}\n</code></pre>"},{"location":"api/task-context.html#acpexecutioncontext","title":"ACPExecutionContext","text":"<p>@description Represents a request specific to the ACP (Agent Communication Protocol). The <code>protocol</code> field is narrowed to <code>Protocol.ACP</code>.</p> <pre><code>extends BaseExecutionContext {\n  protocol: Protocol.ACP;\n}\n</code></pre>"},{"location":"api/task-context.html#chatexecutioncontext","title":"ChatExecutionContext","text":"<p>@description Represents a request specific to the CHAT protocol. The <code>protocol</code> field is narrowed to <code>Protocol.CHAT</code>.</p> <pre><code>extends BaseExecutionContext {\n  protocol: Protocol.CHAT;\n}\n</code></pre>"},{"location":"api/task-context.html#supportedcontext","title":"SupportedContext","text":"<p>@description A discriminated union of all protocol-specific request types. This allows functions to accept any request and use the <code>protocol</code> field to determine the specific type of request, enabling type-safe handling based on the protocol.</p> <pre><code>=\n  | A2AExecutionContext\n  | MCPExecutionContext\n  | ACPExecutionContext\n  | ChatExecutionContext;\n\n/**\n * @description The execution context.\n */\nexport interface ExecutionContext&lt;\n  ContextType extends BaseExecutionContext = SupportedContext,\n&gt; {\n  /**\n   * @description The id.\n   * @type {string}\n   */\n  id: string;\n  /**\n   * @description The protocol.\n   */\n  protocol: Protocol;\n  /**\n   * @description The get request params.\n   * @type {() =&gt; ContextType[\"params\"] | undefined}\n   */\n  getRequestParams: () =&gt; ContextType[\"params\"] | undefined;\n  /**\n   * @description The is cancelled.\n   * @type {() =&gt; boolean}\n   */\n  isCancelled: () =&gt; boolean;\n  /**\n   * @description The request context.\n   * @type {ContextType}\n   */\n  requestContext?: ContextType;\n}\n</code></pre>"},{"location":"api/task-context.html#executioncontext","title":"ExecutionContext","text":"<p>@description The execution context.</p> <pre><code>&lt;\n  ContextType extends BaseExecutionContext = SupportedContext,\n&gt; {\n  /**\n   * @description The id.\n   * @type {string}\n   */\n  id: string;\n  /**\n   * @description The protocol.\n   */\n  protocol: Protocol;\n  /**\n   * @description The get request params.\n   * @type {() =&gt; ContextType[\"params\"] | undefined}\n   */\n  getRequestParams: () =&gt; ContextType[\"params\"] | undefined;\n  /**\n   * @description The is cancelled.\n   * @type {() =&gt; boolean}\n   */\n  isCancelled: () =&gt; boolean;\n  /**\n   * @description The request context.\n   * @type {ContextType}\n   */\n  requestContext?: ContextType;\n}\n</code></pre>"},{"location":"api/task-context.html#agentengine","title":"AgentEngine","text":"<p>@description The id. @type {string} /   id: string;   / @description The protocol. /   protocol: Protocol;   / @description The get request params. @type {() =&gt; ContextType[\"params\"] | undefined} /   getRequestParams: () =&gt; ContextType[\"params\"] | undefined;   / @description The is cancelled. @type {() =&gt; boolean} /   isCancelled: () =&gt; boolean;   / @description The request context. @type {ContextType} /   requestContext?: ContextType; }</p> <p>/** @description The agent engine. @type {AgentEngine}</p> <pre><code>&lt;Context extends ExecutionContext = ExecutionContext&gt; = (\n  context: Context\n) =&gt; AsyncGenerator&lt;any, void, undefined&gt;;\n\n/**\n * @description The execution context config.\n * @type {const}\n</code></pre>"},{"location":"api/task-context.html#executioncontextconfig","title":"executionContextConfig","text":"<p>@description The execution context config. @type {const}</p> <pre><code>= {\n  id: \"contextId\",\n  message: \"userMessage\",\n}\n</code></pre>"},{"location":"contributing/code-documentation.html","title":"Code Documentation Guidelines","text":"<p>When contributing to the Artinet SDK, please use the following Doxygen-style comment patterns to ensure consistent documentation.</p>"},{"location":"contributing/code-documentation.html#class-documentation","title":"Class Documentation","text":"<pre><code>/**\n * @brief Brief description of the class\n * \n * Detailed description of what the class does and how to use it.\n * Include any important concepts or patterns the class implements.\n * \n * @example\n * ```typescript\n * const instance = new ExampleClass(params);\n * instance.doSomething();\n * ```\n */\nclass ExampleClass {\n  // Class implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#method-documentation","title":"Method Documentation","text":"<pre><code>/**\n * @brief Brief description of the method\n * \n * Detailed description of what the method does, including any side effects\n * or state changes it causes. Mention any exceptions that might be thrown.\n * \n * @param paramName Description of the parameter, including type constraints and requirements\n * @param optionalParam Description of an optional parameter and its default value if omitted\n * @return Description of what the method returns, including possible error states\n * \n * @example\n * ```typescript\n * const result = instance.methodName(\"input value\");\n * console.log(result); // Expected output\n * ```\n */\npublic methodName(paramName: string, optionalParam?: number): ReturnType {\n  // Method implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#interface-documentation","title":"Interface Documentation","text":"<pre><code>/**\n * @brief Brief description of the interface\n * \n * Detailed explanation of the interface purpose and usage patterns.\n * Include information about when and why this interface should be implemented.\n * \n * @example\n * ```typescript\n * class MyImplementation implements ExampleInterface {\n *   // Implementation details\n * }\n * ```\n */\ninterface ExampleInterface {\n  /**\n   * @brief Description of the property\n   */\n  propertyName: string;\n\n  /**\n   * @brief Description of the method\n   * @param input Description of parameter\n   * @return Description of return value\n   */\n  methodName(input: InputType): OutputType;\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#type-definition-documentation","title":"Type Definition Documentation","text":"<pre><code>/**\n * @brief Brief description of the type\n * \n * Detailed explanation of what this type represents and when to use it.\n * Include any constraints or special considerations.\n * \n * @example\n * ```typescript\n * const value: ExampleType = {\n *   property: \"value\"\n * };\n * ```\n */\ntype ExampleType = {\n  property: string;\n  optional?: number;\n};\n</code></pre>"},{"location":"contributing/code-documentation.html#function-documentation","title":"Function Documentation","text":"<pre><code>/**\n * @brief Brief description of the function\n * \n * Detailed explanation of what the function does, including any side effects.\n * \n * @param input Description of the input parameter\n * @return Description of the return value\n * @throws Description of any exceptions that might be thrown\n * \n * @example\n * ```typescript\n * const result = utilityFunction(\"input\");\n * ```\n */\nfunction utilityFunction(input: string): number {\n  // Function implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation.html#constants-documentation","title":"Constants Documentation","text":"<pre><code>/**\n * @brief Brief description of the constant\n * \n * Additional details about the constant, including where and how it's used.\n */\nconst IMPORTANT_CONSTANT = \"value\";\n</code></pre>"},{"location":"contributing/code-documentation.html#file-headers","title":"File Headers","text":"<p>Each file should include a header comment describing the file's contents:</p> <pre><code>/**\n * @fileoverview Brief description of the file\n * \n * Detailed description of the file contents, purpose, and any important\n * concepts or patterns used within. Mention any dependencies.\n * \n * @example\n * ```typescript\n * import { Something } from './this-file';\n * ```\n */\n</code></pre>"},{"location":"contributing/code-documentation.html#deprecation-notices","title":"Deprecation Notices","text":"<pre><code>/**\n * @brief Brief description of the deprecated item\n * \n * @deprecated This feature will be removed in version X.Y.Z.\n * Use NewFeature instead.\n * \n * @see {@link NewFeature} for the recommended alternative\n */\n</code></pre> <p>Following these guidelines will ensure that the SDK's documentation is consistent and comprehensive, making it easier for developers to understand and use the library correctly.</p>"},{"location":"sdk/core.html","title":"Core SDK Components","text":"<p>This page provides a comprehensive overview of the main classes, types, and utilities available in the Artinet SDK. These are the fundamental building blocks you'll use to create and interact with A2A-compliant agents.</p>"},{"location":"sdk/core.html#a2aserver","title":"A2AServer","text":"<ul> <li>The primary class for instantiating and running an A2A agent server. It manages the agent's lifecycle, handles incoming requests, executes tasks via a <code>TaskHandler</code>, and uses a <code>TaskStore</code> for persistence. Built on Express.js, it automatically handles JSON-RPC complexity, routing, A2A protocol compliance, and Server-Sent Events (SSE) streaming.</li> </ul> <pre><code>// Key methods\nstart(): express.Express;  // Starts the server and returns the Express app\nstop(): Promise&lt;void&gt;;     // Stops the server and closes all connections\ngetExpressApp(): express.Express;  // Returns the underlying Express app for customization\nregisterServer(): Promise&lt;string&gt;; // Registers the server with the A2A registry\n</code></pre>"},{"location":"sdk/core.html#a2aclient","title":"A2AClient","text":"<ul> <li>The client class used to connect to an <code>A2AServer</code> instance. It allows you to send messages (using <code>sendMessage</code> for single responses or <code>sendStreamingMessage</code> for streaming updates) and manage communication headers. Features refined error handling via <code>RpcError</code>, flexible header management for authentication, and clear separation of concerns.</li> </ul> <pre><code>// Key methods\nasync sendMessage(params: MessageSendParams): Promise&lt;Task | null&gt;;\nsendStreamingMessage(params: MessageSendParams): AsyncIterable&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\nasync getTask(params: TaskQueryParams): Promise&lt;Task | null&gt;;\nasync cancelTask(params: TaskIdParams): Promise&lt;Task | null&gt;;\nasync supports(capability: \"streaming\" | \"pushNotifications\" | \"stateTransitionHistory\"): Promise&lt;boolean&gt;;\naddHeader(name: string, value: string): void;\nsetHeaders(headers: Record&lt;string, string&gt;): void;\n</code></pre>"},{"location":"sdk/core.html#taskhandler-type","title":"TaskHandler (Type)","text":"<ul> <li>An asynchronous generator function (<code>async function*</code>) type that defines the core logic of an agent. It receives a <code>TaskContext</code> and yields <code>TaskYieldUpdate</code> objects to report progress and results. This is where you implement your agent's main functionality, processing user messages and generating responses.</li> </ul> <pre><code>type TaskHandler = (\n  context: TaskContext\n) =&gt; AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt;;\n</code></pre>"},{"location":"sdk/core.html#taskcontext-interfacetype","title":"TaskContext (Interface/Type)","text":"<ul> <li>An object passed as an argument to the <code>TaskHandler</code>. It provides task details such as <code>userMessage</code>, <code>taskId</code>, and methods like <code>isCancelled()</code> to check if a task should be aborted. Use this to access user inputs and manage the agent's execution flow.</li> </ul> <pre><code>interface TaskContext {\n  task: Task;              // Current task state\n  userMessage: Message;    // Message that triggered this task\n  history: Message[];      // Previous messages in this conversation\n  isCancelled(): boolean;  // Check if cancellation was requested\n}\n</code></pre>"},{"location":"sdk/core.html#message-interfacetype","title":"Message (Interface/Type)","text":"<ul> <li>Defines the structure for messages exchanged between users and agents, or between agents. It includes a <code>role</code> (e.g., 'user', 'agent') and <code>parts</code> containing the content (e.g., text, images). This structure follows the A2A protocol specifications and ensures standardized communication.</li> </ul> <pre><code>interface Message {\n  role: \"user\" | \"agent\";\n  parts: Part[];           // Content parts (text, file, data)\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"sdk/core.html#inmemorytaskstore","title":"InMemoryTaskStore","text":"<ul> <li>A simple implementation of the <code>TaskStore</code> interface that stores task state and history in memory. Suitable for development, testing, or agents that do not require persistent task data across restarts. Ideal for rapid prototyping and experimentation.</li> </ul> <pre><code>// Usage\nconst store = new InMemoryTaskStore();\nconst server = new A2AServer({\n  handler: myTaskHandler,\n  taskStore: store,\n  // other parameters...\n});\n</code></pre>"},{"location":"sdk/core.html#filestore","title":"FileStore","text":"<ul> <li>An implementation of the <code>TaskStore</code> interface that persists task state and history to the local filesystem in a specified directory. Useful for agents that need to retain task data between server restarts. Ensures your agent can maintain conversation context and task state.</li> </ul> <pre><code>// Usage\nconst dataDir = path.join(process.cwd(), \"task-data\");\nconst store = new FileStore(dataDir);\nconst server = new A2AServer({\n  handler: myTaskHandler,\n  taskStore: store,\n  // other parameters...\n});\n</code></pre>"},{"location":"sdk/core.html#taskstatusupdateevent-interfacetype","title":"TaskStatusUpdateEvent (Interface/Type)","text":"<ul> <li>An event object yielded by a <code>TaskHandler</code> during streaming operations. It includes the current <code>state</code> of the task (e.g., 'working', 'completed', 'error') and can include an updated <code>message</code> from the agent. This allows real-time progress updates to be sent to clients.</li> </ul> <pre><code>interface TaskStatusUpdateEvent {\n  id: string;\n  status: TaskStatus;      // Current state with timestamp\n  final?: boolean;         // True if this is the final update\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"sdk/core.html#taskartifactupdateevent-interfacetype","title":"TaskArtifactUpdateEvent (Interface/Type)","text":"<ul> <li>An event object yielded by a <code>TaskHandler</code> when an agent produces an artifact (like a file) during a task. It includes details about the <code>artifact</code> such as its name, mimeType, and content. This enables agents to share documents, files, or other complex outputs during task execution.</li> </ul> <pre><code>interface TaskArtifactUpdateEvent {\n  id: string;\n  artifact: Artifact;      // The produced artifact\n  final?: boolean;         // True if this is the final update\n  metadata?: Record&lt;string, unknown&gt;;\n}\n</code></pre>"},{"location":"sdk/core.html#logger-configurelogger-logdebug-utilities","title":"logger / configureLogger / logDebug (Utilities)","text":"<ul> <li>A set of logging utilities provided by the SDK. <code>logger</code> is the main logger instance based on the Pino library. <code>configureLogger</code> allows customization of log levels and output. <code>logDebug</code> and similar functions are helpers for common log levels, making it easier to add structured logging to your agent.</li> </ul> <pre><code>// Configure logging level\nconfigureLogger({ level: \"debug\" });  // Options: silent, error, warn, info, debug, trace\n\n// Use logging helpers\nlogDebug(\"ComponentName\", \"Debug message\", optionalData);\nlogInfo(\"ComponentName\", \"Info message\", optionalData);\nlogWarn(\"ComponentName\", \"Warning message\", optionalData);\nlogError(\"ComponentName\", \"Error message\", errorObject, optionalData);\n</code></pre>"},{"location":"sdk/core.html#jsonrpcserverfactory-type","title":"JSONRPCServerFactory (Type)","text":"<ul> <li>A function signature for providing custom JSON-RPC server creation logic to the A2AServer for advanced customization. This allows you to implement custom methods, integrate with existing Express apps, or fine-tune the API behavior to meet specific requirements.</li> </ul> <pre><code>type JSONRPCServerFactory = (\n  params: CreateJSONRPCServerParams\n) =&gt; JSONRPCServerType;\n</code></pre>"},{"location":"sdk/core.html#agentcard-interfacetype","title":"AgentCard (Interface/Type)","text":"<ul> <li>Describes an agent's capabilities, metadata, skills, and endpoint URL. This information is exposed at the standard <code>/.well-known/agent.json</code> endpoint (and optional fallback paths) to enable discovery and interoperability with other A2A-compliant systems.</li> </ul> <pre><code>interface AgentCard {\n  name: string;            // Agent name\n  url: string;             // Endpoint URL\n  version: string;         // Version identifier\n  description?: string;    // Optional description\n  capabilities: {          // Supported features\n    streaming?: boolean;\n    pushNotifications?: boolean;\n    stateTransitionHistory?: boolean;\n  };\n  skills: Array&lt;{          // Agent's abilities\n    id: string;\n    name: string;\n    description?: string;\n  }&gt;;\n  // Additional optional properties\n}\n</code></pre>"},{"location":"sdk/quickstart.html","title":"Quick Start Guide: Artinet SDK","text":"<p>This guide will help you get your first A2A-compliant agent up and running and show you how to interact with it.</p>"},{"location":"sdk/quickstart.html#installation","title":"Installation","text":"<p>First, you need to install the Artinet SDK into your project. If you're using Node.js and npm, you can install it with the following command in your terminal:</p> <p><pre><code>npm install @artinet/sdk\n</code></pre> If you're using Yarn, you can use:</p> <pre><code>yarn add @artinet/sdk\n</code></pre>"},{"location":"sdk/quickstart.html#1-creating-your-first-agent-server-side","title":"1. Creating Your First Agent (Server-Side)","text":"<p>An A2A-compliant agent is essentially a server that can perform tasks. Here's how to create a simple agent that echoes back any text it receives:</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Define the logic for your agent\n// This function is a 'TaskHandler'. It processes incoming tasks.\nconst echoAgentLogic: TaskHandler = async function* (context: TaskContext) {\n  // Extract text from the user's message\n  // (Assuming the message part is text)\n  const userInput =\n    context.userMessage.parts[0]?.type === \"text\"\n      ? context.userMessage.parts[0].text\n      : \"No text provided\";\n\n  // 1. Yield a 'working' state to indicate the task has started\n  yield { state: \"working\" };\n\n  // You could do more complex work here.\n  // For long tasks, you might periodically check `context.isCancelled()`\n\n  // 2. Yield a 'completed' state with the agent's response\n  yield {\n    state: \"completed\",\n    message: { // This is the agent's reply\n      role: \"agent\",\n      parts: [{ type: \"text\", text: `Your agent says: You sent '${userInput}'` }],\n    },\n  };\n};\n\n// Configure and create the A2A Server instance\nconst server = new A2AServer({\n  handler: echoAgentLogic,          // The logic our agent will use\n  taskStore: new InMemoryTaskStore(),   // Stores task information (in memory for this example)\n  port: 4000,                           // The port your agent server will run on\n  basePath: \"/a2a\",                     // The base API path for your agent\n\n  // The 'card' provides metadata about your agent so others can discover it\n  card: {\n    name: \"EchoAgent\",\n    url: \"http://localhost:4000/a2a\", // How to reach this agent\n    version: \"0.1.0\",\n    capabilities: { streaming: true }, // Indicates this agent supports streaming updates\n    skills: [{ id: \"echo\", name: \"Echo Skill\" }], // Describes what the agent can do\n  },\n});\n\n// Start the server\nasync function main() {\n  try {\n    await server.start(); // Start listening for requests\n    console.log(\"EchoAgent server running at http://localhost:4000/a2a\");\n  } catch (error) {\n    console.error(\"Failed to start server:\", error);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"sdk/quickstart.html#key-concepts","title":"Key Concepts:","text":"<ul> <li>TaskHandler: This is the heart of your agent - an asynchronous generator function that processes incoming tasks and yields status updates.</li> <li>TaskContext: Contains information about the task, including the user's message and methods like <code>isCancelled()</code>.</li> <li>A2AServer: Creates and manages your agent server, handling protocol details automatically.</li> <li>AgentCard (in <code>card</code> parameter): Describes your agent's capabilities and how to reach it.</li> </ul>"},{"location":"sdk/quickstart.html#2-interacting-with-your-agent-client-side","title":"2. Interacting with Your Agent (Client-Side)","text":"<p>Now that you have an agent server running, let's send it a task using the A2AClient:</p> <pre><code>import { A2AClient, Message } from \"@artinet/sdk\";\n\nasync function talkToAgent() {\n  // Create a client pointing to your running agent server\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  // Define the message you want to send to the agent\n  const userMessage: Message = {\n    role: \"user\", // Indicates the message is from a user\n    parts: [{ type: \"text\", text: \"Hello Artinet Agent!\" }], // The content of the message\n  };\n\n  try {\n    console.log(\"Sending message to agent...\");\n\n    // Send the task and wait for the final response\n    // 'sendMessage' is good for tasks that have a single, final response.\nconst taskResponse = await client.sendMessage({\n      id: \"my-echo-task-01\", // A unique ID for this task\n      message: userMessage,\n    });\n\n    console.log(\"Agent responded successfully!\");\n\n    // The final message from the agent is in taskResponse.message\n    if (taskResponse?.message &amp;&amp; taskResponse.message.parts[0]?.type === \"text\") {\n      console.log(\"Agent's final reply:\", taskResponse.message.parts[0].text);\n    } else {\n      console.log(\"Agent's final response structure:\", taskResponse);\n    }\n\n  } catch (error) {\n    console.error(\"Error interacting with agent:\", error);\n  }\n}\n\ntalkToAgent();\n</code></pre>"},{"location":"sdk/quickstart.html#key-concepts_1","title":"Key Concepts:","text":"<ul> <li>A2AClient: Connects to and interacts with A2A-compliant agent servers.</li> <li>Message: Structured format for communication, with a <code>role</code> and <code>parts</code> containing content.</li> <li>sendMessage(): Sends a one-time request and waits for the final response.</li> </ul>"},{"location":"sdk/quickstart.html#3-receiving-streaming-updates","title":"3. Receiving Streaming Updates","text":"<p>For long-running tasks or real-time updates, you can use the streaming API:</p> <pre><code>import { A2AClient, TaskStatusUpdateEvent, TaskArtifactUpdateEvent } from \"@artinet/sdk\";\n\nasync function streamFromAgent() {\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  const userMessage = {\n    role: \"user\",\n    parts: [{ type: \"text\", text: \"Process this data please\" }],\n  };\n\n  try {\n    // Use sendStreamingMessage to get a stream of updates\nconst stream = client.sendStreamingMessage({\n      id: \"streaming-task-01\",\n      message: userMessage,\n    });\n\n    // Process updates as they arrive\n    for await (const update of stream) {\n      if (\"status\" in update) {\n        const statusUpdate = update as TaskStatusUpdateEvent;\n        console.log(`Task status: ${statusUpdate.status.state}`);\n\n        if (statusUpdate.message?.parts[0]?.type === \"text\") {\n          console.log(`Agent says: ${statusUpdate.message.parts[0].text}`);\n        }\n      } else if (\"artifact\" in update) {\n        // Handle artifact updates\n        const artifactUpdate = update as TaskArtifactUpdateEvent;\n        console.log(`Received artifact: ${artifactUpdate.artifact.name}`);\n      }\n    }\n\n    console.log(\"Stream completed\");\n  } catch (error) {\n    console.error(\"Error with streaming task:\", error);\n  }\n}\n\nstreamFromAgent();\n</code></pre>"},{"location":"sdk/quickstart.html#4-running-the-examples","title":"4. Running the Examples","text":"<p>To run these examples:</p> <ol> <li>Save the server code as <code>myEchoAgent.ts</code></li> <li>Save the client code as <code>runClient.ts</code> or <code>streamClient.ts</code></li> <li>Run the server with <code>npx ts-node myEchoAgent.ts</code></li> <li>In another terminal, run the client with <code>npx ts-node runClient.ts</code></li> </ol>"},{"location":"sdk/quickstart.html#next-steps","title":"Next Steps","text":"<p>Now that you've built your first agent, you can:</p> <ul> <li>Explore more complex examples</li> <li>Learn about the core components of the SDK</li> <li>Add authentication to your agent's endpoints</li> <li>Implement persistent storage with <code>FileStore</code></li> <li>Create agents with advanced capabilities by integrating LLMs or other APIs</li> </ul> <p>The Artinet SDK provides a solid foundation for building sophisticated A2A-compliant agents with minimal boilerplate!</p>"},{"location":"sdk/examples/index.html","title":"Artinet SDK Examples","text":"<p>This section contains examples demonstrating how to use the Artinet SDK.</p>"},{"location":"sdk/examples/index.html#available-examples","title":"Available Examples","text":"<ul> <li>basic-server - Example demonstrating basic-server</li> <li>basic-usage - Example demonstrating basic-usage</li> <li>code-deployment - Example demonstrating code-deployment</li> <li>code-deployment - Example demonstrating code-deployment</li> <li>file-storage-client-continued - Example demonstrating file-storage-client-continued</li> <li>file-storage-client - Example demonstrating file-storage-client</li> <li>file-storage-server - Example demonstrating file-storage-server</li> <li>nested-deployment - Example demonstrating nested-deployment</li> <li>streaming-updates - Example demonstrating streaming-updates</li> <li>task-resubscribe - Example demonstrating task-resubscribe</li> <li>task-wrapper - Example demonstrating task-wrapper</li> </ul>"},{"location":"sdk/examples/basic-server.html","title":"basic-server","text":"<p>Basic A2A Server Example</p> <p>This example demonstrates how to create a simple A2A server that responds to incoming tasks.</p>"},{"location":"sdk/examples/basic-server.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Basic A2A Server Example\n *\n * This example demonstrates how to create a simple A2A server\n * that responds to incoming tasks.\n */\n\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  configureLogger,\n} from \"../dist/index.js\";\n\n// Configure logging for this example\nconfigureLogger({ level: \"info\" });\n\n/**\n * Implement a simple task handler\n */\nasync function* simpleEchoAgent(context) {\n  // Extract the user's message\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  console.log(`Processing request: ${userText}`);\n\n  // Send a \"working\" status update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: \"Thinking about your request...\", type: \"text\" }],\n    },\n  };\n\n  // Simulate some work with delay\n  await new Promise((resolve) =&gt; setTimeout(resolve, 1500));\n\n  // Check for task cancellation\n  if (context.isCancelled()) {\n    console.log(\"Task was cancelled\");\n    yield {\n      state: \"canceled\",\n      message: {\n        role: \"agent\",\n        parts: [{ text: \"Processing has been cancelled.\", type: \"text\" }],\n      },\n    };\n    return;\n  }\n\n  // Create a response\n  const response = `You said: \"${userText}\". This is an echo server example.`;\n\n  // Yield an artifact (optional)\n  yield {\n    name: \"response.txt\",\n    parts: [{ text: response, type: \"text\" }],\n  };\n\n  // Yield a completed status with response message\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: response, type: \"text\" }],\n    },\n  };\n}\n\n// Create a server\nconst server = new A2AServer({\n  // Use in-memory storage (no persistence between restarts)\n  handler: simpleEchoAgent,\n  taskStore: new InMemoryTaskStore(),\n  // Customize the port\n  port: 3000,\n\n  // Base path for the API endpoint\n  basePath: \"/api\",\n\n  // CORS options\n  corsOptions: {\n    origin: \"*\",\n    methods: [\"GET\", \"POST\"],\n    allowedHeaders: [\"Content-Type\"],\n  },\n\n  // Customize the agent card\n  card: {\n    name: \"Echo Agent\",\n    description: \"A simple echo agent that responds with your message\",\n    version: \"1.0.0\",\n    url: \"http://localhost:3000\",\n    skills: [\n      {\n        id: \"echo\",\n        name: \"echo\",\n        description: \"Echoes back the user's message\",\n      },\n    ],\n    capabilities: {\n      streaming: true,\n      pushNotifications: false,\n      stateTransitionHistory: true,\n    },\n  },\n});\n\n// Start the server\nserver.start();\nconsole.log(\"A2A Server started on port 3000\");\nconsole.log(\"Try connecting with an A2A client:\");\nconsole.log(\"  A2A Endpoint: http://localhost:3000/api\");\nconsole.log(\"  Agent Card: http://localhost:3000/.well-known/agent.json\");\n</code></pre>"},{"location":"sdk/examples/basic-server.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node basic-server.js</code></li> </ol>"},{"location":"sdk/examples/basic-server.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/basic-usage.html","title":"basic-usage","text":"<p>Basic usage example for the Artinet SDK</p> <p>This example demonstrates how to: - Create an A2AClient instance - Get the agent card - Send a simple task - Handle the response</p>"},{"location":"sdk/examples/basic-usage.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Basic usage example for the Artinet SDK\n *\n * This example demonstrates how to:\n * - Create an A2AClient instance\n * - Get the agent card\n * - Send a simple task\n * - Handle the response\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance pointing to our local server\n    const client = new A2AClient(\"http://localhost:3000/api\");\n    console.log(\"Client initialized\");\n\n    // Get the agent card to discover capabilities\n    try {\n      const agentCard = await client.agentCard();\n      console.log(`Connected to agent: ${agentCard.name}`);\n      console.log(`Agent version: ${agentCard.version}`);\n      console.log(\n        `Streaming supported: ${\n          agentCard.capabilities.streaming ? \"Yes\" : \"No\"\n        }`\n      );\n    } catch (error) {\n      console.log(\"Could not retrieve agent card, continuing anyway...\");\n      console.error(error);\n    }\n\n    // Create a message to send\n    const message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Hello! Can you help me with a question about climate change?\",\n        },\n      ],\n    };\n\n    // Generate a unique task ID\n    const taskId = `task-${Date.now()}`;\n\n    // Send a task\n    console.log(`Sending task with ID: ${taskId}...`);\n\n    const task = await client.sendTask({\n      id: taskId,\n      message,\n    });\n\n    if (task) {\n      console.log(`Task status: ${task.status.state}`);\n\n      if (task.status.message) {\n        // Extract the text parts from the response\n        const textParts = task.status.message.parts\n          .filter((part) =&gt; part.type === \"text\")\n          .map((part) =&gt; part.text);\n\n        console.log(\"Agent response:\", textParts.join(\"\\n\"));\n      }\n    } else {\n      console.log(\"No task response received\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/basic-usage.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node basic-usage.js</code></li> </ol>"},{"location":"sdk/examples/basic-usage.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/code-deployment.html","title":"code-deployment","text":"<p>Example demonstrating code-deployment</p>"},{"location":"sdk/examples/code-deployment.html#source-code","title":"Source Code","text":"<pre><code>import { TaskYieldUpdate, TaskContext, Task, TextPart } from \"@artinet/sdk\";\nimport { artinet } from \"@artinet/sdk/agents\";\n\nconsole.log(\"[CoderAgent] Starting\");\nexport async function* coderAgent({\n  task,\n  history,\n}: TaskContext): AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt; {\n  history = [...history, ...(task.status.message ? [task.status.message] : [])];\n  const messages = (history ?? [])\n    .map((m) =&gt; ({\n      role: (m.role === \"agent\" ? \"model\" : \"user\") as \"user\" | \"model\",\n      content: m.parts\n        .filter((p): p is TextPart =&gt; !!(p as TextPart).text)\n        .map((p) =&gt; p.text)\n        .join(\"\\n\"),\n    }))\n    .filter((m) =&gt; m.content.length &gt; 0);\n\n  if (messages.length === 0) {\n    console.warn(`[CoderAgent] No history/messages found for task ${task.id}`);\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"No input message found.\" }],\n      },\n    };\n    return;\n  }\n\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Generating code...\" }],\n    },\n  };\n\n  const response = await artinet.v0.connect({\n    agentId: \"Qwen/Qwen2.5-Coder-32B-Instruct\",\n    messages: [\n      {\n        role: \"system\",\n        content:\n          \"You are an expert coding assistant. Provide a high-quality code sample according to the output instructions provided below. You may generate multiple files as needed.\",\n      },\n      ...messages,\n    ],\n  });\n\n  console.log(\"coderAgent\", \"response: \", response);\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [\n        {\n          type: \"text\",\n          text: response,\n        },\n      ],\n    },\n  };\n}\n\nawait artinet.v0.taskManager({ taskHandler: coderAgent });\nconsole.log(\"[CoderAgent] Finished\");\n</code></pre>"},{"location":"sdk/examples/code-deployment.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node code-deployment.ts</code></li> </ol>"},{"location":"sdk/examples/code-deployment.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/file-storage-client-continued.html","title":"file-storage-client-continued","text":"<p>Test client for the file storage server example - part 2 This test demonstrates history retrieval after server restart</p>"},{"location":"sdk/examples/file-storage-client-continued.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Test client for the file storage server example - part 2\n * This test demonstrates history retrieval after server restart\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\n// Use the same task ID as in the previous run\nconst taskId = `conversation-1745596127049`;\n\nasync function main() {\n  try {\n    // Create a new client instance\n    const client = new A2AClient(\"http://localhost:3000\");\n    console.log(\"Client initialized\");\n\n    // Get the agent card to discover capabilities\n    try {\n      const agentCard = await client.agentCard();\n      console.log(`Connected to agent: ${agentCard.name}`);\n    } catch (error) {\n      console.log(\"Could not retrieve agent card, continuing anyway...\");\n    }\n\n    console.log(`\\nSending third message with task ID: ${taskId}`);\n    const message =\n      \"This is my third message. The server was restarted. Do you still remember our conversation?\";\n    console.log(`Message: \"${message}\"`);\n\n    // Send a task\n    const task = await client.sendTask({\n      id: taskId,\n      message: {\n        role: \"user\",\n        parts: [\n          {\n            type: \"text\",\n            text: message,\n          },\n        ],\n      },\n    });\n\n    if (task) {\n      console.log(`Task status: ${task.status.state}`);\n\n      if (task.status.message) {\n        // Extract the text parts from the response\n        const textParts = task.status.message.parts\n          .filter((part) =&gt; part.type === \"text\")\n          .map((part) =&gt; part.text);\n\n        console.log(\"Agent response:\", textParts.join(\"\\n\"));\n      }\n    } else {\n      console.log(\"No task response received\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/file-storage-client-continued.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node file-storage-client-continued.js</code></li> </ol>"},{"location":"sdk/examples/file-storage-client-continued.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/file-storage-client.html","title":"file-storage-client","text":"<p>Test client for the file storage server example</p>"},{"location":"sdk/examples/file-storage-client.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Test client for the file storage server example\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance\n    const client = new A2AClient(\"http://localhost:3000\");\n    console.log(\"Client initialized\");\n\n    // Get the agent card to discover capabilities\n    try {\n      const agentCard = await client.agentCard();\n      console.log(`Connected to agent: ${agentCard.name}`);\n      console.log(`Agent version: ${agentCard.version}`);\n      console.log(\n        `Streaming supported: ${\n          agentCard.capabilities.streaming ? \"Yes\" : \"No\"\n        }`\n      );\n    } catch (error) {\n      console.log(\"Could not retrieve agent card, continuing anyway...\");\n      console.error(error);\n    }\n\n    // Generate a unique task ID - we'll reuse this for the second message\n    const taskId = `conversation-${Date.now()}`;\n\n    // First message\n    await sendMessage(client, taskId, \"Hello! This is my first message!\");\n\n    // Second message to the same conversation\n    await sendMessage(\n      client,\n      taskId,\n      \"This is my second message. Do you remember our conversation?\"\n    );\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\nasync function sendMessage(client, taskId, text) {\n  console.log(`\\nSending message with task ID: ${taskId}`);\n  console.log(`Message: \"${text}\"`);\n\n  const message = {\n    role: \"user\",\n    parts: [\n      {\n        type: \"text\",\n        text: text,\n      },\n    ],\n  };\n\n  // Send a task\n  const task = await client.sendTask({\n    id: taskId,\n    message,\n  });\n\n  if (task) {\n    console.log(`Task status: ${task.status.state}`);\n\n    if (task.status.message) {\n      // Extract the text parts from the response\n      const textParts = task.status.message.parts\n        .filter((part) =&gt; part.type === \"text\")\n        .map((part) =&gt; part.text);\n\n      console.log(\"Agent response:\", textParts.join(\"\\n\"));\n    }\n  } else {\n    console.log(\"No task response received\");\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/file-storage-client.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node file-storage-client.js</code></li> </ol>"},{"location":"sdk/examples/file-storage-client.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/file-storage-server.html","title":"file-storage-server","text":"<p>File Storage A2A Server Example</p> <p>This example demonstrates how to create an A2A server that uses file-based storage for persisting tasks and message history between server restarts.</p>"},{"location":"sdk/examples/file-storage-server.html#source-code","title":"Source Code","text":"<pre><code>/**\n * File Storage A2A Server Example\n *\n * This example demonstrates how to create an A2A server that uses\n * file-based storage for persisting tasks and message history\n * between server restarts.\n */\n\nimport { A2AServer, FileStore, configureLogger } from \"../dist/index.js\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\n\n// Configure logging\nconfigureLogger({ level: \"info\" });\n\n// Ensure storage directory exists\nconst DATA_DIR = path.join(process.cwd(), \"data\");\ntry {\n  await fs.mkdir(DATA_DIR, { recursive: true });\n  console.log(`Storage directory created: ${DATA_DIR}`);\n} catch (error) {\n  console.error(`Failed to create storage directory: ${error}`);\n  process.exit(1);\n}\n\n/**\n * Implement a simple task handler with history awareness\n */\nasync function* historyAwareAgent(context) {\n  // Extract the user's most recent message\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  console.log(`Processing request: ${userText}`);\n\n  // Count user messages in history\n  const userMessageCount = context.history.filter(\n    (msg) =&gt; msg.role === \"user\"\n  ).length;\n\n  // Send a \"working\" status update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: \"Processing your request...\", type: \"text\" }],\n    },\n  };\n\n  // Simulate work\n  await new Promise((resolve) =&gt; setTimeout(resolve, 1000));\n\n  // Check for task cancellation\n  if (context.isCancelled()) {\n    console.log(\"Task was cancelled\");\n    yield {\n      state: \"canceled\",\n      message: {\n        role: \"agent\",\n        parts: [{ text: \"Processing has been cancelled.\", type: \"text\" }],\n      },\n    };\n    return;\n  }\n\n  // Create a history-aware response\n  let response;\n\n  if (userMessageCount === 1) {\n    response = `Hello! This is your first message: \"${userText}\". I'll remember our conversation.`;\n  } else {\n    // Summarize past messages\n    const pastUserMessages = context.history\n      .filter((msg) =&gt; msg.role === \"user\")\n      .slice(0, -1) // Exclude the current message\n      .map((msg) =&gt;\n        msg.parts\n          .filter((part) =&gt; part.type === \"text\")\n          .map((part) =&gt; part.text)\n          .join(\" \")\n      );\n\n    response = `You've sent ${userMessageCount} messages. Your previous messages were: ${JSON.stringify(\n      pastUserMessages\n    )}. Your current message is: \"${userText}\"`;\n  }\n\n  // Yield an artifact with conversation stats\n  yield {\n    name: \"conversation-stats.txt\",\n    parts: [\n      {\n        text: `Conversation statistics:\n- Total messages: ${context.history.length}\n- User messages: ${userMessageCount}\n- Agent messages: ${context.history.length - userMessageCount}\n`,\n        type: \"text\",\n      },\n    ],\n  };\n\n  // Yield a completed status with response message\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: response, type: \"text\" }],\n    },\n  };\n}\n\n// Create a server with file-based storage\nconst server = new A2AServer({\n  // Use file-based storage for persistence between restarts\n  taskStore: new FileStore(DATA_DIR),\n  handler: historyAwareAgent,\n\n  // Customize the port\n  port: 3000,\n\n  // Customize the agent card\n  card: {\n    url: \"http://localhost:3000\",\n    name: \"History-Aware Agent\",\n    description: \"An agent that remembers your conversation history\",\n    version: \"1.0.0\",\n    skills: [\n      {\n        id: \"history-aware\",\n        name: \"history-aware\",\n        description: \"An agent that remembers your conversation history\",\n      },\n    ],\n    capabilities: {\n      streaming: true,\n      stateTransitionHistory: true,\n    },\n  },\n});\n\n// Start the server\nserver.start();\nconsole.log(\"A2A Server started on port 3000 with file-based storage\");\nconsole.log(`Tasks and history will be stored in: ${DATA_DIR}`);\nconsole.log(\"Try connecting with an A2A client, then restart the server\");\nconsole.log(\"and continue the conversation with the same task ID!\");\n</code></pre>"},{"location":"sdk/examples/file-storage-server.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node file-storage-server.js</code></li> </ol>"},{"location":"sdk/examples/file-storage-server.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/nested-deployment.html","title":"nested-deployment","text":"<p>Example demonstrating nested-deployment</p>"},{"location":"sdk/examples/nested-deployment.html#source-code","title":"Source Code","text":"<pre><code>import {\n  ClientProxy,\n  Message,\n  Task,\n  TaskContext,\n  TaskYieldUpdate,\n} from \"@artinet/sdk\";\nimport { artinet } from \"@artinet/sdk/agents\";\n\nconsole.log(\"[SimpleEchoAgent] Starting\");\n\nexport async function* simpleEchoAgent(\n  context: TaskContext\n): AsyncGenerator&lt;TaskYieldUpdate, Task | void, unknown&gt; {\n  console.log(\"simpleEchoAgent called\");\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: \"Thinking about your request...\", type: \"text\" }],\n    },\n  };\n\n  const userText = context.userMessage.parts\n    .filter((part) =&gt; part.type === \"text\")\n    .map((part) =&gt; part.text)\n    .join(\" \");\n\n  console.log(`Processing request: ${userText}`);\n  try {\n    const agentClient: ClientProxy = artinet.v0.agent({\n      baseUrl:\n        \"https://agents.artinet.io/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349\",\n      headers: {},\n      fallback:\n        \"/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349/agent-card\",\n    });\n    const agentCard = await agentClient.agentCard();\n    console.log(\"agentCard: \", agentCard);\n    const message: Message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Write a python function to share files remotely. Please be concise and respond with code only. Please use the following format: def share_files(files: list[str]) -&gt; str: ...\",\n        },\n      ],\n    };\n    const task = await agentClient.sendTask({\n      id: \"111\",\n      message: message,\n    });\n    console.log(\"task returned: \", JSON.stringify(task, null, 2));\n    yield {\n      state: task?.status?.state || \"working\",\n      message: task?.status?.message\n        ? {\n            role: \"agent\",\n            parts: task?.status?.message?.parts.map((part) =&gt; ({\n              ...part,\n              text: part.type === \"text\" ? part.text : \"\",\n            })),\n          }\n        : {\n            role: \"agent\",\n            parts: [{ text: \"Task sent to Artinet...\", type: \"text\" }],\n          },\n    };\n  } catch (error) {\n    console.error(\"Error sending task: \", error);\n    yield {\n      state: \"failed\",\n      message: {\n        role: \"agent\",\n        parts: [{ text: \"Error sending task: \" + error, type: \"text\" }],\n      },\n    };\n  }\n  // Check for task cancellation\n  if (context.isCancelled()) {\n    console.log(\"Task was cancelled\");\n    yield {\n      state: \"canceled\",\n      message: {\n        role: \"agent\",\n        parts: [{ text: \"Processing has been cancelled.\", type: \"text\" }],\n      },\n    };\n    return;\n  }\n\n  // Create a response\n  const response = `You said: \"${userText}\". This is an echo server example.`;\n\n  // Yield an artifact (optional)\n  yield {\n    name: \"response.txt\",\n    parts: [{ text: response, type: \"text\" }],\n  };\n\n  // Yield a completed status with response message\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ text: response, type: \"text\" }],\n    },\n  };\n}\n\nawait artinet.v0.taskManager({ taskHandler: simpleEchoAgent });\nconsole.log(\"[SimpleEchoAgent] Finished\");\n</code></pre>"},{"location":"sdk/examples/nested-deployment.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node nested-deployment.ts</code></li> </ol>"},{"location":"sdk/examples/nested-deployment.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/streaming-updates.html","title":"streaming-updates","text":"<p>Streaming updates example for the Artinet SDK</p> <p>This example demonstrates how to: - Create an A2AClient instance - Check if streaming is supported - Send a task with streaming updates - Process updates as they arrive</p>"},{"location":"sdk/examples/streaming-updates.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Streaming updates example for the Artinet SDK\n *\n * This example demonstrates how to:\n * - Create an A2AClient instance\n * - Check if streaming is supported\n * - Send a task with streaming updates\n * - Process updates as they arrive\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance pointing to our local server\n    const client = new A2AClient(\"http://localhost:3000/api\");\n    console.log(\"Client initialized\");\n\n    // Check if streaming is supported\n    let streamingSupported = false;\n    try {\n      streamingSupported = await client.supports(\"streaming\");\n      console.log(`Streaming supported: ${streamingSupported ? \"Yes\" : \"No\"}`);\n    } catch (error) {\n      console.log(\n        \"Could not check streaming support, assuming it is supported...\"\n      );\n      streamingSupported = true; // Assume it's supported for this example\n    }\n\n    if (streamingSupported) {\n      // Create a message to send\n      const message = {\n        role: \"user\",\n        parts: [\n          {\n            type: \"text\",\n            text: \"Tell me a story about space exploration. Take your time and give details about different missions.\",\n          },\n        ],\n      };\n\n      // Generate a unique task ID\n      const taskId = `streaming-task-${Date.now()}`;\n      console.log(`Sending streaming task with ID: ${taskId}...`);\n\n      // Send the task and subscribe to updates\n      const stream = client.sendTaskSubscribe({\n        id: taskId,\n        message,\n      });\n\n      console.log(\"Processing streaming updates...\");\n\n      // Process the updates as they arrive\n      let responseText = \"\";\n\n      for await (const update of stream) {\n        // Check the type of update\n        if (\"status\" in update) {\n          console.log(`Task status update: ${update.status.state}`);\n\n          // If there's a message in this status update\n          if (update.status.message) {\n            const textParts = update.status.message.parts\n              .filter((part) =&gt; part.type === \"text\")\n              .map((part) =&gt; part.text);\n\n            const newText = textParts.join(\"\\n\");\n\n            // Check if this is new text or a replacement\n            if (\n              update.status.message.parts.some((part) =&gt; part.metadata?.append)\n            ) {\n              responseText += newText;\n            } else {\n              responseText = newText;\n            }\n\n            // Print the text received so far\n            console.log(`\\nResponse so far (${responseText.length} chars):`);\n            console.log(\"-------------------\");\n            console.log(responseText);\n            console.log(\"-------------------\\n\");\n          }\n\n          // If this is the final update, we're done\n          if (update.final) {\n            console.log(\"Final update received\");\n          }\n        } else if (\"artifact\" in update) {\n          // Handle artifact updates\n          console.log(\n            `Received artifact: ${update.artifact.name || \"unnamed\"}`\n          );\n\n          // Process artifact parts\n          for (const part of update.artifact.parts) {\n            if (part.type === \"text\") {\n              console.log(`Artifact text: ${part.text.substring(0, 100)}...`);\n            } else if (part.type === \"file\") {\n              console.log(`Artifact file: ${part.file.name || \"unnamed\"}`);\n              // In a real app, you might download the file from part.file.uri\n            }\n          }\n\n          // If this is the final artifact, note it\n          if (update.final) {\n            console.log(\"Final artifact received\");\n          }\n        }\n      }\n\n      console.log(\"Stream completed\");\n    } else {\n      console.log(\"Streaming is not supported by this agent\");\n    }\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/streaming-updates.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node streaming-updates.js</code></li> </ol>"},{"location":"sdk/examples/streaming-updates.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/task-resubscribe.html","title":"task-resubscribe","text":"<p>Task resubscription example for the Artinet SDK</p> <p>This example demonstrates how to: - Create an A2AClient instance - Send a task without subscribing initially - Resubscribe to an existing task to get updates</p>"},{"location":"sdk/examples/task-resubscribe.html#source-code","title":"Source Code","text":"<pre><code>/**\n * Task resubscription example for the Artinet SDK\n *\n * This example demonstrates how to:\n * - Create an A2AClient instance\n * - Send a task without subscribing initially\n * - Resubscribe to an existing task to get updates\n */\n\nimport { A2AClient } from \"../dist/index.js\";\n\nasync function main() {\n  try {\n    // Create a new client instance pointing to our local server\n    const client = new A2AClient(\"http://localhost:3000/api\");\n    console.log(\"Client initialized\");\n\n    // Create a message to send\n    const message = {\n      role: \"user\",\n      parts: [\n        {\n          type: \"text\",\n          text: \"Generate a detailed analysis of climate change impacts over the next 50 years. This should take some time.\",\n        },\n      ],\n    };\n\n    // Generate a unique task ID\n    const taskId = `long-running-task-${Date.now()}`;\n    console.log(`Sending task with ID: ${taskId}...`);\n\n    // First, send the task without subscribing\n    await client.sendTask({\n      id: taskId,\n      message,\n    });\n    console.log(\"Task sent successfully\");\n\n    console.log(\"Simulating a client disconnect...\");\n    // In a real application, this might be triggered by a client reconnection\n    // after a network interruption or browser refresh\n\n    // Wait for 2 seconds to simulate time passing\n    await new Promise((resolve) =&gt; setTimeout(resolve, 2000));\n\n    console.log(\"Client reconnected, resubscribing to task...\");\n\n    // Now resubscribe to the task to get updates\n    const stream = client.resubscribeTask({ id: taskId });\n    console.log(\"Resubscribed to task\");\n\n    // Process the updates as they arrive\n    console.log(\"Processing task updates after resubscription:\");\n    let responseText = \"\";\n\n    for await (const update of stream) {\n      // Check the type of update\n      if (\"status\" in update) {\n        console.log(`Task status update: ${update.status.state}`);\n\n        // Process message if present\n        if (update.status.message) {\n          const textParts = update.status.message.parts\n            .filter((part) =&gt; part.type === \"text\")\n            .map((part) =&gt; part.text);\n\n          responseText = textParts.join(\"\\n\");\n          console.log(`\\nResponse text (${responseText.length} chars):`);\n          console.log(\"-------------------\");\n          console.log(\n            responseText.substring(0, 200) +\n              (responseText.length &gt; 200 ? \"...\" : \"\")\n          );\n          console.log(\"-------------------\\n\");\n        }\n\n        // Check if this is the final update\n        if (update.final) {\n          console.log(\"Final update received, task is complete\");\n        }\n      } else if (\"artifact\" in update) {\n        // Handle artifact updates\n        console.log(`Received artifact: ${update.artifact.name || \"unnamed\"}`);\n\n        // Process artifact parts\n        for (const part of update.artifact.parts) {\n          if (part.type === \"text\") {\n            console.log(`Artifact text: ${part.text.substring(0, 100)}...`);\n          } else if (part.type === \"file\") {\n            console.log(`Artifact file: ${part.file.name || \"unnamed\"}`);\n            // In a real app, you might download the file from part.file.uri\n          }\n        }\n      }\n    }\n\n    console.log(\"Task stream completed\");\n  } catch (error) {\n    console.error(\"Error:\", error.message);\n\n    // If there's an error, try to get the current status of the task\n    if (error.message.includes(\"connection\") &amp;&amp; client) {\n      console.log(\"Attempting to check task status...\");\n      try {\n        const taskId = error.taskId || `long-running-task-${Date.now() - 2000}`;\n        const taskStatus = await client.getTask(taskId);\n        console.log(\"Current task status:\", taskStatus);\n      } catch (statusError) {\n        console.error(\"Could not retrieve task status:\", statusError.message);\n      }\n    }\n  }\n}\n\n// Run the example\nmain().catch(console.error);\n</code></pre>"},{"location":"sdk/examples/task-resubscribe.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node task-resubscribe.js</code></li> </ol>"},{"location":"sdk/examples/task-resubscribe.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/examples/task-wrapper.html","title":"task-wrapper","text":"<p>Example demonstrating task-wrapper</p>"},{"location":"sdk/examples/task-wrapper.html#source-code","title":"Source Code","text":"<pre><code>export const taskHandlerProxy = async (taskHandler) =&gt; {\n  if (!env.hostOnYield &amp;&amp; !env.Context) {\n    const err = new Error(\"invalid runtime environment\");\n    throw err;\n  }\n  const context = env.Context;\n  const onYieldProxy = env.hostOnYield;\n\n  if (!onYieldProxy || !context) {\n    const err = new Error(\"invalid runtime environment\");\n    throw err;\n  }\n  const generator = taskHandler(context);\n  for await (const yieldValue of generator) {\n    onYieldProxy(yieldValue);\n  }\n};\n\nexport const fetchResponseProxy = async (agentID, messages) =&gt; {\n  if (!env.hostFetchResponse) {\n    const err = new Error(\"invalid runtime environment\");\n    throw err;\n  }\n  const fetchResponseImpl = env.hostFetchResponse;\n  return fetchResponseImpl(agentID, messages);\n};\n</code></pre>"},{"location":"sdk/examples/task-wrapper.html#usage","title":"Usage","text":"<p>To run this example:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Navigate to the examples directory</li> <li>Run <code>npx ts-node task-wrapper.js</code></li> </ol>"},{"location":"sdk/examples/task-wrapper.html#expected-output","title":"Expected Output","text":""},{"location":"sdk/tests/index.html","title":"Artinet SDK Tests","text":"<p>This section contains documentation for the test suite of the Artinet SDK.</p>"},{"location":"sdk/tests/index.html#available-tests","title":"Available Tests","text":"<ul> <li>a2a-mcp.test - Tests for a2a mcp.test</li> <li>a2a-protocol.test - Tests for a2a protocol.test</li> <li>bundler.test - Tests for bundler.test</li> <li>client.test - Tests for client.test</li> <li>common-errors.test - Tests for common errors.test</li> <li>deployment.xx - Tests for deployment.xx</li> <li>file-storage.test - Tests for file storage.test</li> <li>http-utils.test - Tests for http utils.test</li> <li>integration.test - Tests for integration.test</li> <li>register.test - Tests for register.test</li> <li>rpc-client.test - Tests for rpc client.test</li> <li>server-error-handling.test - Tests for server error handling.test</li> <li>server-impl.test - Tests for server impl.test</li> <li>server.test - Tests for server.test</li> <li>streaming.test - Tests for streaming.test</li> </ul>"},{"location":"sdk/tests/index.html#running-all-tests","title":"Running All Tests","text":"<p>To run the full test suite:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run all tests with <code>npm test</code></li> </ol>"},{"location":"sdk/tests/index.html#test-coverage","title":"Test Coverage","text":"<p>To generate a test coverage report:</p> <pre><code>npm test -- --coverage\n</code></pre> <p>This will create a coverage report that can be viewed in the browser.</p>"},{"location":"sdk/tests/a2a-mcp.test.html","title":"a2a-mcp.test","text":"<p>Simple echo task handler for testing</p>"},{"location":"sdk/tests/a2a-mcp.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Client-Server Integration Tests</li> <li>express broker</li> </ul>"},{"location":"sdk/tests/a2a-mcp.test.html#source-code","title":"Source Code","text":"<pre><code>import { describe, beforeEach, test, expect, afterEach } from \"@jest/globals\";\nimport express from \"express\";\nimport http from \"http\";\nimport {\n  A2AClient,\n  TaskState,\n  logInfo,\n  configureLogger,\n  ExecutionContext,\n  MCPExecutionContext,\n  MessageSendParams,\n  SendMessageRequest,\n  InMemoryTaskStore,\n} from \"../src/index.js\";\nimport {\n  A2AExecutionContext,\n  AgentEngine,\n  MCPContext,\n} from \"../src/types/services/context.js\";\nimport { Protocol } from \"../src/types/services/protocol.js\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport { ServiceDispatcher } from \"../src/types/services/dispatcher.js\";\nimport { MCPService } from \"../src/services/mcp/index.js\";\nimport { A2AService } from \"../src/services/a2a/index.js\";\nimport { z } from \"zod\";\nimport { ExpressServer } from \"../src/server/lib/express-server.js\";\nimport expressListRoutes from \"express-list-routes\";\nimport request from \"supertest\";\n\nconfigureLogger({ level: \"silent\" });\n\n/**\n * Simple echo task handler for testing\n */\nconst echoAgent: AgentEngine = async function* (context: ExecutionContext) {\n  const userMessage =\n    context.protocol === Protocol.MCP\n      ? (context.getRequestParams() as MCPContext).message\n      : (context.getRequestParams() as MessageSendParams).message;\n  // Extract user text\n  const userText = userMessage;\n  // Send working status\n  yield {\n    taskId:\n      (context.getRequestParams() as MessageSendParams).message?.taskId ??\n      context.id,\n    contextId: context.id,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Working,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Processing...\" }],\n      },\n    },\n    final: false,\n  };\n  await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  // Check cancellation\n  if (context.isCancelled()) {\n    yield {\n      taskId: context.id,\n      contextId: context.id,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Canceled,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Task was canceled.\" }],\n        },\n      },\n      final: true,\n    };\n    return;\n  }\n\n  // Create a response\n  const response = `You said: \"${userText}\"`;\n\n  // Create an artifact\n  yield {\n    taskId: context.id,\n    contextId: context.id,\n    kind: \"artifact-update\",\n    artifact: {\n      artifactId: \"test-artifact-id\",\n      name: \"echo.txt\",\n      parts: [{ kind: \"text\", text: response }],\n    },\n  };\n\n  // Complete the task\n  yield {\n    id: context.id,\n    contextId: context.id,\n    kind: \"task\",\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: response }],\n      },\n    },\n  };\n};\n\nconst mockReq = (\n  method: string,\n  headers: Record&lt;string, string&gt; = {\n    \"mcp-session-id\": \"test-session-id\",\n    accept: \"application/json, text/event-stream\",\n    \"content-type\": \"application/json\",\n  },\n  body: any = {\n    jsonrpc: \"2.0\",\n    id: \"test-session-id\",\n    method: \"tools/call\",\n    params: {\n      name: \"test-skill\",\n      arguments: {\n        message: \"hello world\",\n      },\n    },\n  }\n) =&gt; {\n  return {\n    method: method,\n    headers: headers,\n    body: body,\n    on: (event: string, callback: (...args: any[]) =&gt; void) =&gt; {\n      logInfo(\"mockRequest\", event);\n    },\n    status: (code: number) =&gt; {\n      logInfo(\"mock request\", code.toString());\n    },\n    write: (payload: any) =&gt; {\n      logInfo(\"mock request\", payload);\n    },\n    writeHead: (code: number, headers: Record&lt;string, string&gt;) =&gt; {\n      logInfo(\"mock request\", code.toString(), headers);\n    },\n    send: (payload: any) =&gt; {\n      logInfo(\"mock request\", payload);\n    },\n    end: (payload: any) =&gt; {\n      logInfo(\"mock request\", payload);\n    },\n  };\n};\n\nconst mockRes = (\n  resolve: (value?: any) =&gt; void,\n  reject: (reason?: any) =&gt; void\n) =&gt; {\n  return {\n    on: (event: string, callback: (...args: any[]) =&gt; void) =&gt; {\n      logInfo(\"mockResponse\", \"on\", event);\n    },\n    onclose: () =&gt; {\n      logInfo(\"mockResponse\", \"onclose\");\n    },\n    onerror: (error: any) =&gt; {\n      logInfo(\"mockResponse\", \"onerror\", error);\n      reject(error);\n    },\n    onend: () =&gt; {\n      logInfo(\"mockResponse\", \"onend\");\n    },\n    ondata: (data: any) =&gt; {\n      logInfo(\"mockResponse\", \"ondata\", data);\n    },\n    ondrain: () =&gt; {\n      logInfo(\"mockResponse\", \"ondrain\");\n    },\n    onfinish: () =&gt; {\n      logInfo(\"mockResponse\", \"onfinish\");\n    },\n    write: (payload: any) =&gt; {\n      logInfo(\"mockResponse\", \"write\", payload);\n    },\n    writeHead: (code: number, headers: Record&lt;string, string&gt;) =&gt; {\n      logInfo(\"mockResponseWriteHead\", code.toString(), headers);\n      if (code !== 200 &amp;&amp; code !== 201 &amp;&amp; code !== 204 &amp;&amp; code !== 202) {\n        reject(new Error(`Mock response error: ${code}`));\n      }\n      return {\n        end: (arg: any) =&gt; {\n          logInfo(\"writeHead:mockResponseEnd\", arg);\n          resolve();\n        },\n        send: (payload: any) =&gt; {\n          logInfo(\"writeHead:mockResponseSend\", payload);\n        },\n      };\n    },\n    send: (payload: any) =&gt; {\n      logInfo(\"mockResponseSend\", payload);\n    },\n    end: (payload: any) =&gt; {\n      logInfo(\"mockResponseEnd\", payload);\n      resolve(payload);\n    },\n    status: (code: number) =&gt; {\n      logInfo(\"mockResponseStatus\", code.toString());\n    },\n  };\n};\n\ndescribe(\"Client-Server Integration Tests\", () =&gt; {\n  let dispatcher: ServiceDispatcher;\n  let mcpService: MCPService;\n  let a2aService: A2AService;\n  let client: A2AClient;\n\n  beforeEach(async () =&gt; {\n    // Create a simple server\n    a2aService = new A2AService({\n      taskStore: new InMemoryTaskStore(),\n      engine: echoAgent,\n      card: {\n        name: \"test-agent\",\n        description: \"test-description\",\n        url: \"test-url\",\n        version: \"1.0.0\",\n        capabilities: {\n          streaming: false,\n          pushNotifications: false,\n          stateTransitionHistory: false,\n        },\n        defaultInputModes: [\"text\"],\n        defaultOutputModes: [\"text\"],\n        skills: [\n          {\n            id: \"test-skill-id\",\n            name: \"test-skill\",\n            description: \"test-description\",\n            tags: [\"test-tag\"],\n          },\n        ],\n      },\n    });\n    mcpService = new MCPService({\n      serverInfo: {\n        name: \"test-mcp-server\",\n        version: \"1.0.0\",\n      },\n      engine: echoAgent,\n      skills: [...a2aService.state.getCard().skills],\n    });\n    mcpService.tool(\n      \"echo-skill\",\n      {\n        message: z.string(),\n      },\n      async ({ message }) =&gt; {\n        return {\n          content: [{ type: \"text\", text: message }],\n        };\n      }\n    );\n    dispatcher = new ServiceDispatcher({\n      services: {\n        [Protocol.A2A]: a2aService,\n        [Protocol.MCP]: mcpService,\n      },\n      engine: echoAgent,\n    });\n  });\n\n  test(\"dispatcher setup\", async () =&gt; {\n    expect(dispatcher).toBeDefined();\n  });\n\n  test(\"mcp service setup\", async () =&gt; {\n    expect(mcpService).toBeDefined();\n  });\n\n  test(\"a2a service setup\", async () =&gt; {\n    expect(a2aService).toBeDefined();\n  });\n\n  test(\"mcp execute\", async () =&gt; {\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () =&gt; \"test-session-id\",\n    });\n    transport.sessionId = \"test-session-id\";\n    // @ts-ignore\n    transport._initialized = true;\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      const executionContext: ExecutionContext&lt;MCPExecutionContext&gt; = {\n        id: \"test-session-id\",\n        protocol: Protocol.MCP,\n        getRequestParams: () =&gt; ({\n          message: \"Hello, world!\",\n        }),\n        isCancelled: () =&gt; false,\n        requestContext: {\n          protocol: Protocol.MCP,\n          id: \"test-session-id\",\n          method: \"tools/call\",\n          params: {\n            message: \"Hello, world!\",\n          },\n          request: mockReq(\"POST\"),\n          transport: transport,\n          response: mockRes(resolve, reject),\n        },\n      };\n      mcpService\n        .execute({\n          executionContext: executionContext,\n          engine: echoAgent,\n        })\n        .catch((error) =&gt; {\n          console.error(\"mcpService execute error\", error);\n          reject(error);\n        });\n    });\n  });\n\n  test(\"a2a execute\", async () =&gt; {\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      const mockA2AReq = mockReq(\n        \"POST\",\n        {},\n        {\n          message: \"Hello, world!\",\n        }\n      );\n      const mockA2ARes = mockRes(resolve, reject);\n      const messageSendContext: A2AExecutionContext&lt;SendMessageRequest&gt; = {\n        id: \"test-message-id\",\n        protocol: Protocol.A2A,\n        method: \"message/send\",\n        params: {\n          message: {\n            messageId: \"test-message-id\",\n            kind: \"message\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Hello, world!\" }],\n          },\n        },\n        request: mockA2AReq,\n        response: mockA2ARes,\n        task: {\n          id: \"test-message-id\",\n          contextId: \"test-message-id\",\n          status: {\n            state: TaskState.Working,\n            message: {\n              messageId: \"test-message-id\",\n              kind: \"message\",\n              role: \"user\",\n              parts: [{ kind: \"text\", text: \"Hello, world!\" }],\n            },\n          },\n          kind: \"task\",\n          metadata: {},\n        },\n      };\n      a2aService\n        .execute({\n          executionContext: {\n            id: \"test-message-id\",\n            protocol: Protocol.A2A,\n            getRequestParams: () =&gt; messageSendContext.params,\n            isCancelled: () =&gt; false,\n            requestContext: messageSendContext,\n          },\n          engine: echoAgent,\n        })\n        .catch((error) =&gt; {\n          console.error(\"a2a execute error\", error);\n          reject(error);\n        });\n    });\n  });\n\n  test(\"mcp onRequest\", async () =&gt; {\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () =&gt; \"test-session-id\",\n    });\n    transport.sessionId = \"test-session-id\";\n    // @ts-ignore\n    transport._initialized = true;\n    logInfo(\"transport\", transport.sessionId);\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      const mockRequest = mockReq(\"POST\");\n      const mockResponse = mockRes(resolve, reject);\n      dispatcher\n        .onRequest({\n          protocol: Protocol.MCP,\n          id: \"test-session-id\",\n          method: \"tools/call\",\n          params: {\n            message: \"Hello, world!\",\n          },\n          request: mockRequest,\n          response: mockResponse,\n          transport: transport,\n        })\n        .catch((error) =&gt; {\n          console.error(\"mcp onRequest error\", error);\n          reject(error);\n        });\n    });\n  });\n  test(\"a2a onRequest\", async () =&gt; {\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      const mockA2AReq = mockReq(\"POST\");\n      const mockA2ARes = mockRes(resolve, reject);\n      dispatcher\n        .onRequest({\n          protocol: Protocol.A2A,\n          id: \"test-message-id\",\n          method: \"message/send\",\n          params: {\n            message: {\n              messageId: \"test-message-id\",\n              kind: \"message\",\n              role: \"user\",\n              parts: [{ kind: \"text\", text: \"Hello, world!\" }],\n            },\n          },\n          request: mockA2AReq,\n          response: mockA2ARes,\n        })\n        .catch((error) =&gt; {\n          console.error(\"a2a onRequest error\", error);\n          reject(error);\n        });\n    });\n  });\n\n  test(\"mcp tool\", async () =&gt; {\n    const transport = new StreamableHTTPServerTransport({\n      sessionIdGenerator: () =&gt; \"test-session-id\",\n    });\n    transport.sessionId = \"test-session-id\";\n    // @ts-ignore\n    transport._initialized = true;\n    return new Promise&lt;void&gt;((resolve, reject) =&gt; {\n      const mockRequest = mockReq(\"POST\");\n      const mockResponse = mockRes(resolve, reject);\n      dispatcher\n        .onRequest({\n          protocol: Protocol.MCP,\n          id: \"test-session-id\",\n          method: \"tools/call\",\n          params: {\n            message: \"Echo This!\",\n          },\n          request: mockReq(\"POST\", undefined, {\n            jsonrpc: \"2.0\",\n            id: \"test-session-id\",\n            method: \"tools/call\",\n            params: {\n              name: \"echo-skill\",\n              arguments: {\n                message: \"Echo This!\",\n              },\n            },\n          }),\n          response: mockResponse,\n          transport: transport,\n        })\n        .catch((error) =&gt; {\n          console.error(\"mcp tool error\", error);\n          reject(error);\n        });\n    });\n  });\n\n  describe(\"express broker\", () =&gt; {\n    let app: express.Express;\n    let server: http.Server;\n    let broker: ExpressServer;\n    // Track any pending requests for cleanup\n    let pendingRequests: request.Test[] = [];\n\n    beforeEach(async () =&gt; {\n      broker = new ExpressServer({\n        storage: new InMemoryTaskStore(),\n        card: a2aService.state.getCard(),\n        engine: echoAgent,\n        services: {\n          [Protocol.MCP]: mcpService,\n          [Protocol.A2A]: a2aService,\n        },\n      });\n      broker.registerRoutes();\n      app = broker.getApp();\n      server = await broker.start();\n      pendingRequests = [];\n    });\n\n    afterEach(async () =&gt; {\n      // Ensure all pending requests are completed\n      await Promise.all(\n        pendingRequests.map((req) =&gt; {\n          try {\n            return req;\n          } catch (e) {\n            // Ignore errors during cleanup\n            return null;\n          }\n        })\n      );\n\n      await broker.stop();\n      // Add a small delay to allow any open connections to close\n      await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n    });\n\n    // Helper function to track supertest requests\n    const trackRequest = (req: request.Test): request.Test =&gt; {\n      pendingRequests.push(req);\n      return req;\n    };\n\n    test(\"express broker setup\", async () =&gt; {\n      const routes = expressListRoutes(app);\n      logInfo(\"express broker routes\", JSON.stringify(routes, null, 2));\n    });\n    test(\"express broker receive message\", async () =&gt; {\n      const response = await trackRequest(\n        request(server)\n          .post(\"/a2a\")\n          .send({\n            jsonrpc: \"2.0\",\n            id: \"test-session-id\",\n            method: \"message/send\",\n            params: {\n              message: {\n                messageId: \"test-message-id\",\n                kind: \"message\",\n                role: \"user\",\n                parts: [{ kind: \"text\", text: \"Hello, world!\" }],\n              },\n            },\n          })\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.kind).toBe(\"task\");\n      expect(response.body.result.status.state).toBe(TaskState.Completed);\n      expect(response.body.result.status.message).toBeDefined();\n      expect(response.body.result.status.message.kind).toBe(\"message\");\n      expect(response.body.result.status.message.role).toBe(\"agent\");\n      expect(response.body.result.status.message.parts).toBeDefined();\n      expect(response.body.result.status.message.parts[0].kind).toBe(\"text\");\n      expect(response.body.result.status.message.parts[0].text).toContain(\n        \"You said:\"\n      );\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/a2a-mcp.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest a2a-mcp.test.ts</code></li> </ol>"},{"location":"sdk/tests/a2a-mcp.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/a2a-protocol.test.html","title":"a2a-protocol.test","text":"<p>Tests for a2a protocol.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/a2a-protocol.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2A Protocol Specification Tests</li> <li>Agent Card</li> <li>Task States</li> <li>Message and Artifact Types</li> <li>Task Management</li> <li>Push Notification API</li> <li>Invalid Method Handling</li> </ul>"},{"location":"sdk/tests/a2a-protocol.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  jest,\n  describe,\n  it,\n  beforeEach,\n  afterEach,\n  expect,\n} from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  ExecutionContext,\n  InMemoryTaskStore,\n  A2AExecutionContext,\n  TaskState,\n  TaskStatusUpdateEvent,\n  TaskYieldUpdate,\n  TextPart,\n  UpdateEvent,\n  configureLogger,\n  MessageSendParams,\n  SendMessageRequest,\n} from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\n\n// Define a comprehensive task handler for A2A protocol testing\nasync function* a2aProtocolTestHandler(\n  context: ExecutionContext\n): AsyncGenerator&lt;UpdateEvent, void, unknown&gt; {\n  const params = context.getRequestParams() as MessageSendParams;\n  const taskId = params.message.taskId ?? context.id;\n  const contextId = context.id;\n  const text = params.message.parts\n    .filter((part) =&gt; part.kind === \"text\")\n    .map((part) =&gt; (part as TextPart).text)\n    .join(\" \");\n\n  // Test for all possible states in A2A protocol\n  if (text.includes(\"throw\")) {\n    throw new Error(\"Simulated task error\");\n  }\n\n  if (text.includes(\"fail\")) {\n    const yieldable: TaskStatusUpdateEvent = {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: true,\n      status: {\n        state: TaskState.Failed,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Task failed intentionally.\" }],\n        },\n      },\n    };\n    yield yieldable;\n    return;\n  }\n\n  if (text.includes(\"input-required\")) {\n    const yieldable: TaskStatusUpdateEvent = {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: true,\n      status: {\n        state: TaskState.InputRequired,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"need more information\" }],\n        },\n      },\n    };\n\n    yield yieldable;\n    return;\n  }\n\n  if (text.includes(\"working-only\")) {\n    const yieldable: TaskStatusUpdateEvent = {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: false,\n      status: {\n        state: TaskState.Working,\n        message: {\n          messageId: \"test-message-id-working-only\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Still working...\" }],\n        },\n      },\n    };\n\n    yield yieldable;\n    return;\n  }\n  if (text.includes(\"multi-part\")) {\n    yield {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: true,\n      status: {\n        state: TaskState.Working,\n        message: {\n          messageId: \"test-message-id-multi-part\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [\n            { kind: \"text\", text: \"First part\" },\n            { kind: \"data\", data: { key: \"value\" } },\n          ],\n        },\n      },\n    };\n\n    yield {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: true,\n      status: {\n        state: TaskState.Completed,\n        message: {\n          messageId: \"test-message-id-multi-part\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [\n            { kind: \"text\", text: \"Task completed with multiple part types.\" },\n            {\n              kind: \"file\",\n              file: {\n                name: \"test.txt\",\n                mimeType: \"text/plain\",\n                bytes: Buffer.from(\"test content\").toString(\"base64\"),\n              },\n            },\n          ],\n        },\n      },\n    };\n    return;\n  }\n\n  if (text.includes(\"streaming\")) {\n    yield {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: false,\n      status: {\n        state: TaskState.Working,\n        message: {\n          messageId: \"test-message-id-streaming\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Working...\" }],\n        },\n      },\n    };\n\n    yield {\n      taskId: taskId,\n      kind: \"artifact-update\",\n      contextId: contextId,\n      artifact: {\n        artifactId: \"test-artifact-id\",\n        name: \"partial-artifact\",\n        parts: [{ kind: \"text\", text: \"Partial \" }],\n      },\n    };\n\n    yield {\n      taskId: taskId,\n      kind: \"artifact-update\",\n      contextId: contextId,\n      artifact: {\n        artifactId: \"test-artifact-id\",\n        name: \"partial-artifact\",\n        parts: [{ kind: \"text\", text: \"Partial \" }],\n      },\n      append: true,\n      lastChunk: true,\n    };\n\n    yield {\n      taskId: taskId,\n      kind: \"status-update\",\n      contextId: contextId,\n      final: true,\n      status: {\n        state: TaskState.Completed,\n        message: {\n          messageId: \"test-message-id-streaming-completed\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Streaming completed!\" }],\n        },\n      },\n    };\n    return;\n  }\n\n  // Default case - normal processing\n  yield {\n    taskId: taskId,\n    kind: \"status-update\",\n    contextId: contextId,\n    final: false,\n    status: {\n      state: TaskState.Working,\n      message: {\n        messageId: \"test-message-id-working\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Working...\" }],\n      },\n    },\n  };\n\n  yield {\n    taskId: taskId,\n    kind: \"status-update\",\n    contextId: contextId,\n    final: true,\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id-completed\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Task completed successfully.\" }],\n      },\n    },\n  };\n}\n\ndescribe(\"A2A Protocol Specification Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    server = new A2AServer({\n      handler: a2aProtocolTestHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n      card: {\n        name: \"A2A Protocol Test Agent\",\n        url: \"http://localhost:41241\",\n        version: \"1.0.0\",\n        description: \"A2A Protocol Test Agent\",\n        defaultInputModes: [\"text\"],\n        defaultOutputModes: [\"text\"],\n        capabilities: {\n          streaming: true,\n          pushNotifications: true,\n          stateTransitionHistory: true,\n        },\n        skills: [\n          {\n            id: \"test\",\n            name: \"test\",\n            description: \"Test Skill Description\",\n            tags: [\"test\", \"skill\"],\n          },\n        ],\n      },\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Agent Card\", () =&gt; {\n    it(\"returns agent card at /.well-known/agent.json\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).get(\"/.well-known/agent.json\")\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.name).toBe(\"A2A Protocol Test Agent\");\n      expect(response.body.capabilities.streaming).toBe(true);\n      expect(response.body.capabilities.pushNotifications).toBe(true);\n      expect(response.body.skills).toHaveLength(1);\n      expect(response.body.skills[0].id).toBe(\"test\");\n    });\n\n    it(\"returns agent card at /agent-card\", async () =&gt; {\n      const response = await trackRequest(request(app).get(\"/agent-card\"));\n\n      expect(response.status).toBe(200);\n      expect(response.body.name).toBe(\"A2A Protocol Test Agent\");\n    });\n  });\n\n  describe(\"Task States\", () =&gt; {\n    it(\"handles task/send with task/completed state\", async () =&gt; {\n      const requestBody: SendMessageRequest = {\n        jsonrpc: \"2.0\",\n        id: \"test-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            messageId: \"test-message-id\",\n            kind: \"message\",\n            taskId: \"test-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Basic test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"test-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n      expect(response.body.result.status.message.parts[0].text).toBe(\n        \"Task completed successfully.\"\n      );\n    });\n\n    it(\"handles task/send with task/failed state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"fail-request-1\",\n        method: \"message/send\",\n        params: {\n          id: \"fail-task-1\",\n          message: {\n            taskId: \"fail-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This will fail\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"fail-task-1\");\n      expect(response.body.result.status.state).toBe(\"failed\");\n      expect(response.body.result.status.message.parts[0].text).toBe(\n        \"Task failed intentionally.\"\n      );\n    });\n\n    it(\"handles task/send with input-required state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"input-required-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"input-required-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This needs input-required\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"input-required-task-1\");\n      expect(response.body.result.status.state).toBe(\"input-required\");\n      expect(response.body.result.status.message.parts[0].text).toContain(\n        \"need more information\"\n      );\n    });\n\n    it(\"handles task/send with working state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"working-request-1\",\n        method: \"message/send\",\n        params: {\n          id: \"working-task-1\",\n          message: {\n            taskId: \"working-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This is working-only\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"working-task-1\");\n      expect(response.body.result.status.state).toBe(\"working\");\n      expect(response.body.result.status.message.parts[0].text).toContain(\n        \"Still working...\"\n      );\n    });\n  });\n\n  describe(\"Message and Artifact Types\", () =&gt; {\n    it(\"handles multiple part types and artifacts\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"multi-part-request-1\",\n        method: \"message/send\",\n        params: {\n          id: \"multi-part-task-1\",\n          message: {\n            taskId: \"multi-part-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This is multi-part\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"multi-part-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n\n      // Check multiple parts in message\n      expect(response.body.result.status.message.parts).toHaveLength(2);\n      expect(response.body.result.status.message.parts[0].kind).toBe(\"text\");\n      expect(response.body.result.status.message.parts[1].kind).toBe(\"file\");\n      expect(response.body.result.status.message.parts[1].file.name).toBe(\n        \"test.txt\"\n      );\n\n      // Check artifacts only if present (implementation may vary)\n      if (response.body.result.artifacts) {\n        expect(response.body.result.artifacts).toHaveLength(1);\n        expect(response.body.result.artifacts[0].name).toBe(\"test-artifact\");\n        expect(response.body.result.artifacts[0].description).toBe(\n          \"Test artifact description\"\n        );\n        expect(response.body.result.artifacts[0].parts[0].text).toBe(\n          \"Artifact content\"\n        );\n        expect(response.body.result.artifacts[0].metadata.testKey).toBe(\n          \"testValue\"\n        );\n      }\n    });\n  });\n\n  describe(\"Task Management\", () =&gt; {\n    it(\"retrieves task with tasks/get\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"create-request-1\",\n        method: \"message/send\",\n        params: {\n          id: \"retrieve-task-1\",\n          message: {\n            taskId: \"retrieve-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task to be retrieved\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now retrieve it\n      const retrieveBody = {\n        jsonrpc: \"2.0\",\n        id: \"retrieve-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"retrieve-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(retrieveBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"retrieve-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n    });\n\n    it(\"returns error for non-existent task\", async () =&gt; {\n      const retrieveBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(retrieveBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001); // Task not found error\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n\n    it(\"cancels a task with tasks/cancel\", async () =&gt; {\n      // First create a task that will stay in working state\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"cancel-create-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"cancel-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This is working-only\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now cancel it\n      const cancelBody = {\n        jsonrpc: \"2.0\",\n        id: \"cancel-request-1\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"cancel-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"cancel-task-1\");\n      expect(response.body.result.status.state).toBe(\"canceled\");\n    });\n\n    it(\"returns error when canceling non-existent task\", async () =&gt; {\n      const cancelBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-cancel-request-1\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001); // Task not found error\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n\n    it(\"returns error when canceling completed task\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"completed-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"completed-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task to be completed\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n      // Now try to cancel it\n      const cancelBody = {\n        jsonrpc: \"2.0\",\n        id: \"completed-cancel-request-1\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"completed-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32002);\n      expect(response.body.error.message).toBe(\"Task cannot be canceled\");\n    });\n  });\n\n  describe(\"Push Notification API\", () =&gt; {\n    it(\"sets push notification configuration\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-create-request-1\",\n        method: \"message/send\",\n        params: {\n          id: \"push-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task for push notifications\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now set push notification config\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-request-1\",\n        method: \"tasks/pushNotificationConfig/set\",\n        params: {\n          taskId: \"push-task-1\",\n          pushNotificationConfig: {\n            url: \"https://example.com/webhook\",\n            token: \"test-token\",\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n\n    it(\"does not get push notification configuration\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-create-request-1\",\n        method: \"message/send\",\n        params: {\n          id: \"push-get-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Task for push notifications\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createBody));\n\n      // Now try to get push notification config\n      const getBody = {\n        jsonrpc: \"2.0\",\n        id: \"push-get-request-1\",\n        method: \"tasks/pushNotificationConfig/get\",\n        params: {\n          id: \"push-get-task-1\",\n          config: {\n            url: \"https://example.com/webhook\",\n            token: \"test-token\",\n          },\n        },\n      };\n\n      const response = await trackRequest(request(app).post(\"/\").send(getBody));\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n    });\n\n    it(\"returns error when setting push notification for non-existent task\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-push-request-1\",\n        method: \"tasks/pushNotificationConfig/set\",\n        params: {\n          taskId: \"nonexistent-task-1\",\n          pushNotificationConfig: {\n            url: \"https://example.com/webhook\",\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n\n      // The implementation might return either a task not found error\n      // or a method not found error if push notifications aren't implemented\n      expect(response.body.error).toBeDefined();\n      expect([-32001, -32601, -32003]).toContain(response.body.error.code);\n    });\n  });\n\n  describe(\"Invalid Method Handling\", () =&gt; {\n    it(\"handles non-existent method\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-method-request-1\",\n        method: \"invalid/method\",\n        params: {\n          id: \"invalid-method-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32601); // Method not found error\n      expect(response.body.error.message).toBe(\"Method not found\");\n    });\n\n    it(\"handles invalid params\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-params-request-1\",\n        method: \"message/send\",\n        params: {},\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602); // Invalid params error\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/a2a-protocol.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest a2a-protocol.test.ts</code></li> </ol>"},{"location":"sdk/tests/a2a-protocol.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/bundler.test.html","title":"bundler.test","text":"<p>Tests for bundler.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/bundler.test.html#test-suites","title":"Test Suites","text":"<ul> <li>bundle</li> </ul>"},{"location":"sdk/tests/bundler.test.html#source-code","title":"Source Code","text":"<pre><code>import { describe, it, expect } from \"@jest/globals\";\nimport { bundle } from \"../src/index.js\";\nimport { configureLogger } from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\ndescribe(\"bundle\", () =&gt; {\n  it(\"should be defined\", () =&gt; {\n    expect(bundle).toBeDefined();\n  });\n\n  it(\"should bundle a file\", async () =&gt; {\n    const filePath = new URL(\"../examples/code-deployment.js\", import.meta.url);\n    const result = await bundle(filePath);\n    expect(result).toBeDefined();\n\n    // console.log(\"result: \", result);\n  });\n});\n</code></pre>"},{"location":"sdk/tests/bundler.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest bundler.test.ts</code></li> </ol>"},{"location":"sdk/tests/bundler.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/client.test.html","title":"client.test","text":"<p>Tests for client.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/client.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2AClient</li> </ul>"},{"location":"sdk/tests/client.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  test,\n  describe,\n  expect,\n  beforeEach,\n  beforeAll,\n  afterAll,\n} from \"@jest/globals\";\n\nimport {\n  A2AClient,\n  SystemError,\n  AgentCard,\n  Message,\n  Task,\n  TaskState,\n  MessageSendParams,\n  TaskStatusUpdateEvent,\n  TaskArtifactUpdateEvent,\n  TaskPushNotificationConfig,\n  TaskIdParams,\n  TaskQueryParams,\n  PushNotificationConfig,\n  configureLogger,\n} from \"../src/index.js\";\nimport { http, HttpResponse } from \"msw\";\nimport { setupServer } from \"msw/node\";\n\nconfigureLogger({ level: \"silent\" });\n\nconst MOCK_AGENT_CARD: AgentCard = {\n  name: \"Test Agent\",\n  description: \"A test agent for unit tests\",\n  url: \"https://test-agent.example.com/api\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,\n    pushNotifications: true,\n    stateTransitionHistory: false,\n  },\n  skills: [\n    {\n      id: \"test-skill\",\n      name: \"Test Skill\",\n      description: \"A test skill for unit tests\",\n      tags: [\"test\", \"skill\"],\n    },\n  ],\n  defaultInputModes: [\"text\"],\n  defaultOutputModes: [\"text\"],\n};\n\nconst MOCK_TASK: Task = {\n  id: \"test-task-123\",\n  kind: \"task\",\n  status: {\n    state: \"completed\" as TaskState,\n    message: {\n      messageId: \"test-message-id\",\n      kind: \"message\",\n      role: \"agent\",\n      parts: [\n        {\n          kind: \"text\",\n          text: \"This is a test response\",\n        },\n      ],\n    },\n    timestamp: new Date().toISOString(),\n  },\n  artifacts: [\n    {\n      artifactId: \"test-artifact-id\",\n      name: \"test-artifact\",\n      parts: [\n        {\n          kind: \"text\",\n          text: \"Artifact content\",\n        },\n      ],\n    },\n  ],\n};\n\n// Task update events for streaming\nconst STATUS_UPDATE_EVENT: TaskStatusUpdateEvent = {\n  taskId: \"test-task-123\",\n  contextId: \"test-context-id\",\n  kind: \"status-update\",\n  final: false,\n  status: {\n    state: \"working\" as TaskState,\n    timestamp: new Date().toISOString(),\n  },\n};\n\nconst ARTIFACT_UPDATE_EVENT: TaskArtifactUpdateEvent = {\n  taskId: \"test-task-123\",\n  contextId: \"test-context-id\",\n  kind: \"artifact-update\",\n  artifact: {\n    artifactId: \"test-artifact-id\",\n    name: \"new-artifact\",\n    parts: [\n      {\n        kind: \"text\",\n        text: \"New artifact content\",\n      },\n    ],\n  },\n};\n\nconst MOCK_NOTIFICATION_CONFIG: PushNotificationConfig = {\n  url: \"https://notification-endpoint.example.com\",\n  token: \"test-notification-token\",\n};\n\nconst MOCK_PUSH_NOTIFICATION_CONFIG: TaskPushNotificationConfig = {\n  taskId: \"test-task-123\",\n  pushNotificationConfig: MOCK_NOTIFICATION_CONFIG,\n};\n\n// Setup MSW server for mocking HTTP requests\nconst server = setupServer(\n  // Mock agent card endpoint\n  http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n    return HttpResponse.json(MOCK_AGENT_CARD);\n  }),\n\n  // Mock fallback agent card endpoint\n  http.get(\"https://test-agent.example.com/agent-card\", () =&gt; {\n    return HttpResponse.json(MOCK_AGENT_CARD);\n  }),\n\n  // Mock message/send endpoint\n  http.post(\"https://test-agent.example.com\", async ({ request }) =&gt; {\n    const body = (await request.json()) as {\n      method: string;\n      id: string | number;\n      params?: Record&lt;string, any&gt;;\n    };\n\n    if (body.method === \"message/send\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: MOCK_TASK,\n      });\n    }\n\n    if (body.method === \"tasks/get\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: MOCK_TASK,\n      });\n    }\n\n    if (body.method === \"tasks/cancel\") {\n      const canceledTask = {\n        ...MOCK_TASK,\n        status: {\n          ...MOCK_TASK.status,\n          state: \"canceled\",\n        },\n      };\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: canceledTask,\n      });\n    }\n\n    if (body.method === \"tasks/pushNotificationConfig/set\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: body.params,\n      });\n    }\n\n    if (body.method === \"tasks/pushNotificationConfig/get\") {\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: MOCK_PUSH_NOTIFICATION_CONFIG,\n      });\n    }\n\n    if (\n      body.method === \"message/stream\" ||\n      body.method === \"tasks/resubscribe\"\n    ) {\n      // For streaming endpoints, create a mock SSE response\n      // This is a simplified implementation since MSW doesn't handle SSE natively\n      // We'll create a text response with the correct format\n      const eventData1 = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: STATUS_UPDATE_EVENT,\n      });\n\n      const eventData2 = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: body.id,\n        result: ARTIFACT_UPDATE_EVENT,\n      });\n\n      // Create a text response that mimics SSE format\n      const responseText =\n        `event: event\\ndata: ${eventData1}\\n\\n` +\n        `event: event\\ndata: ${eventData2}\\n\\n`;\n      return new HttpResponse(responseText, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n    }\n\n    // Default case for unhandled methods\n    return HttpResponse.json(\n      {\n        jsonrpc: \"2.0\",\n        id: body.id,\n        error: {\n          code: -32601,\n          message: \"Method not found\",\n        },\n      },\n      { status: 400 }\n    );\n  })\n);\n\ndescribe(\"A2AClient\", () =&gt; {\n  let client: A2AClient;\n\n  beforeAll(() =&gt; {\n    server.listen();\n  });\n\n  afterAll(() =&gt; {\n    server.close();\n  });\n\n  beforeEach(() =&gt; {\n    client = new A2AClient(\"https://test-agent.example.com\");\n    server.resetHandlers();\n  });\n\n  // Test agent card retrieval\n  test(\"should fetch an agent card\", async () =&gt; {\n    const card = await client.agentCard();\n    expect(card).toEqual(MOCK_AGENT_CARD);\n\n    // Test the cached card path (line 51 in client.ts)\n    // This second call should use the cached card without making a network request\n\n    // Override the server to return a different card,\n    // if the cache is used, we'll still get the original\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return HttpResponse.json({\n          ...MOCK_AGENT_CARD,\n          version: \"2.0.0\", // Changed version\n        });\n      })\n    );\n\n    const cachedCard = await client.agentCard();\n    // Verify we got the original card (from cache) not the new one\n    expect(cachedCard).toEqual(MOCK_AGENT_CARD);\n    expect(cachedCard.version).toBe(\"1.0.0\"); // Original version, not 2.0.0\n  });\n\n  // Test agent card refreshing\n  test(\"should refresh an agent card\", async () =&gt; {\n    // First get the card to cache it\n    await client.agentCard();\n\n    // Mock a change to the agent card on the server\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return HttpResponse.json({\n          ...MOCK_AGENT_CARD,\n          version: \"1.1.0\",\n        });\n      })\n    );\n\n    // Refresh the card\n    const updatedCard = await client.refreshAgentCard();\n    expect(updatedCard.version).toBe(\"1.1.0\");\n  });\n\n  // Test fallback to secondary card URL\n  test(\"should fetch agent card from fallback URL when primary fails\", async () =&gt; {\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return new HttpResponse(null, { status: 404 });\n      })\n    );\n\n    const card = await client.agentCard();\n    expect(card).toEqual(MOCK_AGENT_CARD);\n  });\n\n  // Test agent card fetching error\n  test(\"should throw when both agent card endpoints fail\", async () =&gt; {\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return new HttpResponse(\"Not found\", {\n          status: 404,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      }),\n      http.get(\"https://test-agent.example.com/agent-card\", () =&gt; {\n        return new HttpResponse(\"Server error\", {\n          status: 500,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    await expect(client.agentCard()).rejects.toThrow();\n  });\n\n  // Test constructor with string URL and headers\n  test(\"should construct client with string URL and headers\", () =&gt; {\n    const testClient = new A2AClient(\"https://example.com\", {\n      Authorization: \"Bearer test-token\",\n    });\n\n    // Check internal state\n    expect((testClient as any).baseUrl.href).toBe(\"https://example.com/\");\n    expect((testClient as any).customHeaders[\"Authorization\"]).toBe(\n      \"Bearer test-token\"\n    );\n  });\n\n  // Test sending a task\n  test(\"should send a task and receive a response\", async () =&gt; {\n    const message: Message = {\n      messageId: \"test-message-id\",\n      kind: \"message\",\n      role: \"user\",\n      parts: [\n        {\n          kind: \"text\",\n          text: \"Hello, this is a test message\",\n        },\n      ],\n    };\n\n    const params: MessageSendParams = {\n      message,\n    };\n\n    const task = await client.sendTask(params);\n    expect(task).toEqual(MOCK_TASK);\n  });\n\n  // Test getting a task\n  test(\"should get a task by ID\", async () =&gt; {\n    const task = await client.getTask({ id: \"test-task-123\" });\n    expect(task).toEqual(MOCK_TASK);\n  });\n\n  // Test canceling a task\n  test(\"should cancel a task\", async () =&gt; {\n    const task = await client.cancelTask({ id: \"test-task-123\" });\n    expect(task).toMatchObject({\n      id: \"test-task-123\",\n      status: {\n        state: \"canceled\",\n      },\n    });\n  });\n\n  // Test push notification config setting\n  test(\"should set task push notification config\", async () =&gt; {\n    const config: TaskPushNotificationConfig = {\n      taskId: \"test-task-123\",\n      pushNotificationConfig: {\n        url: \"https://notification-endpoint.example.com\",\n        token: \"test-notification-token\",\n      },\n    };\n\n    const result = await client.setTaskPushNotification(config);\n    expect(result).toEqual(config);\n  });\n\n  // Test push notification config getting\n  test(\"should get task push notification config\", async () =&gt; {\n    const params: TaskIdParams = {\n      id: \"test-task-123\",\n    };\n\n    const config = await client.getTaskPushNotification(params);\n    expect(config).toEqual(MOCK_PUSH_NOTIFICATION_CONFIG);\n  });\n\n  // Test streaming task updates\n  test(\"should stream task updates\", async () =&gt; {\n    const message: Message = {\n      messageId: \"test-message-id\",\n      kind: \"message\",\n      role: \"user\",\n      parts: [\n        {\n          kind: \"text\",\n          text: \"Hello, this is a test message\",\n        },\n      ],\n    };\n\n    const params: MessageSendParams = {\n      message,\n    };\n\n    const events: (\n      | Task\n      | TaskStatusUpdateEvent\n      | TaskArtifactUpdateEvent\n      | Message\n    )[] = [];\n    const stream = client.sendTaskSubscribe(params);\n    for await (const event of stream) {\n      events.push(event);\n    }\n\n    expect(events.length).toBe(2);\n    // Check event types without explicit type property references\n    expect(events[0]).toHaveProperty(\"status\"); // It's a status update\n    expect(events[1]).toHaveProperty(\"artifact\"); // It's an artifact update\n  });\n\n  // Test resubscribe task updates\n  test(\"should resubscribe to task updates\", async () =&gt; {\n    const params: TaskQueryParams = {\n      id: \"test-task-123\",\n    };\n\n    const events: (\n      | Task\n      | TaskStatusUpdateEvent\n      | TaskArtifactUpdateEvent\n      | Message\n    )[] = [];\n\n    for await (const event of client.resubscribeTask(params)) {\n      events.push(event);\n    }\n\n    expect(events.length).toBe(2);\n    // Check event types without explicit type property references\n    expect(events[0]).toHaveProperty(\"status\"); // It's a status update\n    expect(events[1]).toHaveProperty(\"artifact\"); // It's an artifact update\n  });\n\n  // Test error handling - network errors\n  test(\"should handle network errors during HTTP request\", async () =&gt; {\n    // Mock a network error by using a response that forces a fetch error\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(null, { status: 500 });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - invalid JSON response\n  test(\"should handle invalid JSON response\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(\"This is not JSON\", {\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - invalid JSON-RPC structure\n  test(\"should handle invalid JSON-RPC structure\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return HttpResponse.json({ not: \"valid-jsonrpc\" });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - HTTP error with JSON-RPC error\n  test(\"should handle HTTP error with JSON-RPC error\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return HttpResponse.json(\n          {\n            jsonrpc: \"2.0\",\n            id: \"123\",\n            error: {\n              code: -32000,\n              message: \"Task not found\",\n            },\n          },\n          { status: 400 }\n        );\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling - HTTP error with non-JSON response\n  test(\"should handle HTTP error with non-JSON response\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(\"Internal Server Error\", {\n          status: 500,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    await expect(client.getTask({ id: \"test-task-123\" })).rejects.toThrow();\n  });\n\n  // Test error handling for streaming - response not OK\n  test(\"should handle streaming error when response is not OK\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return new HttpResponse(\"Bad Request\", {\n          status: 400,\n          headers: { \"Content-Type\": \"text/plain\" },\n        });\n      })\n    );\n\n    const stream = client.sendTaskSubscribe({\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"user\",\n        parts: [{ kind: \"text\", text: \"Test\" }],\n      },\n    });\n\n    await expect(async () =&gt; {\n      for await (const event of stream) {\n        // This should not execute\n      }\n    }).rejects.toThrow();\n  });\n\n  // Test capability check - edge case with no capabilities\n  test(\"should handle agent card with no capabilities\", async () =&gt; {\n    // First ensure the agent card is cached with valid data\n    await client.agentCard();\n\n    server.use(\n      http.get(\"https://test-agent.example.com/.well-known/agent.json\", () =&gt; {\n        return HttpResponse.json({\n          ...MOCK_AGENT_CARD,\n          capabilities: undefined,\n        });\n      })\n    );\n\n    // Force refresh to clear the cache\n    await client.refreshAgentCard();\n\n    const hasStreaming = await client.supports(\"streaming\");\n    expect(hasStreaming).toBe(false);\n  });\n\n  // Test capability check error handling\n  test(\"should handle error during capability check\", async () =&gt; {\n    // Re-use the server default handlers which have valid responses\n    // This ensures the test doesn't fail when trying to fetch the agent card\n\n    // Create a client with a known invalid URL to simulate error\n    const badClient = new A2AClient(\"https://invalid-url.example.com\");\n\n    // Mock a failed request for the invalid URL\n    server.use(\n      http.get(\"https://invalid-url.example.com/.well-known/agent.json\", () =&gt; {\n        return new HttpResponse(null, { status: 404 });\n      }),\n      http.get(\"https://invalid-url.example.com/agent-card\", () =&gt; {\n        return new HttpResponse(null, { status: 404 });\n      })\n    );\n\n    const hasStreaming = await badClient.supports(\"streaming\");\n    expect(hasStreaming).toBe(false);\n  });\n\n  // Test error handling\n  test(\"should handle JSON-RPC errors\", async () =&gt; {\n    server.use(\n      http.post(\"https://test-agent.example.com\", () =&gt; {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: \"123\",\n          error: {\n            code: -32000,\n            message: \"Task not found\",\n          },\n        });\n      })\n    );\n\n    await expect(client.getTask({ id: \"nonexistent-task\" })).rejects.toThrow(\n      SystemError\n    );\n  });\n\n  // Test capability check\n  test(\"should check if a capability is supported\", async () =&gt; {\n    // First, ensure the agent card is cached\n    await client.agentCard();\n\n    const hasStreaming = await client.supports(\"streaming\");\n    expect(hasStreaming).toBe(true);\n\n    const hasPushNotifications = await client.supports(\"pushNotifications\");\n    expect(hasPushNotifications).toBe(true);\n\n    const hasStateTransitionHistory = await client.supports(\n      \"stateTransitionHistory\"\n    );\n    expect(hasStateTransitionHistory).toBe(false);\n\n    // Test the default case in the switch statement for uncovered branch\n    const hasUnsupportedCapability = await client.supports(\n      \"unknownCapability\" as any\n    );\n    expect(hasUnsupportedCapability).toBe(false);\n  });\n\n  // Test header management\n  test(\"should manage custom headers\", () =&gt; {\n    // Add a header\n    client.addHeader(\"Authorization\", \"Bearer test-token\");\n\n    // Check internal state (this is a private test hack, normally wouldn't test private members)\n    const headers = (client as any).customHeaders;\n    expect(headers[\"Authorization\"]).toBe(\"Bearer test-token\");\n\n    // Add another header\n    client.addHeader(\"X-Custom-Header\", \"test-value\");\n    expect((client as any).customHeaders[\"X-Custom-Header\"]).toBe(\"test-value\");\n\n    // Replace all headers\n    client.setHeaders({\n      \"Content-Type\": \"application/json\",\n      \"Accept-Language\": \"en-US\",\n    });\n\n    const newHeaders = (client as any).customHeaders;\n    expect(newHeaders[\"Authorization\"]).toBeUndefined();\n    expect(newHeaders[\"Content-Type\"]).toBe(\"application/json\");\n    expect(newHeaders[\"Accept-Language\"]).toBe(\"en-US\");\n\n    // Remove a header\n    client.removeHeader(\"Content-Type\");\n    expect((client as any).customHeaders[\"Content-Type\"]).toBeUndefined();\n\n    // Clear all headers\n    client.clearHeaders();\n    expect(Object.keys((client as any).customHeaders).length).toBe(0);\n  });\n});\n</code></pre>"},{"location":"sdk/tests/client.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest client.test.ts</code></li> </ol>"},{"location":"sdk/tests/client.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/common-errors.test.html","title":"common-errors.test","text":"<p>Tests for common errors.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/common-errors.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Error Handling Utilities</li> <li>SystemError</li> <li>Error Factories</li> <li>FAILED_UPDATE</li> <li>Error Constants</li> </ul>"},{"location":"sdk/tests/common-errors.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  SystemError,\n  PARSE_ERROR,\n  METHOD_NOT_FOUND,\n  INVALID_REQUEST,\n  INVALID_PARAMS,\n  INTERNAL_ERROR,\n  TASK_NOT_FOUND,\n  TASK_NOT_CANCELABLE,\n  UNSUPPORTED_OPERATION,\n  PUSH_NOTIFICATION_NOT_SUPPORTED,\n  FAILED_UPDATE,\n  ErrorCodeParseError,\n  ErrorCodeInvalidParams,\n  ErrorCodeInternalError,\n  ErrorCodeInvalidRequest,\n  ErrorCodeMethodNotFound,\n  ErrorCodeTaskNotFound,\n  ErrorCodeTaskNotCancelable,\n  ErrorCodeUnsupportedOperation,\n  ErrorCodePushNotificationNotSupported,\n  configureLogger,\n} from \"../src/index.js\";\nimport { describe, it, expect } from \"@jest/globals\";\n\nconfigureLogger({ level: \"silent\" });\n\ndescribe(\"Error Handling Utilities\", () =&gt; {\n  describe(\"SystemError\", () =&gt; {\n    it(\"should create a SystemError with proper attributes\", () =&gt; {\n      const error = new SystemError(\"System operation failed\", -12345, {\n        detail: \"Additional error information\",\n      });\n      expect(error.name).toBe(\"Error\");\n      expect(error.message).toBe(\"System operation failed\");\n      expect(error.code).toBe(-12345);\n      expect(error).toBeInstanceOf(Error);\n      expect(error).toBeInstanceOf(SystemError);\n    });\n\n    it(\"should include optional data in error object\", () =&gt; {\n      const data = { detail: \"Additional error information\" };\n      const error = new SystemError(\"Error with data\", -32000, data);\n      expect(error.data).toEqual(data);\n    });\n  });\n\n  describe(\"Error Factories\", () =&gt; {\n    it(\"should create Parse Error\", () =&gt; {\n      const error = PARSE_ERROR(\"Invalid JSON payload\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeParseError);\n      expect(error.message).toBe(\"Invalid JSON payload\");\n    });\n\n    it(\"should create Invalid Request Error\", () =&gt; {\n      const error = INVALID_REQUEST(\"Invalid request\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeInvalidRequest);\n      expect(error.message).toBe(\"Request payload validation error\");\n    });\n\n    it(\"should create Method Not Found Error\", () =&gt; {\n      const error = METHOD_NOT_FOUND(\"Method not found\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeMethodNotFound);\n      expect(error.message).toBe(\"Method not found\");\n    });\n\n    it(\"should create Invalid Params Error\", () =&gt; {\n      const error = INVALID_PARAMS(\"Invalid parameters\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeInvalidParams);\n      expect(error.message).toBe(\"Invalid parameters\");\n    });\n\n    it(\"should create Internal Error\", () =&gt; {\n      const error = INTERNAL_ERROR(\"Internal error\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeInternalError);\n      expect(error.message).toBe(\"Internal error\");\n    });\n\n    it(\"should create Task Not Found Error\", () =&gt; {\n      const error = TASK_NOT_FOUND(\"Task not found\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeTaskNotFound);\n      expect(error.message).toBe(\"Task not found\");\n    });\n\n    it(\"should create Task Not Cancelable Error\", () =&gt; {\n      const error = TASK_NOT_CANCELABLE(\"Task cannot be canceled\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeTaskNotCancelable);\n      expect(error.message).toBe(\"Task cannot be canceled\");\n    });\n\n    it(\"should create Unsupported Operation Error\", () =&gt; {\n      const error = UNSUPPORTED_OPERATION(\"This operation is not supported\");\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodeUnsupportedOperation);\n      expect(error.message).toBe(\"This operation is not supported\");\n    });\n\n    it(\"should create Push Notification Not Supported Error\", () =&gt; {\n      const error = PUSH_NOTIFICATION_NOT_SUPPORTED(\n        \"Push Notification is not supported\"\n      );\n      expect(error).toBeInstanceOf(SystemError);\n      expect(error.code).toBe(ErrorCodePushNotificationNotSupported);\n      expect(error.message).toBe(\"Push Notification is not supported\");\n    });\n\n    it(\"should include data in created error\", () =&gt; {\n      const data = { field: \"taskId\", reason: \"not found\" };\n      const error = TASK_NOT_FOUND(data);\n      expect(error.data).toEqual(data);\n    });\n  });\n\n  describe(\"FAILED_UPDATE\", () =&gt; {\n    it(\"should create a failed task update\", () =&gt; {\n      const message = \"Task execution failed\";\n      const update = FAILED_UPDATE(\"taskId\", \"contextId\", \"agent\", message);\n\n      // Test the structure without relying on specific type\n      const failedUpdate = update as any;\n      expect(failedUpdate.status.state).toBe(\"failed\");\n      expect(failedUpdate.status.message).toBeDefined();\n      expect(failedUpdate.status.message.role).toBe(\"agent\");\n      expect(Array.isArray(failedUpdate.status.message.parts)).toBe(true);\n      expect(failedUpdate.status.message.parts).toHaveLength(1);\n      expect(failedUpdate.status.message.parts[0].kind).toBe(\"text\");\n      expect(failedUpdate.status.message.parts[0].text).toBe(message);\n    });\n  });\n\n  describe(\"Error Constants\", () =&gt; {\n    it(\"should have the correct error code values\", () =&gt; {\n      expect(ErrorCodeParseError).toBe(-32700);\n      expect(ErrorCodeInvalidParams).toBe(-32602);\n      expect(ErrorCodeInternalError).toBe(-32603);\n      expect(ErrorCodeInvalidRequest).toBe(-32600);\n      expect(ErrorCodeMethodNotFound).toBe(-32601);\n      expect(ErrorCodeTaskNotFound).toBe(-32001);\n      expect(ErrorCodeTaskNotCancelable).toBe(-32002);\n      expect(ErrorCodeUnsupportedOperation).toBe(-32004);\n      expect(ErrorCodePushNotificationNotSupported).toBe(-32003);\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/common-errors.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest common-errors.test.ts</code></li> </ol>"},{"location":"sdk/tests/common-errors.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/deployment.xx.html","title":"deployment.xx","text":"<p>Tests for deployment.xx functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/deployment.xx.html#test-suites","title":"Test Suites","text":"<ul> <li>TestDeployment</li> <li>FullDeployment</li> </ul>"},{"location":"sdk/tests/deployment.xx.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport {\n  testDeployment,\n  configureLogger,\n  SendMessageRequest,\n  Message,\n  AgentCard,\n  ServerDeploymentRequestParams,\n  ServerDeploymentResponse,\n  Task,\n  bundle,\n  fullDeployment,\n  MessageSendParams,\n} from \"../src/index.js\";\nimport { logDebug } from \"../src/utils/logging/log.js\";\nimport { A2AClient } from \"../src/index.js\";\n\nconfigureLogger({ level: \"trace\" });\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\n\nconst basicTest = \"throw new Error('test'); export default 'ok';\";\nconst coderCode = await bundle(\n  new URL(\"../examples/code-deployment.js\", import.meta.url)\n);\nconst ts_coderCode = await bundle(\n  new URL(\"../examples/code-deployment.ts\", import.meta.url)\n);\n\nconst nestedTestCode = await bundle(\n  new URL(\"../examples/nested-deployment.ts\", import.meta.url)\n);\n\nconst MOCK_AGENT_CARD: AgentCard = {\n  name: \"Quick-Agent-v0\",\n  description: \"A test agent for unit tests\",\n  url: \"https://test-agent.example.com/api\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,\n    pushNotifications: true,\n    stateTransitionHistory: false,\n  },\n  skills: [\n    {\n      id: \"test-skill\",\n      name: \"Test Skill\",\n      description: \"A test skill for unit tests\",\n      tags: [\"test\", \"skill\"],\n    },\n  ],\n  defaultInputModes: [\"text\"],\n  defaultOutputModes: [\"text\"],\n};\n\nconst MOCK_AGENT_CARD_NESTED: AgentCard = {\n  name: \"Quick-Agent-v0-Nested\",\n  description: \"A test agent for unit tests\",\n  url: \"https://test-agent.example.com/api\",\n  version: \"1.0.0\",\n  capabilities: {\n    streaming: true,\n    pushNotifications: true,\n    stateTransitionHistory: false,\n  },\n  skills: [\n    {\n      id: \"test-skill\",\n      name: \"Test Skill\",\n      description: \"A test skill for unit tests\",\n      tags: [\"test\", \"skill\"],\n    },\n  ],\n  defaultInputModes: [\"text\"],\n  defaultOutputModes: [\"text\"],\n};\n\nconst testParams: ServerDeploymentRequestParams = {\n  name: \"Test Agent\",\n  agentCard: MOCK_AGENT_CARD,\n  code: basicTest,\n};\n\nconst coderTestParams: ServerDeploymentRequestParams = {\n  name: \"Test Agent\",\n  agentCard: MOCK_AGENT_CARD,\n  code: coderCode,\n};\n\nconst ts_coderTestParams: ServerDeploymentRequestParams = {\n  name: \"Test Agent\",\n  agentCard: MOCK_AGENT_CARD,\n  code: ts_coderCode,\n};\n\nconst nestedTestParams: ServerDeploymentRequestParams = {\n  name: \"Nested Agent\",\n  agentCard: MOCK_AGENT_CARD_NESTED,\n  code: nestedTestCode,\n};\n\nconst fullTestParams: ServerDeploymentRequestParams = {\n  name: \"Quick-Agent-v0\",\n  agentCard: MOCK_AGENT_CARD,\n  code: ts_coderCode,\n};\n\nconst message: Message = {\n  messageId: \"test-message-id\",\n  kind: \"message\",\n  role: \"user\",\n  parts: [\n    {\n      kind: \"text\",\n      text: \"Write a python function to share files remotely. Please be concise and respond with code only. Please use the following format: def share_files(files: list[str]) -&gt; str: ...\",\n    },\n  ],\n};\nconst message2: Message = {\n  messageId: \"test-message-id-2\",\n  kind: \"message\",\n  role: \"user\",\n  parts: [\n    {\n      kind: \"text\",\n      text: \"Write a javascript function to share files remotely. Please be concise and respond with code only. Please use the following format: function share_files(files: string[]) { ... }\",\n    },\n  ],\n};\n\nconst sendTaskRequest: SendMessageRequest = {\n  jsonrpc: \"2.0\",\n  id: \"test-request-1\",\n  method: \"message/send\",\n  params: {\n    message: message,\n  },\n};\n\ndescribe(\"TestDeployment\", () =&gt; {\n  it(\"should deploy test logic\", async () =&gt; {\n    const requests: SendMessageRequest[] = [\n      sendTaskRequest,\n      {\n        jsonrpc: \"2.0\",\n        id: \"test-request-2\",\n        method: \"message/send\",\n        params: {\n          message: message2,\n        },\n      },\n    ];\n    logDebug(\"testDeployment\", \"Starting testDeployment test...\");\n    const results: (Message | Task | ServerDeploymentResponse)[] = [];\n    for await (const result of testDeployment(testParams, requests)) {\n      if (result) {\n        results.push(result);\n      }\n    }\n    console.log(\n      \"testDeployment completed\",\n      \"testDeployment test finished.\",\n      results\n    );\n    expect(results.length).toBeGreaterThanOrEqual(4);\n  });\n\n  it(\"should bundle and deploy test logic\", async () =&gt; {\n    const requests: SendMessageRequest[] = [\n      sendTaskRequest,\n      {\n        jsonrpc: \"2.0\",\n        id: \"test-request-2\",\n        method: \"message/send\",\n        params: {\n          message: message2,\n        },\n      },\n    ];\n    logDebug(\"testDeployment\", \"Starting testDeployment test...\");\n    const results: (Message | Task | ServerDeploymentResponse)[] = [];\n    for await (const result of testDeployment(coderTestParams, requests)) {\n      logDebug(\"testDeployment\", \"Received result:\", JSON.stringify(result));\n      if (result) {\n        results.push(result);\n      }\n    }\n    while (true &amp;&amp; results.length &lt; 4) {\n      await new Promise((resolve) =&gt; setTimeout(resolve, 10));\n    }\n    logDebug(\"testDeployment\", \"testDeployment test finished.\");\n    expect(results.length).toBeGreaterThanOrEqual(4);\n  }, 90000);\n\n  it(\"should bundle and deploy typescript test logic\", async () =&gt; {\n    const requests: SendMessageRequest[] = [\n      sendTaskRequest,\n      {\n        jsonrpc: \"2.0\",\n        id: \"test-request-2\",\n        method: \"message/send\",\n        params: {\n          message: message2,\n        },\n      },\n    ];\n    logDebug(\"testDeployment\", \"Starting testDeployment test...\");\n    const results: (Message | Task | ServerDeploymentResponse)[] = [];\n    for await (const result of testDeployment(ts_coderTestParams, requests)) {\n      logDebug(\"testDeployment\", \"Received result:\", JSON.stringify(result));\n      if (result) {\n        results.push(result);\n      }\n    }\n    while (true &amp;&amp; results.length &lt; 4) {\n      await new Promise((resolve) =&gt; setTimeout(resolve, 10));\n    }\n    logDebug(\"testDeployment\", \"testDeployment test finished.\");\n    expect(results.length).toBeGreaterThanOrEqual(4);\n  }, 90000);\n\n  it(\"should test nested deployment\", async () =&gt; {\n    const requests: SendMessageRequest[] = [\n      sendTaskRequest,\n      {\n        jsonrpc: \"2.0\",\n        id: \"test-request-2\",\n        method: \"message/send\",\n        params: {\n          message: message2,\n        },\n      },\n    ];\n    logDebug(\"testDeployment\", \"Starting testDeployment test...\");\n    const results: (Message | Task | ServerDeploymentResponse)[] = [];\n    for await (const result of testDeployment(nestedTestParams, requests)) {\n      logDebug(\"testDeployment\", \"Received result:\", JSON.stringify(result));\n      if (result) {\n        results.push(result);\n      }\n    }\n    while (true &amp;&amp; results.length &lt; 4) {\n      await new Promise((resolve) =&gt; setTimeout(resolve, 10));\n    }\n    logDebug(\"testDeployment\", \"testDeployment test finished.\");\n    console.log(\"results: \", JSON.stringify(results, null, 2));\n    expect(results.length).toBeGreaterThanOrEqual(2);\n  }, 90000);\n});\n\ndescribe(\"FullDeployment\", () =&gt; {\n  //ensure valid API Key is set\n  it.skip(\"should fully deploy test logic\", async () =&gt; {\n    logDebug(\"testDeployment\", \"Starting fullDeployment test...\");\n    const deployment = await fullDeployment(fullTestParams);\n    expect(deployment).toBeDefined();\n    expect(deployment.error).toBeUndefined();\n    logDebug(\"testDeployment\", \"fullDeployment test finished.\");\n  }, 90000);\n\n  it.skip(\"should fully deploy nested test logic\", async () =&gt; {\n    logDebug(\"testDeployment\", \"Starting fullDeployment test...\");\n    const deployment = await fullDeployment(nestedTestParams);\n    expect(deployment).toBeDefined();\n    expect(deployment.error).toBeUndefined();\n    logDebug(\"testDeployment\", \"fullDeployment test finished.\");\n  }, 90000);\n\n  it(\"should access deployed agent\", async () =&gt; {\n    logDebug(\"testDeployment\", \"Starting fullDeployment test...\");\n    const client = new A2AClient(\n      \"https://agents.artinet.io/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349\",\n      {},\n      \"/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349/agent-card\"\n    );\n    const card = await client.agentCard();\n    const asCard = card as AgentCard;\n    logDebug(\"testDeployment\", \"agentCard:\", JSON.stringify(asCard));\n    expect(asCard).toBeDefined();\n    console.log(asCard);\n    logDebug(\"testDeployment\", \"fullDeployment test finished.\");\n  }, 90000);\n\n  it(\"should execute task on deployed agent\", async () =&gt; {\n    logDebug(\"testDeployment\", \"Starting fullDeployment test...\");\n    const client = new A2AClient(\n      \"https://agents.artinet.io/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349\",\n      {},\n      \"/agentId=0x88a03f820c633d580f37e9dae1487a32ae2f59b42eafe0f8396c5a902507f349/.well-known/agent.json\"\n    );\n    const params: MessageSendParams = {\n      message: message,\n    };\n    const task = await client.sendTask(params);\n    logDebug(\"testDeployment\", \"task:\", JSON.stringify(task));\n    expect(task).toBeDefined();\n    expect(task?.kind).toBe(\"task\");\n    expect((task as Task).status.state).toBe(\"completed\");\n    console.log(task);\n    console.log((task as Task).status.message);\n    logDebug(\"testDeployment\", \"fullDeployment test finished.\");\n  }, 90000);\n\n  it(\"should execute task on nested deployed agent\", async () =&gt; {\n    logDebug(\"testDeployment\", \"Starting fullDeployment test...\");\n    const client = new A2AClient(\n      \"https://agents.artinet.io/agentId=0x350dd68abd99508c3acc5c61d889fe2f83e4cb5dc8740af0cf7444be9ca686af\",\n      {},\n      \"/0x350dd68abd99508c3acc5c61d889fe2f83e4cb5dc8740af0cf7444be9ca686af/agent-card\"\n    );\n    const params: MessageSendParams = {\n      message: message,\n    };\n    const task = await client.sendTask(params);\n    logDebug(\"testDeployment\", \"task:\", JSON.stringify(task));\n    expect(task).toBeDefined();\n    expect(task?.kind).toBe(\"task\");\n    expect((task as Task).status.state).toBe(\"completed\");\n    console.log(task);\n    console.log((task as Task).status.message);\n    logDebug(\"testDeployment\", \"fullDeployment test finished.\");\n  }, 90000);\n});\n</code></pre>"},{"location":"sdk/tests/deployment.xx.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest deployment.xx.ts</code></li> </ol>"},{"location":"sdk/tests/deployment.xx.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/file-storage.test.html","title":"file-storage.test","text":"<p>Tests for file storage.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/file-storage.test.html#test-suites","title":"Test Suites","text":"<ul> <li>FileStore</li> </ul>"},{"location":"sdk/tests/file-storage.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport { join } from \"path\";\nimport { mkdtemp, rm } from \"fs/promises\";\nimport * as os from \"os\";\nimport {\n  configureLogger,\n  FileStore,\n  Task,\n  TaskState,\n  Message,\n} from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\ndescribe(\"FileStore\", () =&gt; {\n  let tempDir: string;\n  let fileStore: FileStore;\n\n  // Create a temporary directory for testing\n  beforeEach(async () =&gt; {\n    tempDir = await mkdtemp(join(os.tmpdir(), \"a2a-file-store-test-\"));\n    fileStore = new FileStore(tempDir);\n  });\n\n  // Clean up the temporary directory after tests\n  afterEach(async () =&gt; {\n    await rm(tempDir, { recursive: true, force: true });\n  });\n\n  it(\"should save and retrieve a task\", async () =&gt; {\n    const taskId = \"test-task-1\";\n    const task: Task = {\n      id: taskId,\n      kind: \"task\",\n      status: {\n        state: \"working\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n    };\n\n    // Save the task\n    await fileStore.save({ task, history: [] });\n\n    // Retrieve the task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.id).toBe(taskId);\n    expect(result?.task.status.state).toBe(\"working\");\n  });\n\n  it(\"should update an existing task\", async () =&gt; {\n    const taskId = \"test-task-2\";\n    const task: Task = {\n      id: taskId,\n      kind: \"task\",\n      status: {\n        state: \"submitted\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n    };\n\n    // Save the task initially\n    await fileStore.save({ task, history: [] });\n\n    // Update the task\n    const updatedTask: Task = {\n      id: taskId,\n      kind: \"task\",\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n      artifacts: [\n        {\n          artifactId: \"test-artifact-id\",\n          name: \"result.txt\",\n          parts: [\n            {\n              kind: \"text\",\n              text: \"Task completed successfully\",\n            },\n          ],\n        },\n      ],\n    };\n\n    await fileStore.save({ task: updatedTask, history: [] });\n\n    // Retrieve the updated task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.id).toBe(taskId);\n    expect(result?.task.status.state).toBe(\"completed\");\n    expect(result?.task.artifacts).toBeDefined();\n    expect(result?.task.artifacts?.length).toBe(1);\n    expect(result?.task.artifacts?.[0].name).toBe(\"result.txt\");\n  });\n\n  it(\"should return null for non-existent task\", async () =&gt; {\n    const nonExistentTaskId = \"non-existent-task\";\n\n    const result = await fileStore.load(nonExistentTaskId);\n\n    expect(result).toBeNull();\n  });\n\n  it(\"should handle tasks with artifacts containing file parts\", async () =&gt; {\n    const taskId = \"test-file-task\";\n    const fileContent = \"SGVsbG8gQTJBIQ==\"; // Base64 encoded \"Hello A2A!\"\n\n    const task: Task = {\n      id: taskId,\n      kind: \"task\",\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n      artifacts: [\n        {\n          artifactId: \"test-artifact-id\",\n          name: \"example.txt\",\n          parts: [\n            {\n              kind: \"file\",\n              file: {\n                name: \"example.txt\",\n                mimeType: \"text/plain\",\n                bytes: fileContent,\n              },\n            },\n          ],\n        },\n      ],\n    };\n\n    // Save the task\n    await fileStore.save({ task, history: [] });\n\n    // Retrieve the task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.artifacts).toBeDefined();\n    expect(result?.task.artifacts?.length).toBe(1);\n\n    const filePart = result?.task.artifacts?.[0].parts[0];\n    expect(filePart?.kind).toBe(\"file\");\n    expect((filePart as any).file.name).toBe(\"example.txt\");\n    expect((filePart as any).file.bytes).toBe(fileContent);\n  });\n\n  it(\"should handle tasks with multiple artifacts\", async () =&gt; {\n    const taskId = \"multi-artifact-task\";\n\n    const task: Task = {\n      id: taskId,\n      kind: \"task\",\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n      artifacts: [\n        {\n          artifactId: \"test-artifact-id\",\n          name: \"result1.txt\",\n          parts: [\n            {\n              kind: \"text\",\n              text: \"First result\",\n            },\n          ],\n        },\n        {\n          artifactId: \"test-artifact-id-2\",\n          name: \"result2.txt\",\n          parts: [\n            {\n              kind: \"text\",\n              text: \"Second result\",\n            },\n          ],\n        },\n      ],\n    };\n\n    // Save the task\n    await fileStore.save({ task, history: [] });\n\n    // Retrieve the task\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.task.artifacts).toBeDefined();\n    expect(result?.task.artifacts?.length).toBe(2);\n    expect(result?.task.artifacts?.[0].name).toBe(\"result1.txt\");\n    expect(result?.task.artifacts?.[1].name).toBe(\"result2.txt\");\n  });\n\n  it(\"should save and retrieve task history\", async () =&gt; {\n    const taskId = \"history-task\";\n\n    const task: Task = {\n      id: taskId,\n      kind: \"task\",\n      status: {\n        state: \"completed\" as TaskState,\n        timestamp: new Date().toISOString(),\n      },\n    };\n\n    const history: Message[] = [\n      {\n        messageId: \"test-message-id-1\",\n        kind: \"message\",\n        role: \"user\",\n        parts: [\n          {\n            kind: \"text\",\n            text: \"Initial request\",\n          },\n        ],\n      },\n      {\n        messageId: \"test-message-id-2\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [\n          {\n            kind: \"text\",\n            text: \"Agent response\",\n          },\n        ],\n      },\n    ];\n\n    // Save the task with history\n    await fileStore.save({ task, history });\n\n    // Retrieve the task and history\n    const result = await fileStore.load(taskId);\n\n    expect(result).toBeDefined();\n    expect(result?.history).toBeDefined();\n    expect(result?.history.length).toBe(2);\n    expect(result?.history[0].role).toBe(\"user\");\n    expect(result?.history[1].role).toBe(\"agent\");\n  });\n});\n</code></pre>"},{"location":"sdk/tests/file-storage.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest file-storage.test.ts</code></li> </ol>"},{"location":"sdk/tests/file-storage.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/http-utils.test.html","title":"http-utils.test","text":"<p>Tests for http utils.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/http-utils.test.html#test-suites","title":"Test Suites","text":"<ul> <li>HTTP Utils</li> <li>sendJsonRpcRequest</li> <li>sendGetRequest</li> <li>handleJsonRpcResponse</li> <li>handleJsonResponse</li> <li>parseResponse</li> <li>executeJsonRpcRequest</li> <li>executeGetRequest</li> <li>handleEventStream</li> <li>executeStreamEvents</li> <li>createJsonRpcRequest</li> <li>sendJsonRpcRequest with network errors</li> <li>sendGetRequest with network errors</li> <li>parseResponse additional cases</li> <li>handleJsonResponse additional cases</li> </ul>"},{"location":"sdk/tests/http-utils.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport { http, HttpResponse } from \"msw\";\nimport { setupServer } from \"msw/node\";\nimport {\n  sendJsonRpcRequest,\n  sendGetRequest,\n  handleJsonRpcResponse,\n  handleJsonResponse,\n  executeJsonRpcRequest,\n  executeGetRequest,\n  createJsonRpcRequest,\n  parseResponse,\n  handleEventStream,\n  ErrorCodeParseError,\n  JSONRPCRequest,\n  JSONRPCResponse,\n  SystemError,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Define a TestRequest type that matches JSONRPCRequest constraint\ntype TestMethod =\n  | \"test/method\"\n  | \"test/empty\"\n  | \"test/invalid\"\n  | \"test/error\"\n  | \"test/network-error\"\n  | \"test/streaming\";\n\n// Define a custom request type for testing\ninterface TestRequest extends JSONRPCRequest {\n  method: TestMethod;\n  params: {\n    param?: string;\n    status?: string;\n    [key: string]: any;\n  };\n}\n\nconfigureLogger({ level: \"silent\" });\n\n// Setup MSW server for mocking HTTP requests\nconst server = setupServer(\n  // Mock successful request\n  http.post(\"https://example.com/api\", ({ request }) =&gt; {\n    const url = new URL(request.url);\n    if (url.pathname === \"/api\") {\n      const contentType = request.headers.get(\"Content-Type\") || \"\";\n      if (contentType.includes(\"application/json\")) {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          result: { foo: \"bar\" },\n        });\n      }\n    }\n    return HttpResponse.json({}, { status: 404 });\n  }),\n\n  // Mock successful GET request\n  http.get(\"https://example.com/api\", () =&gt; {\n    return HttpResponse.json({ success: true });\n  }),\n\n  // Mock network error GET request\n  http.get(\"https://example.com/api/error\", () =&gt; {\n    return new HttpResponse(null, { status: 500 });\n  }),\n\n  // Mock invalid JSON response\n  http.get(\"https://example.com/api/invalid\", () =&gt; {\n    return new HttpResponse(\"not a json\", {\n      status: 200,\n      headers: { \"Content-Type\": \"text/plain\" },\n    });\n  }),\n\n  // Mock invalid JSON-RPC response with null result\n  http.get(\"https://example.com/api/null-result\", () =&gt; {\n    return HttpResponse.json({\n      jsonrpc: \"2.0\",\n      id: \"test-id\",\n    });\n  }),\n\n  // Mock empty response\n  http.get(\"https://example.com/api/empty-response\", () =&gt; {\n    return new HttpResponse(null, { status: 204 });\n  }),\n\n  // Mock network error for specific endpoints\n  http.get(\"https://example.com/api/network-error\", () =&gt; {\n    throw new Error(\"Network error\");\n  }),\n\n  http.post(\"https://example.com/api/network-error\", () =&gt; {\n    throw new Error(\"Network error\");\n  }),\n\n  // Mock RPC error response\n  http.post(\"https://example.com/api/rpc-error\", () =&gt; {\n    return HttpResponse.json(\n      {\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32603,\n          message: \"Internal error\",\n          data: { details: \"Something went wrong\" },\n        },\n      },\n      { status: 200 }\n    );\n  }),\n\n  // Mock invalid streaming response\n  http.post(\"https://example.com/api/streaming\", () =&gt; {\n    const encoder = new TextEncoder();\n    const stream = new ReadableStream({\n      start(controller) {\n        controller.enqueue(\n          encoder.encode(\n            `event: message\\ndata: ${JSON.stringify({\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              result: { status: \"working\" },\n            })}\\n\\n`\n          )\n        );\n        controller.enqueue(\n          encoder.encode(\n            `event: message\\ndata: ${JSON.stringify({\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              result: { status: \"completed\" },\n            })}\\n\\n`\n          )\n        );\n        controller.close();\n      },\n    });\n\n    return new HttpResponse(stream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        Connection: \"keep-alive\",\n        \"Cache-Control\": \"no-cache\",\n      },\n    });\n  }),\n\n  http.post(\"https://example.com/api/invalid-streaming\", () =&gt; {\n    const encoder = new TextEncoder();\n    const stream = new ReadableStream({\n      start(controller) {\n        controller.enqueue(encoder.encode(`event: message\\ndata: invalid\\n\\n`));\n        controller.close();\n      },\n    });\n\n    return new HttpResponse(stream, {\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        Connection: \"keep-alive\",\n        \"Cache-Control\": \"no-cache\",\n      },\n    });\n  })\n);\n\ndescribe(\"HTTP Utils\", () =&gt; {\n  beforeAll(() =&gt; {\n    server.listen();\n  });\n\n  afterAll(() =&gt; {\n    server.close();\n  });\n\n  beforeEach(() =&gt; {\n    server.resetHandlers();\n  });\n\n  describe(\"sendJsonRpcRequest\", () =&gt; {\n    test(\"should send a JSON-RPC request and return the response\", async () =&gt; {\n      const response = await sendJsonRpcRequest(\n        new URL(\"https://example.com/api\"),\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        { \"Custom-Header\": \"value\" }\n      );\n\n      expect(response.ok).toBe(true);\n      const data = await response.json();\n      expect(data).toEqual({\n        jsonrpc: \"2.0\",\n        id: expect.any(String),\n        result: { foo: \"bar\" },\n      });\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      // Configure MSW to simulate a network error for this specific test\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(null, { status: 500 });\n        })\n      );\n\n      try {\n        await sendJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/method\" as any,\n          {} as any\n        );\n        // If we get here, the test should fail only if we got a response\n        // but we expected to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n  });\n\n  describe(\"sendGetRequest\", () =&gt; {\n    test(\"should send a GET request and return the response\", async () =&gt; {\n      const response = await sendGetRequest(\n        new URL(\"https://example.com/api\"),\n        { \"Custom-Header\": \"value\" }\n      );\n\n      expect(response.ok).toBe(true);\n      const data = await response.json();\n      expect(data).toEqual({ success: true });\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      // Configure MSW to simulate a network error for this specific test\n      server.use(\n        http.get(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(null, { status: 500 });\n        })\n      );\n\n      try {\n        await sendGetRequest(new URL(\"https://example.com/api\"));\n        // If we got here, the test should only fail if we got a response\n        // when we expected it to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n  });\n\n  describe(\"handleJsonRpcResponse\", () =&gt; {\n    test(\"should parse and return the result from a JSON-RPC response\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/method\",\n        }),\n      });\n\n      const result = await handleJsonRpcResponse&lt;\n        JSONRPCResponse&lt;{ foo: string }&gt;\n      &gt;(response, \"test/method\");\n      expect(result).toEqual({ foo: \"bar\" });\n    });\n\n    test(\"should handle HTTP errors with JSON-RPC errors\", async () =&gt; {\n      // Override the response for this specific test\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return HttpResponse.json(\n            {\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              error: {\n                code: -32603,\n                message: \"Internal error\",\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/error\",\n        }),\n      });\n\n      try {\n        await handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/error\");\n        // If we get here, the test should fail\n        expect(true).toBe(false); // Force test to fail\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n      }\n    });\n\n    test(\"should handle HTTP errors with non-JSON-RPC responses\", async () =&gt; {\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(\"Not a JSON-RPC response\", {\n            status: 500,\n            headers: { \"Content-Type\": \"text/plain\" },\n          });\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/method\",\n        }),\n      });\n\n      await expect(\n        handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/method\")\n      ).rejects.toThrow();\n    });\n\n    test(\"should handle responses with invalid JSON\", async () =&gt; {\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(\"not a json\", {\n            status: 200,\n            headers: { \"Content-Type\": \"text/plain\" },\n          });\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\", {\n        method: \"POST\",\n        body: JSON.stringify({\n          jsonrpc: \"2.0\",\n          id: \"test-id\",\n          method: \"test/method\",\n        }),\n      });\n\n      await expect(\n        handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/method\")\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle JSON-RPC errors with data field\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/rpc-error\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ jsonrpc: \"2.0\", id: \"test-id\" }),\n      });\n\n      await expect(\n        handleJsonRpcResponse&lt;JSONRPCResponse&gt;(response, \"test/error-with-data\")\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle non-A2AError exceptions during processing\", async () =&gt; {\n      // Use a direct test of the error handling path in handleJsonRpcResponse\n      const invalidResponse = new Response(null, { status: 200 });\n\n      try {\n        await handleJsonRpcResponse&lt;JSONRPCResponse&gt;(\n          invalidResponse,\n          \"test/error-handling\"\n        );\n        // Should not reach here\n        expect(\"this line\").toBe(\"not reached\");\n      } catch (error) {\n        // Verify it's an A2AError with the right code\n        expect(error instanceof SystemError).toBe(true);\n        expect((error as SystemError&lt;any&gt;).code).toBe(ErrorCodeParseError);\n      }\n    });\n  });\n\n  describe(\"handleJsonResponse\", () =&gt; {\n    test(\"should parse and return JSON from a successful response\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api\");\n      const result = await handleJsonResponse&lt;{ success: boolean }&gt;(\n        response,\n        \"test-endpoint\"\n      );\n      expect(result).toEqual({ success: true });\n    });\n\n    test(\"should handle HTTP errors\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/error\");\n      await expect(\n        handleJsonResponse&lt;any&gt;(response, \"error-endpoint\")\n      ).rejects.toThrow();\n    });\n\n    test(\"should handle invalid JSON\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/invalid\");\n      await expect(\n        handleJsonResponse&lt;any&gt;(response, \"invalid-endpoint\")\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle empty responses\", async () =&gt; {\n      const response = await fetch(\"https://example.com/api/empty-response\");\n      await expect(\n        handleJsonResponse&lt;any&gt;(response, \"empty-response-endpoint\")\n      ).rejects.toThrow(SystemError);\n    });\n  });\n\n  describe(\"parseResponse\", () =&gt; {\n    test(\"should parse valid JSON-RPC response\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        result: { foo: \"bar\" },\n      });\n\n      const result = parseResponse&lt;JSONRPCResponse&lt;{ foo: string }&gt;&gt;(data);\n      expect(result).toEqual({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        result: { foo: \"bar\" },\n      });\n    });\n\n    test(\"should throw for empty data\", () =&gt; {\n      expect(() =&gt; parseResponse(\"\")).toThrow(SystemError);\n    });\n\n    test(\"should throw for JSON-RPC errors\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32601,\n          message: \"Method not found\",\n        },\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for JSON-RPC errors with data field\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32603,\n          message: \"Internal error\",\n          data: { details: \"Something went wrong\" },\n        },\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for invalid JSON-RPC structure\", () =&gt; {\n      const data = JSON.stringify({\n        not: \"jsonrpc\",\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for missing result\", () =&gt; {\n      const data = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n      });\n\n      expect(() =&gt; parseResponse(data)).toThrow(SystemError);\n    });\n\n    test(\"should throw for invalid JSON\", () =&gt; {\n      expect(() =&gt; parseResponse(\"invalid json\")).toThrow(SystemError);\n    });\n  });\n\n  describe(\"executeJsonRpcRequest\", () =&gt; {\n    test(\"should execute a JSON-RPC request and return the result\", async () =&gt; {\n      const result = await executeJsonRpcRequest(\n        new URL(\"https://example.com/api\"),\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        { \"Custom-Header\": \"value\" }\n      );\n\n      expect(result).toEqual({ foo: \"bar\" });\n    });\n\n    test(\"should handle errors\", async () =&gt; {\n      // Override the response for this specific test\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          return HttpResponse.json(\n            {\n              jsonrpc: \"2.0\",\n              id: \"test-id\",\n              error: {\n                code: -32603,\n                message: \"Internal error\",\n              },\n            },\n            { status: 400 }\n          );\n        })\n      );\n\n      try {\n        await executeJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/error\" as any,\n          {} as any\n        );\n        // If we got here, the test should only fail if we got a response\n        // when we expected it to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      server.use(\n        http.post(\"https://example.com/api\", () =&gt; {\n          throw new Error(\"Network error\");\n        })\n      );\n\n      try {\n        await executeJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/method\" as any,\n          {} as any\n        );\n        // If we got here, the test should only fail if we got a response\n        // when we expected it to throw\n      } catch (error) {\n        // Success - we expected it to throw\n        expect(error).toBeDefined();\n      }\n    });\n\n    test(\"should accept different accept headers\", async () =&gt; {\n      const result = await executeJsonRpcRequest(\n        new URL(\"https://example.com/api\"),\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        { \"Custom-Header\": \"value\" },\n        \"application/json\"\n      );\n\n      expect(result).toEqual({ foo: \"bar\" });\n    });\n  });\n\n  describe(\"executeGetRequest\", () =&gt; {\n    test(\"should execute a GET request and return the parsed result\", async () =&gt; {\n      const result = await executeGetRequest&lt;{ success: boolean }&gt;(\n        new URL(\"https://example.com/api\"),\n        { \"Custom-Header\": \"value\" },\n        \"test-endpoint\"\n      );\n\n      expect(result).toEqual({ success: true });\n    });\n\n    test(\"should handle errors\", async () =&gt; {\n      await expect(\n        executeGetRequest&lt;any&gt;(\n          new URL(\"https://example.com/api/error\"),\n          {},\n          \"error-endpoint\"\n        )\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should handle network errors\", async () =&gt; {\n      server.use(\n        http.get(\"https://example.com/api\", () =&gt; {\n          throw new Error(\"Network error\");\n        })\n      );\n\n      await expect(\n        executeGetRequest&lt;any&gt;(\n          new URL(\"https://example.com/api\"),\n          {},\n          \"network-error-endpoint\"\n        )\n      ).rejects.toThrow(SystemError);\n    });\n\n    test(\"should work without optional parameters\", async () =&gt; {\n      const result = await executeGetRequest&lt;{ success: boolean }&gt;(\n        new URL(\"https://example.com/api\")\n      );\n\n      expect(result).toEqual({ success: true });\n    });\n  });\n\n  describe(\"handleEventStream\", () =&gt; {\n    test(\"should handle empty events array\", async () =&gt; {\n      const encoder = new TextEncoder();\n      const stream = new ReadableStream({\n        start(controller) {\n          // Send an event with valid structure but no data we care about\n          controller.enqueue(\n            encoder.encode(\n              `event: message\\ndata: ${JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"test-id\",\n                // Missing result property intentionally\n              })}\\n\\n`\n            )\n          );\n          controller.close();\n        },\n      });\n\n      const response = new Response(stream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n\n      const generator = handleEventStream&lt;JSONRPCResponse&gt;(response);\n      const results: any[] = [];\n\n      for await (const event of generator) {\n        results.push(event);\n      }\n\n      // Should not yield any events since the input had none\n      expect(results.length).toBe(0);\n    });\n\n    test(\"should handle parser errors in event data\", async () =&gt; {\n      const encoder = new TextEncoder();\n      const stream = new ReadableStream({\n        start(controller) {\n          // Send an invalid event (not proper JSON)\n          controller.enqueue(\n            encoder.encode(`event: message\\ndata: invalid-json\\n\\n`)\n          );\n          controller.close();\n        },\n      });\n\n      const response = new Response(stream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n\n      const generator = handleEventStream&lt;JSONRPCResponse&gt;(response);\n      const results: any[] = [];\n\n      for await (const event of generator) {\n        results.push(event);\n      }\n\n      // Should not yield any events since the input was invalid\n      expect(results.length).toBe(0);\n    });\n\n    test(\"should handle valid events with undefined result\", async () =&gt; {\n      const encoder = new TextEncoder();\n      const stream = new ReadableStream({\n        start(controller) {\n          // Send an event with null result to trigger the warning branch\n          controller.enqueue(\n            encoder.encode(\n              `event: message\\ndata: ${JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: \"test-id\",\n                result: undefined,\n              })}\\n\\n`\n            )\n          );\n          controller.close();\n        },\n      });\n\n      const response = new Response(stream, {\n        headers: {\n          \"Content-Type\": \"text/event-stream\",\n        },\n      });\n\n      const generator = handleEventStream&lt;JSONRPCResponse&gt;(response);\n      const results: any[] = [];\n\n      for await (const event of generator) {\n        results.push(event);\n      }\n\n      // Should not yield any events since result was undefined\n      expect(results.length).toBe(0);\n    });\n  });\n\n  describe(\"executeStreamEvents\", () =&gt; {\n    test.skip(\"should execute a streaming request and yield events\", () =&gt; {});\n\n    test.skip(\"should handle errors in streaming requests\", () =&gt; {});\n  });\n\n  describe(\"createJsonRpcRequest\", () =&gt; {\n    test(\"should create a properly formatted JSON-RPC request with custom ID\", () =&gt; {\n      const request = createJsonRpcRequest(\n        \"test/method\" as any,\n        {} as any, // Empty object to avoid type issues\n        \"custom-id\"\n      );\n      expect(request).toEqual({\n        jsonrpc: \"2.0\",\n        id: \"custom-id\",\n        method: \"test/method\",\n        params: {},\n      });\n    });\n\n    test(\"should create a properly formatted JSON-RPC request with auto-generated ID\", () =&gt; {\n      const request = createJsonRpcRequest(\n        \"test/method\" as any,\n        {} as any // Empty object to avoid type issues\n      );\n      expect(request).toEqual({\n        jsonrpc: \"2.0\",\n        id: expect.any(String), // UUID is auto-generated\n        method: \"test/method\",\n        params: {},\n      });\n    });\n  });\n\n  describe(\"sendJsonRpcRequest with network errors\", () =&gt; {\n    test(\"should handle network error that's not an Error instance\", async () =&gt; {\n      try {\n        await sendJsonRpcRequest(\n          new URL(\"https://example.com/api\"),\n          \"test/method\" as any,\n          {} as any // Empty params to avoid type issues\n        );\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect(error.message).toContain(\"Network connection lost\");\n      }\n    });\n  });\n\n  describe(\"sendGetRequest with network errors\", () =&gt; {\n    test(\"should handle network error that's not an Error instance\", async () =&gt; {\n      try {\n        await sendGetRequest(new URL(\"https://example.com/api\"));\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect(error.message).toContain(\"Connection timeout\");\n      }\n    });\n  });\n\n  describe(\"parseResponse additional cases\", () =&gt; {\n    test(\"should handle error that's not an A2AError during parsing\", () =&gt; {\n      try {\n        parseResponse(\"invalid json\");\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect((error as SystemError&lt;any&gt;).code).toBe(ErrorCodeParseError);\n      }\n    });\n  });\n\n  describe(\"handleJsonResponse additional cases\", () =&gt; {\n    test(\"should handle error that's not an Error instance\", async () =&gt; {\n      server.use(\n        http.get(\"https://example.com/api\", () =&gt; {\n          return new HttpResponse(\"\", {\n            status: 200,\n            headers: { \"Content-Type\": \"application/json\" },\n          });\n        })\n      );\n\n      const response = await fetch(\"https://example.com/api\");\n      try {\n        await handleJsonResponse(response, \"custom-endpoint\");\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect(error.message).toContain(\"Invalid JSON payload\");\n      }\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/http-utils.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest http-utils.test.ts</code></li> </ol>"},{"location":"sdk/tests/http-utils.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/integration.test.html","title":"integration.test","text":"<p>Simple echo task handler for testing</p>"},{"location":"sdk/tests/integration.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Client-Server Integration Tests</li> </ul>"},{"location":"sdk/tests/integration.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  jest,\n  describe,\n  beforeEach,\n  afterEach,\n  test,\n  expect,\n} from \"@jest/globals\";\nimport express from \"express\";\nimport {\n  A2AClient,\n  A2AServer,\n  InMemoryTaskStore,\n  Message,\n  Task,\n  TaskContext,\n  TaskState,\n  UpdateEvent,\n  configureLogger,\n  ExecutionContext,\n  MessageSendParams,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n/**\n * Simple echo task handler for testing\n */\nasync function* echoHandler(\n  context: ExecutionContext\n): AsyncGenerator&lt;UpdateEvent, void, unknown&gt; {\n  // Extract user text\n  const params = context.getRequestParams() as MessageSendParams;\n  const taskId = params.message.taskId ?? context.id;\n  const contextId = context.id;\n  const userText = params.message.parts\n    .filter((part) =&gt; part.kind === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Send working status\n  yield {\n    taskId,\n    contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Working,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Processing...\" }],\n      },\n    },\n    final: false,\n  };\n  await new Promise((resolve) =&gt; setTimeout(resolve, 300));\n  // Check cancellation\n  if (context.isCancelled()) {\n    yield {\n      taskId,\n      contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Canceled,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Task was canceled.\" }],\n        },\n      },\n      final: true,\n    };\n    return;\n  }\n\n  // Create a response\n  const response = `You said: \"${userText}\"`;\n\n  // Create an artifact\n  yield {\n    taskId,\n    contextId,\n    kind: \"artifact-update\",\n    artifact: {\n      artifactId: \"test-artifact-id\",\n      name: \"echo.txt\",\n      parts: [{ kind: \"text\", text: response }],\n    },\n  };\n\n  // Complete the task\n  yield {\n    id: taskId,\n    contextId,\n    kind: \"task\",\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: response }],\n      },\n    },\n  };\n}\n\ndescribe(\"Client-Server Integration Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let expressServer: any;\n  let port: number;\n  let client: A2AClient;\n\n  beforeEach(async () =&gt; {\n    // Create a simple server\n    server = new A2AServer({\n      handler: echoHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0,\n    });\n    app = server.start();\n\n    // Get the actual port\n    expressServer = app.listen(0);\n    port = (expressServer.address() as any).port;\n\n    // Create client\n    client = new A2AClient(`http://localhost:${port}`);\n  });\n\n  afterEach(async () =&gt; {\n    // Force close any open connections\n    return new Promise&lt;void&gt;((resolve) =&gt; {\n      // Close the express server gracefully\n      server.stop().then(() =&gt; {\n        // Allow some time for connections to fully close\n        setTimeout(resolve, 100);\n      });\n      expressServer.close(() =&gt; {\n        resolve();\n      });\n    });\n  });\n\n  test(\"client can retrieve agent card\", async () =&gt; {\n    const card = await client.agentCard();\n\n    expect(card).toBeDefined();\n    expect(card.name).toBe(\"A2A Server\");\n    expect(card.capabilities.streaming).toBe(true);\n  });\n\n  test(\"client can send task and get response\", async () =&gt; {\n    const testMessage = \"Hello, A2A!\";\n    const task = await client.sendTask({\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"user\",\n        parts: [{ kind: \"text\", text: testMessage }],\n      },\n    });\n\n    expect(task).toBeDefined();\n    expect(task?.kind).toBe(\"task\");\n    expect((task as Task).status.state).toBe(\"completed\");\n\n    // Check if the response message contains our echo\n    const responseText = (task as Task).status.message?.parts\n      .filter((part) =&gt; part.kind === \"text\")\n      .map((part) =&gt; (part as any).text)\n      .join(\" \");\n\n    expect(responseText).toContain(testMessage);\n\n    // Check if artifact was created\n    expect((task as Task).artifacts).toBeDefined();\n    expect((task as Task).artifacts!.length).toBe(1);\n    expect((task as Task).artifacts![0].name).toBe(\"echo.txt\");\n  });\n\n  test(\"client can stream task updates\", async () =&gt; {\n    const testMessage = \"Test streaming\";\n    const stream = client.sendTaskSubscribe({\n      message: {\n        taskId: \"stream-task-test\",\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"user\",\n        parts: [{ kind: \"text\", text: testMessage }],\n      },\n    });\n\n    const updates: any[] = [];\n    for await (const update of stream) {\n      updates.push(update);\n    }\n\n    // We should have at least 3 updates:\n    // 1. \"submitted\" status (initial state from server)\n    // 2. \"working\" status (from our handler)\n    // 3. artifact\n    // 4. \"completed\" status\n    expect(updates.length).toBeGreaterThanOrEqual(3);\n\n    // First update should be \"submitted\" status\n    expect(updates[0].status?.state).toBe(\"submitted\");\n\n    // Second update should be \"working\" status\n    if (updates.length &gt; 1) {\n      expect(updates[1].status?.state).toBe(\"working\");\n    }\n\n    // Check for artifact update\n    const artifactUpdate = updates.find((u) =&gt; u.artifact);\n    expect(artifactUpdate).toBeDefined();\n    expect(artifactUpdate.artifact.name).toBe(\"echo.txt\");\n\n    // Last update should be \"completed\" status\n    const lastUpdate = updates[updates.length - 1];\n    expect(lastUpdate.status?.state).toBe(\"completed\");\n\n    // Verify response text contains our message\n    const responseText = lastUpdate.status.message?.parts\n      .filter((part: any) =&gt; part.kind === \"text\")\n      .map((part: any) =&gt; part.text)\n      .join(\" \");\n\n    expect(responseText).toContain(testMessage);\n  });\n\n  test(\"client can cancel a task\", async () =&gt; {\n    // First send a task to create it\n    const task = client.sendTask({\n      message: {\n        taskId: \"cancel-task-test\",\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"user\",\n        parts: [{ kind: \"text\", text: \"Task to be canceled\" }],\n      },\n    });\n\n    const canceledTask = await client.cancelTask({\n      id: \"cancel-task-test\",\n    });\n    expect(canceledTask).toBeDefined();\n    expect(canceledTask!.status.state).toBe(\"canceled\");\n    expect(((await task) as Task)?.status.state).toBe(\"canceled\");\n  });\n\n  test(\"client can get task by ID\", async () =&gt; {\n    await client.sendTask({\n      message: {\n        taskId: \"get-task-test\",\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"user\",\n        parts: [{ kind: \"text\", text: \"Task to be retrieved\" }],\n      },\n    });\n\n    // Now retrieve it\n    const task = await client.getTask({\n      id: \"get-task-test\",\n    });\n\n    expect(task).toBeDefined();\n    expect(task!.id).toBe(\"get-task-test\");\n    expect(task!.status.state).toBe(\"completed\");\n  });\n});\n</code></pre>"},{"location":"sdk/tests/integration.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest integration.test.ts</code></li> </ol>"},{"location":"sdk/tests/integration.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/register.test.html","title":"register.test","text":"<p>Tests for register.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/register.test.html#test-suites","title":"Test Suites","text":"<ul> <li>register Function</li> </ul>"},{"location":"sdk/tests/register.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest, describe, test, expect } from \"@jest/globals\";\nimport { register, convert, AgentCard, configureLogger } from \"../src/index.js\";\nimport { MetadataValidator } from \"@artinet/metadata-validator\";\n\nconfigureLogger({ level: \"silent\" });\n// Mock global fetch with proper typing for mock implementation\nglobal.fetch = jest.fn() as jest.MockedFunction&lt;typeof fetch&gt;;\nconst mockFetch = global.fetch as jest.MockedFunction&lt;typeof fetch&gt;;\n\ndescribe(\"register Function\", () =&gt; {\n  let sampleAgentCard: AgentCard;\n\n  beforeEach(() =&gt; {\n    // Reset all mocks before each test\n    jest.clearAllMocks();\n    mockFetch.mockClear();\n    mockFetch.mockResolvedValue({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: {\n            success: true,\n            registrationId: \"default-reg-id\",\n          },\n        }),\n      }),\n    } as Response); // Assert as Response type\n\n    // Define a basic AgentCard for testing\n    sampleAgentCard = {\n      name: \"Test Agent\",\n      description: \"A test agent card\",\n      url: \"https://agents.artinet.io/agent\",\n      version: \"1.0.0\",\n      capabilities: {\n        streaming: false,\n        pushNotifications: false,\n        stateTransitionHistory: false,\n      },\n      skills: [\n        {\n          id: \"skill1\",\n          name: \"Skill One\",\n          description: \"Does one thing\",\n          tags: [],\n        },\n        {\n          id: \"skill2\",\n          name: \"Skill Two\",\n          description: \"Does another thing\",\n          tags: [],\n        },\n      ],\n      defaultInputModes: [\"text\"],\n      defaultOutputModes: [\"text\"], // Explicitly no auth for default test card\n      provider: { organization: \"Test Org\", url: \"http://test.org\" },\n      documentationUrl: \"http://docs.test.org\",\n    };\n  });\n\n  test(\"valid AgentCard should validate\", async () =&gt; {\n    const registration = await convert(sampleAgentCard);\n    const validator = new MetadataValidator();\n    const { isValid, errors } = await validator.validateMetadata(registration);\n    expect(isValid).toBe(true);\n    expect(errors.length).toBe(0);\n  });\n\n  test(\"invalid AgentCard should not validate\", async () =&gt; {\n    const registration = await convert(sampleAgentCard);\n    registration.version = \"invalid-version\";\n    const validator = new MetadataValidator();\n    const { isValid, errors } = await validator.validateMetadata(registration);\n    expect(isValid).toBe(false);\n    expect(errors.length).toBeGreaterThan(0);\n  });\n\n  test(\"should register successfully and return registrationId\", async () =&gt; {\n    const expectedRegId = \"test-success-id\";\n\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: {\n            success: true,\n            registrationId: expectedRegId,\n          },\n        }),\n      }),\n    } as Response);\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(expectedRegId);\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n  test(\"should return empty string and log warning on API call failure (success: false)\", async () =&gt; {\n    const apiErrorMsg = \"Failed to register with API\";\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: { success: false, error: apiErrorMsg },\n        }),\n      }),\n    } as Response);\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"should return empty string if API returns success but no registrationId\", async () =&gt; {\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: { success: true, registrationId: undefined },\n        }),\n      }),\n    } as Response);\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"should return empty string and log warning if fetch throws a network error\", async () =&gt; {\n    const fetchErrorMsg = \"Network Error\";\n    mockFetch.mockRejectedValueOnce(new Error(fetchErrorMsg));\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n\n  test(\"should set endpoint authentication to true if AgentCard has auth schemes\", async () =&gt; {\n    sampleAgentCard.security = [\n      {\n        scheme: [\"bearer\"],\n        credentials: [\"test-token\"],\n      },\n    ];\n    mockFetch.mockResolvedValueOnce({\n      ok: true,\n      json: async () =&gt; ({\n        body: JSON.stringify({\n          registrationResponse: { success: true, registrationId: \"id-456\" },\n        }),\n      }),\n    } as Response);\n    await register(sampleAgentCard);\n    expect(mockFetch).toHaveBeenCalledTimes(1);\n  });\n  test(\"should return empty string if URL is localhost\", async () =&gt; {\n    sampleAgentCard.url = \"http://localhost:8080/agent\";\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n  });\n  test(\"should return empty string if URL is 127.0.0.1\", async () =&gt; {\n    sampleAgentCard.url = \"http://127.0.0.1:8080/agent\";\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n  });\n  test(\"should return empty string if URL is empty\", async () =&gt; {\n    sampleAgentCard.url = \"\";\n    const result = await register(sampleAgentCard);\n    expect(result).toBe(\"\");\n  });\n});\n</code></pre>"},{"location":"sdk/tests/register.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest register.test.ts</code></li> </ol>"},{"location":"sdk/tests/register.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/rpc-client.test.html","title":"rpc-client.test","text":"<p>Tests for rpc client.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/rpc-client.test.html#test-suites","title":"Test Suites","text":"<ul> <li>RPC Client</li> <li>createJsonRpcRequest</li> <li>executeJsonRpcRequest</li> <li>parseResponse</li> </ul>"},{"location":"sdk/tests/rpc-client.test.html#source-code","title":"Source Code","text":"<pre><code>import { jest } from \"@jest/globals\";\nimport { http, HttpResponse } from \"msw\";\nimport { setupServer } from \"msw/node\";\nimport { configureLogger, SystemError } from \"../src/index.js\";\n\nconfigureLogger({ level: \"silent\" });\n\n// Override the createJsonRpcRequest for testing to avoid type checking\nfunction createTestRequest(\n  method: string,\n  params: any,\n  id: string | number = \"test-\" + Math.random().toString(36).substring(2, 9)\n): any {\n  return {\n    jsonrpc: \"2.0\",\n    id,\n    method,\n    params,\n  };\n}\n\n// Define a simpler version of executeJsonRpcRequest for testing\nasync function executeJsonRpcRequestTest(\n  baseUrl: URL,\n  method: string,\n  params: any,\n  headers: Record&lt;string, string&gt; = {},\n  options: { timeout?: number } = {}\n): Promise&lt;any&gt; {\n  const requestBody = createTestRequest(method, params);\n\n  const controller = new AbortController();\n  let timeoutId: NodeJS.Timeout | undefined;\n\n  if (options.timeout) {\n    timeoutId = setTimeout(() =&gt; controller.abort(), options.timeout);\n  }\n\n  try {\n    const response = await fetch(baseUrl, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        ...headers,\n      },\n      body: JSON.stringify(requestBody),\n      signal: controller.signal,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error ${response.status}`);\n    }\n\n    const textResponse = await response.text();\n    return parseResponseTest(textResponse);\n  } catch (error) {\n    if (error instanceof DOMException &amp;&amp; error.name === \"AbortError\") {\n      throw new Error(\"Request timeout\");\n    }\n    throw error;\n  } finally {\n    if (timeoutId !== undefined) {\n      clearTimeout(timeoutId);\n    }\n  }\n}\n\n// Define a simpler version of parseResponse for testing\nfunction parseResponseTest(data: string): any {\n  if (!data) {\n    throw new Error(\"Empty response\");\n  }\n\n  const parsed = JSON.parse(data);\n\n  if (parsed.error) {\n    throw new SystemError(\n      parsed.error.message,\n      parsed.error.code,\n      parsed.error.data\n    );\n  }\n\n  if (\n    typeof parsed !== \"object\" ||\n    parsed === null ||\n    parsed.jsonrpc !== \"2.0\"\n  ) {\n    throw new Error(\"Invalid response format\");\n  }\n\n  if (parsed.result === undefined) {\n    throw new Error(\"Invalid response: missing result\");\n  }\n\n  return parsed.result;\n}\n\n// Define the structure of our expected request body\ninterface TestJsonRpcRequest {\n  jsonrpc: string;\n  id: string | number;\n  method: string;\n  params?: Record&lt;string, any&gt;;\n}\n\n// Setup MSW server for mocking HTTP requests\nconst server = setupServer(\n  // Mock successful JSON-RPC request\n  http.post(\"https://example.com/api\", async ({ request }) =&gt; {\n    const body = (await request.json()) as TestJsonRpcRequest;\n\n    if (typeof body === \"object\" &amp;&amp; body !== null) {\n      if (body.method === \"test/echo\") {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: body.id,\n          result: body.params,\n        });\n      }\n\n      if (body.method === \"test/error\") {\n        return HttpResponse.json({\n          jsonrpc: \"2.0\",\n          id: body.id,\n          error: {\n            code: -32603,\n            message: \"Test error\",\n            data: { detail: \"This is a test error\" },\n          },\n        });\n      }\n\n      return HttpResponse.json({\n        jsonrpc: \"2.0\",\n        id: body.id || \"unknown\",\n        error: {\n          code: -32601,\n          message: \"Method not found\",\n        },\n      });\n    }\n\n    // Return a generic error for invalid bodies\n    return HttpResponse.json({\n      jsonrpc: \"2.0\",\n      id: null,\n      error: {\n        code: -32700,\n        message: \"Parse error\",\n      },\n    });\n  }),\n\n  // Mock error response\n  http.post(\"https://example.com/api/error\", () =&gt; {\n    return new HttpResponse(null, { status: 500 });\n  }),\n\n  // Mock timeout\n  http.post(\"https://example.com/api/timeout\", () =&gt; {\n    return new Promise((resolve) =&gt; {\n      // Resolve after timeout to simulate network timeout\n      setTimeout(() =&gt; {\n        resolve(\n          HttpResponse.json({\n            jsonrpc: \"2.0\",\n            id: \"timeout-request\",\n            result: { message: \"Too late\" },\n          })\n        );\n      }, 2000);\n    });\n  })\n);\n\ndescribe(\"RPC Client\", () =&gt; {\n  beforeAll(() =&gt; {\n    server.listen();\n  });\n\n  afterAll(() =&gt; {\n    server.close();\n  });\n\n  beforeEach(() =&gt; {\n    server.resetHandlers();\n  });\n\n  describe(\"createJsonRpcRequest\", () =&gt; {\n    it(\"creates a valid JSON-RPC 2.0 request object\", () =&gt; {\n      // Use our test function instead of the actual one\n      const request = createTestRequest(\"test/method\", { param1: \"value1\" });\n\n      expect(request.jsonrpc).toBe(\"2.0\");\n      expect(request.method).toBe(\"test/method\");\n      expect(request.params).toEqual({ param1: \"value1\" });\n      expect(request.id).toBeDefined();\n      expect(typeof request.id).toBe(\"string\");\n    });\n\n    it(\"preserves the provided ID if supplied\", () =&gt; {\n      const customId = \"custom-request-id\";\n      // Use our test function instead of the actual one\n      const request = createTestRequest(\n        \"test/method\",\n        { param1: \"value1\" },\n        customId\n      );\n\n      expect(request.id).toBe(customId);\n    });\n  });\n\n  describe(\"executeJsonRpcRequest\", () =&gt; {\n    it(\"successfully executes a JSON-RPC request and returns the result\", async () =&gt; {\n      const params = { message: \"Hello, API!\" };\n      const result = await executeJsonRpcRequestTest(\n        new URL(\"https://example.com/api\"),\n        \"test/echo\",\n        params\n      );\n\n      expect(result).toEqual(params);\n    });\n\n    it(\"throws a SystemError on JSON-RPC error response\", async () =&gt; {\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api\"),\n          \"test/error\",\n          {}\n        )\n      ).rejects.toThrow(SystemError);\n\n      try {\n        await executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api\"),\n          \"test/error\",\n          {}\n        );\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect((error as SystemError&lt;any&gt;).code).toBe(-32603);\n        expect((error as SystemError&lt;any&gt;).message).toBe(\"Test error\");\n        expect((error as SystemError&lt;any&gt;).data).toEqual({\n          detail: \"This is a test error\",\n        });\n      }\n    });\n\n    it(\"throws an error for non-existent methods\", async () =&gt; {\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api\"),\n          \"non/existent/method\",\n          {}\n        )\n      ).rejects.toThrow(\"Method not found\");\n    });\n\n    it(\"throws an error for HTTP error responses\", async () =&gt; {\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api/error\"),\n          \"test/method\",\n          {}\n        )\n      ).rejects.toThrow();\n    });\n\n    it(\"times out for long-running requests\", async () =&gt; {\n      // Set a short timeout for this test\n      await expect(\n        executeJsonRpcRequestTest(\n          new URL(\"https://example.com/api/timeout\"),\n          \"test/method\",\n          {},\n          {},\n          { timeout: 500 } // 500ms timeout\n        )\n      ).rejects.toThrow(/timeout/i);\n    }, 2000); // Set a timeout for the test itself\n  });\n\n  describe(\"parseResponse\", () =&gt; {\n    it(\"parses a valid JSON-RPC response\", async () =&gt; {\n      const responseText = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        result: { success: true },\n      });\n\n      const parsedResult = parseResponseTest(responseText);\n      expect(parsedResult).toEqual({ success: true });\n    });\n\n    it(\"throws for invalid JSON responses\", async () =&gt; {\n      const responseText = \"This is not JSON\";\n\n      expect(() =&gt; parseResponseTest(responseText)).toThrow();\n    });\n\n    it(\"throws for missing result and error fields\", async () =&gt; {\n      const responseText = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        // Missing both result and error fields\n      });\n\n      expect(() =&gt; parseResponseTest(responseText)).toThrow(\"Invalid response\");\n    });\n\n    it(\"throws for error responses\", async () =&gt; {\n      const responseText = JSON.stringify({\n        jsonrpc: \"2.0\",\n        id: \"test-id\",\n        error: {\n          code: -32000,\n          message: \"Error message\",\n        },\n      });\n\n      expect(() =&gt; parseResponseTest(responseText)).toThrow(SystemError);\n\n      try {\n        parseResponseTest(responseText);\n      } catch (error) {\n        expect(error).toBeInstanceOf(SystemError);\n        expect((error as SystemError&lt;any&gt;).code).toBe(-32000);\n        expect((error as SystemError&lt;any&gt;).message).toBe(\"Error message\");\n      }\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/rpc-client.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest rpc-client.test.ts</code></li> </ol>"},{"location":"sdk/tests/rpc-client.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/server-error-handling.test.html","title":"server-error-handling.test","text":"<p>Tests for server error handling.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/server-error-handling.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2AServer Error Handling</li> <li>Task Handler Errors</li> <li>Invalid JSON-RPC Request Handling</li> <li>Content Type Handling</li> </ul>"},{"location":"sdk/tests/server-error-handling.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  jest,\n  describe,\n  it,\n  beforeEach,\n  afterEach,\n  expect,\n} from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  ExecutionContext,\n  InMemoryTaskStore,\n  Message,\n  MessageSendParams,\n  TaskContext,\n  TaskState,\n  UpdateEvent,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Define an error-prone task handler for testing\nasync function* errorProneTaskHandler(\n  context: ExecutionContext\n): AsyncGenerator&lt;UpdateEvent, void, unknown&gt; {\n  const params = context.getRequestParams() as MessageSendParams;\n  const taskId = params.message.taskId ?? context.id;\n  const contextId = context.id;\n  const text = params.message.parts\n    .filter((part) =&gt; part.kind === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // If the message contains \"throw\", we'll simulate an error\n  if (text.includes(\"throw\")) {\n    throw new Error(\"Simulated task error\");\n  }\n\n  // If the message contains \"fail\", we'll yield a failed state\n  if (text.includes(\"fail\")) {\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Failed,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Task failed intentionally.\" }],\n        } as Message,\n      },\n      final: true,\n    };\n    return;\n  }\n\n  // Otherwise, normal processing\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Working,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Working...\" }],\n      },\n    },\n    final: false,\n  };\n\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Task completed successfully.\" }],\n      },\n    },\n    final: true,\n  };\n}\n\ndescribe(\"A2AServer Error Handling\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    server = new A2AServer({\n      handler: errorProneTaskHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Task Handler Errors\", () =&gt; {\n    it(\"handles exceptions thrown by task handler\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"error-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"error-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This will throw an error\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      // The server should handle the error and return a failed task\n      expect(response.status).toBe(200);\n      // When the task handler throws, the server should return an error in the response\n      // or a task with failed state\n      if (response.body.result) {\n        expect(response.body.result.id).toBe(\"error-task-1\");\n        expect(response.body.result.status.state).toBe(\"failed\");\n      } else if (response.body.error) {\n        // Or it might return an internal error\n        expect(response.body.error).toBeDefined();\n        expect(response.body.error.code).toBe(-32603); // Internal error\n        expect(response.body.error.message).toBe(\"Internal error\");\n      }\n    });\n\n    it(\"correctly handles task failed state\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"fail-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"fail-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This will fail\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"fail-task-1\");\n      expect(response.body.result.status.state).toBe(\"failed\");\n      expect(response.body.result.status.message).toBeDefined();\n      expect(response.body.result.status.message.parts[0].text).toBe(\n        \"Task failed intentionally.\"\n      );\n    });\n  });\n\n  describe(\"Invalid JSON-RPC Request Handling\", () =&gt; {\n    it.skip(\"handles invalid JSON in request body\", async () =&gt; {\n      const response = await trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Content-Type\", \"application/json\")\n          .send(\"this is not valid json\")\n      );\n\n      // The server might return either a 400 Bad Request or 200 with JSON-RPC error\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32700); // JSON parse error\n      expect(response.body.error.message).toBe(\"Invalid JSON payload\");\n    });\n\n    it(\"returns error for empty request body\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).post(\"/\").set(\"Content-Type\", \"application/json\").send(\"\")\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      // Should be parse error or invalid request\n      expect([-32700, -32600].includes(response.body.error.code)).toBe(true);\n    });\n\n    it.skip(\"returns error when request body is not an object\", async () =&gt; {\n      const response = await trackRequest(request(app).post(\"/\").send(\"42\"));\n\n      // The server might return various status codes for invalid content types\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect([-32700, -32600].includes(response.body.error.code)).toBe(true);\n    });\n  });\n\n  describe(\"Content Type Handling\", () =&gt; {\n    it(\"accepts JSON-RPC requests with application/json content type\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"content-type-test\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"content-type-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Testing content type\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Content-Type\", \"application/json\")\n          .send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"content-type-task-1\");\n    });\n\n    it(\"accepts JSON-RPC requests with application/json; charset=utf-8\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"charset-test\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"charset-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Testing charset\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Content-Type\", \"application/json; charset=utf-8\")\n          .send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"charset-task-1\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/server-error-handling.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest server-error-handling.test.ts</code></li> </ol>"},{"location":"sdk/tests/server-error-handling.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/server-impl.test.html","title":"server-impl.test","text":"<p>Tests for server impl.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/server-impl.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Server Implementation Tests</li> <li>Server Configuration</li> <li>Error Handling</li> <li>Task History Management</li> <li>Task Timestamps</li> </ul>"},{"location":"sdk/tests/server-impl.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  jest,\n  describe,\n  it,\n  beforeEach,\n  afterEach,\n  expect,\n} from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  ExecutionContext,\n  UpdateEvent,\n  INTERNAL_ERROR,\n  AgentCard,\n  configureLogger,\n  TaskYieldUpdate,\n  TaskState,\n  Message,\n  MessageSendParams,\n  SendMessageRequest,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Create a specialized task handler for more coverage testing\nasync function* serverImplTestHandler(\n  context: ExecutionContext\n): AsyncGenerator&lt;UpdateEvent, void, unknown&gt; {\n  const params = context.getRequestParams() as MessageSendParams;\n  const taskId = params.message.taskId ?? context.id;\n  const contextId = context.id;\n  const text = params.message.parts\n    .filter((part) =&gt; part.kind === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Need to specifically test error conditions\n  if (text.includes(\"throw-internal\")) {\n    throw INTERNAL_ERROR(new Error(\"Internal test error\"));\n  }\n\n  // Test for different state transitions in detail\n  if (text.includes(\"streaming\")) {\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Submitted,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Task submitted...\" }],\n        },\n      },\n      final: false,\n    };\n\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Working,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Working...\" }],\n        },\n      },\n      final: false,\n    };\n\n    // Simulate a few more updates\n    for (let i = 1; i &lt;= 3; i++) {\n      yield {\n        taskId: taskId,\n        contextId: contextId,\n        kind: \"status-update\",\n        status: {\n          state: TaskState.Working,\n          message: {\n            messageId: \"test-message-id\",\n            kind: \"message\",\n            role: \"agent\",\n            parts: [{ kind: \"text\", text: `Still working (${i}/3)...` }],\n          },\n        },\n        final: false,\n      };\n\n      // Small delay to simulate processing\n      await new Promise((resolve) =&gt; setTimeout(resolve, 50));\n    }\n\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Completed,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Task completed successfully!\" }],\n        },\n      },\n      final: true,\n    };\n    return;\n  }\n\n  // Default case\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Working,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Working on it...\" }],\n      },\n    },\n    final: false,\n  };\n\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Completed!\" }],\n      },\n    },\n    final: true,\n  };\n}\n\ndescribe(\"Server Implementation Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    // Create a server with a custom agent card to test that code path\n    const customCard: AgentCard = {\n      name: \"Server Impl Test Agent\",\n      url: \"http://localhost:41241\",\n      version: \"1.0.0\",\n      capabilities: {\n        streaming: true,\n        pushNotifications: true,\n        stateTransitionHistory: true,\n      },\n      skills: [\n        {\n          id: \"test-skill\",\n          name: \"Test Skill\",\n          description: \"Test skill description\",\n          tags: [\"test\", \"skill\"],\n        },\n      ],\n      defaultInputModes: [\"text\"],\n      defaultOutputModes: [\"text\"],\n      description: \"Test agent description\",\n    };\n\n    server = new A2AServer({\n      handler: serverImplTestHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n      card: customCard,\n      // Use custom CORS options to test that code path\n      corsOptions: {\n        origin: [\"http://localhost:3000\"],\n        methods: [\"GET\", \"POST\", \"OPTIONS\"],\n        allowedHeaders: [\"Content-Type\", \"Authorization\"],\n      },\n      // Use custom base path to test that code path\n      basePath: \"/api\",\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Server Configuration\", () =&gt; {\n    it(\"uses custom base path\", async () =&gt; {\n      // Test that the API endpoint is available at the custom path\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"test-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"test-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Basic test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app)\n          .post(\"/api\") // Using custom path\n          .send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"test-task-1\");\n    });\n\n    it(\"uses custom agent card\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).get(\"/.well-known/agent.json\")\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.name).toBe(\"Server Impl Test Agent\");\n      expect(response.body.skills[0].id).toBe(\"test-skill\");\n    });\n\n    it(\"properly applies CORS settings\", async () =&gt; {\n      const response = await trackRequest(\n        request(app)\n          .options(\"/api\")\n          .set(\"Origin\", \"http://localhost:3000\")\n          .set(\"Access-Control-Request-Method\", \"POST\")\n      );\n\n      expect(response.status).toBe(204);\n      expect(response.header[\"access-control-allow-origin\"]).toBe(\n        \"http://localhost:3000\"\n      );\n      expect(response.header[\"access-control-allow-methods\"]).toContain(\"GET\");\n      expect(response.header[\"access-control-allow-methods\"]).toContain(\"POST\");\n    });\n  });\n\n  describe(\"Error Handling\", () =&gt; {\n    it(\"handles SystemError thrown by task handler\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"internal-error-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"internal-error-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"This will throw-internal error\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32603);\n      expect(response.body.error.message).toBe(\"Internal error\");\n    });\n\n    it(\"returns TASK_NOT_FOUND error for non-existent task\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\"); //todo not returning error message\n    });\n\n    it(\"returns METHOD_NOT_FOUND error for invalid method\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-method-request-1\",\n        method: \"invalid/method\",\n        params: {\n          id: \"invalid-method-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32601);\n      expect(response.body.error.message).toBe(\"Method not found\");\n    });\n\n    it(\"returns INVALID_PARAMS error for missing params\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-params-request-1\",\n        method: \"message/send\",\n        // Missing params\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n\n    it(\"returns INVALID_PARAMS error for invalid task ID\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-task-id-request-1\",\n        method: \"tasks/get\",\n        params: {\n          // Missing id\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n  });\n\n  describe(\"Task History Management\", () =&gt; {\n    it(\"requests task with history\", async () =&gt; {\n      // First create a task\n      const createBody = {\n        jsonrpc: \"2.0\",\n        id: \"history-create-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"history-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task for history test\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/api\").send(createBody));\n\n      // Now retrieve it with history\n      const retrieveBody = {\n        jsonrpc: \"2.0\",\n        id: \"history-retrieve-request-1\",\n        method: \"tasks/get\",\n        params: {\n          id: \"history-task-1\",\n          historyLength: 2,\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(retrieveBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"history-task-1\");\n      // History might or might not be included depending on implementation\n    });\n\n    it(\"includes session ID when provided\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"session-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"session-task-1\",\n            contextId: \"test-session-123\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task with session ID\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"session-task-1\");\n      expect(response.body.result.contextId).toBe(\"test-session-123\");\n    });\n\n    it(\"includes metadata when provided\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"metadata-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"metadata-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task with metadata\" }],\n          },\n          metadata: {\n            testKey: \"testValue\",\n            source: \"unit-test\",\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"metadata-task-1\");\n      // Metadata might be stored but not returned, depending on implementation\n    });\n  });\n\n  describe(\"Task Timestamps\", () =&gt; {\n    it(\"includes timestamps in task status\", async () =&gt; {\n      const requestBody: SendMessageRequest = {\n        jsonrpc: \"2.0\",\n        id: \"timestamp-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            messageId: \"timestamp-message-id-1\",\n            kind: \"message\",\n            taskId: \"timestamp-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task for timestamp test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/api\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.status.timestamp).toBeDefined();\n\n      // Verify it's a valid ISO date string\n      const timestamp = new Date(response.body.result.status.timestamp);\n      expect(timestamp.toString()).not.toBe(\"Invalid Date\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/server-impl.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest server-impl.test.ts</code></li> </ol>"},{"location":"sdk/tests/server-impl.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/server.test.html","title":"server.test","text":"<p>Tests for server.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/server.test.html#test-suites","title":"Test Suites","text":"<ul> <li>A2AServer</li> <li>Agent Card</li> <li>message/send</li> <li>tasks/get</li> <li>tasks/cancel</li> <li>Method not found</li> </ul>"},{"location":"sdk/tests/server.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  describe,\n  beforeEach,\n  afterEach,\n  it,\n  expect,\n  jest,\n} from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  InMemoryTaskStore,\n  TaskStore,\n  configureLogger,\n  TaskState,\n  ExecutionContext,\n  AgentEngine,\n  MessageSendParams,\n  logInfo,\n  SendMessageRequest,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Define test task handler\nconst basicTaskHandler: AgentEngine = async function* (\n  context: ExecutionContext\n) {\n  const params = context.getRequestParams() as MessageSendParams;\n  const taskId = params.message.taskId ?? context.id;\n  const contextId = context.id;\n  // Check if task already has status, if not, use \"working\"\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Working,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Working on it...\" }],\n      },\n    },\n    final: false,\n  };\n\n  // Simulate some work\n  await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n\n  // Check for cancellation\n  if (context.isCancelled()) {\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: { state: TaskState.Canceled },\n      final: true,\n    };\n    return;\n  }\n  // Generate a result artifact\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"artifact-update\",\n    artifact: {\n      artifactId: \"test-artifact-id\",\n      name: \"result.txt\",\n      parts: [\n        {\n          kind: \"text\",\n          text: `Task ${contextId} completed successfully.`,\n        },\n      ],\n    },\n    lastChunk: true,\n  };\n  // Final completion status\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Task completed successfully!\" }],\n      },\n    },\n    final: true,\n  };\n};\n\ndescribe(\"A2AServer\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let taskStore: TaskStore;\n  // Track any pending requests for cleanup\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    taskStore = new InMemoryTaskStore();\n    server = new A2AServer({\n      handler: basicTaskHandler,\n      taskStore,\n      port: 0, // Don't actually listen\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Ensure all pending requests are completed\n    await Promise.all(\n      pendingRequests.map((req) =&gt; {\n        try {\n          return req;\n        } catch (e) {\n          // Ignore errors during cleanup\n          return null;\n        }\n      })\n    );\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  describe(\"Agent Card\", () =&gt; {\n    it(\"serves agent card at /.well-known/agent.json\", async () =&gt; {\n      const response = await trackRequest(\n        request(app).get(\"/.well-known/agent.json\")\n      );\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty(\"name\");\n      expect(response.body).toHaveProperty(\"capabilities\");\n    });\n\n    it(\"serves agent card at /agent-card\", async () =&gt; {\n      const response = await trackRequest(request(app).get(\"/agent-card\"));\n      expect(response.status).toBe(200);\n      expect(response.body).toHaveProperty(\"name\");\n      expect(response.body).toHaveProperty(\"capabilities\");\n    });\n  });\n\n  describe(\"message/send\", () =&gt; {\n    it(\"handles a valid task send request\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"test-request-1\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"test-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Hello, world!\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.jsonrpc).toBe(\"2.0\");\n      expect(response.body.id).toBe(\"test-request-1\");\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"test-task-1\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n      expect(response.body.result.artifacts).toHaveLength(1);\n      expect(response.body.result.artifacts[0].name).toBe(\"result.txt\");\n    });\n\n    it(\"returns an error for invalid request format\", async () =&gt; {\n      const invalidRequest = {\n        // Missing required jsonrpc field\n        id: \"invalid-req\",\n        method: \"message/send\",\n        params: {\n          id: \"task-id\",\n          message: {\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(invalidRequest)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32600); // Invalid request error\n      expect(response.body.error.message).toBe(\n        \"Request payload validation error\"\n      ); //todo expected \"Request payload validation error\" but may be caused by the jsonrpc middleware\n    });\n\n    it(\"returns an error for missing task ID\", async () =&gt; {\n      const requestWithoutId = {\n        jsonrpc: \"2.0\",\n        id: \"missing-id-req\",\n        method: \"message/send\",\n        params: {\n          // Missing id field\n          message: {\n            // role: \"user\",\n            parts: [{ kind: \"text\", text: \"Test\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestWithoutId)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n    });\n  });\n\n  describe(\"tasks/get\", () =&gt; {\n    it(\"retrieves a task after it has been created\", async () =&gt; {\n      // First create a task\n      const createRequest = {\n        jsonrpc: \"2.0\",\n        id: \"create-req\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"retrieve-task\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task to retrieve\" }],\n          },\n        },\n      };\n\n      const createResponse = await trackRequest(\n        request(app).post(\"/\").send(createRequest)\n      );\n      logInfo(\"createResponse\", createResponse.body);\n\n      // Now try to retrieve it\n      const getRequest = {\n        jsonrpc: \"2.0\",\n        id: \"get-req\",\n        method: \"tasks/get\",\n        params: {\n          id: \"retrieve-task\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(getRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.result).toBeDefined();\n      expect(response.body.result.id).toBe(\"retrieve-task\");\n      expect(response.body.result.status.state).toBe(\"completed\");\n    });\n\n    it(\"returns an error for non-existent task\", async () =&gt; {\n      const getRequest = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-req\",\n        method: \"tasks/get\",\n        params: {\n          id: \"nonexistent-task\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(getRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n  });\n\n  describe(\"tasks/cancel\", () =&gt; {\n    it(\"successfully cancels a task\", async () =&gt; {\n      // First create a task\n      const createRequest = {\n        jsonrpc: \"2.0\",\n        id: \"create-cancel-req\",\n        method: \"message/send\",\n        params: {\n          message: {\n            taskId: \"cancel-task\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Task to cancel\" }],\n          },\n        },\n      };\n\n      await trackRequest(request(app).post(\"/\").send(createRequest));\n\n      // Now try to cancel it (note: the task may complete before cancellation in this test)\n      const cancelRequest = {\n        jsonrpc: \"2.0\",\n        id: \"cancel-req\",\n        method: \"tasks/cancel\",\n        params: {\n          id: \"cancel-task\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(cancelRequest)\n      );\n\n      // It's possible the task completes before we can cancel it,\n      // in which case we'll get a \"task not cancelable\" error,\n      // but that's also a valid test result\n      if (response.body.error) {\n        expect(response.body.error.code).toBe(-32002);\n        expect(response.body.error.message).toBe(\"Task cannot be canceled\");\n      } else {\n        expect(response.status).toBe(200);\n        expect(response.body.result).toBeDefined();\n        expect(response.body.result.id).toBe(\"cancel-task\");\n        expect(response.body.result.status.state).toBe(\"canceled\");\n      }\n    });\n  });\n\n  describe(\"Method not found\", () =&gt; {\n    it(\"returns a method not found error for unknown methods\", async () =&gt; {\n      const unknownMethodRequest = {\n        jsonrpc: \"2.0\",\n        id: \"unknown-method-req\",\n        method: \"unknown/method\",\n        params: {},\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(unknownMethodRequest)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32601);\n      expect(response.body.error.message).toBe(\"Method not found\");\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/server.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest server.test.ts</code></li> </ol>"},{"location":"sdk/tests/server.test.html#coverage","title":"Coverage","text":""},{"location":"sdk/tests/streaming.test.html","title":"streaming.test","text":"<p>Tests for streaming.test functionality in the Artinet SDK.</p>"},{"location":"sdk/tests/streaming.test.html#test-suites","title":"Test Suites","text":"<ul> <li>Streaming API Tests</li> <li>message/stream</li> <li>tasks/resubscribe</li> </ul>"},{"location":"sdk/tests/streaming.test.html#source-code","title":"Source Code","text":"<pre><code>import {\n  jest,\n  describe,\n  it,\n  beforeEach,\n  afterEach,\n  expect,\n} from \"@jest/globals\";\nimport express from \"express\";\nimport request from \"supertest\";\nimport {\n  A2AServer,\n  ExecutionContext,\n  InMemoryTaskStore,\n  MessageSendParams,\n  SendStreamingMessageRequest,\n  TaskContext,\n  TaskResubscriptionRequest,\n  TaskState,\n  UpdateEvent,\n  configureLogger,\n} from \"../src/index.js\";\n\n// Set a reasonable timeout for all tests\njest.setTimeout(10000);\nconfigureLogger({ level: \"silent\" });\n\n// Specialized task handler for streaming tests\nasync function* streamingTestHandler(\n  context: ExecutionContext\n): AsyncGenerator&lt;UpdateEvent, void, unknown&gt; {\n  const params = context.getRequestParams() as MessageSendParams;\n  const taskId = params.message.taskId ?? context.id;\n  const contextId = context.id;\n  const text = params.message.parts\n    .filter((part) =&gt; part.kind === \"text\")\n    .map((part) =&gt; (part as any).text)\n    .join(\" \");\n\n  // Quick completion without streaming for non-streaming tests\n  if (text.includes(\"quick\")) {\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Completed,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: \"Quick completion\" }],\n        },\n      },\n      final: true,\n    };\n    return;\n  }\n\n  // Test for resubscription\n  if (text.includes(\"resubscribe\")) {\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Working,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [\n            { kind: \"text\", text: \"Starting work for resubscribe test...\" },\n          ],\n        },\n      },\n      final: false,\n    };\n\n    // Add a small delay to allow for resubscription test\n    await new Promise((resolve) =&gt; setTimeout(resolve, 100));\n\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Completed,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [\n            { kind: \"text\", text: \"Completed task for resubscribe test\" },\n          ],\n        },\n      },\n      final: true,\n    };\n    return;\n  }\n\n  // Long running task with multiple updates\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Submitted,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Task submitted\" }],\n      },\n    },\n    final: false,\n  };\n\n  // Progress updates\n  for (let i = 1; i &lt;= 3; i++) {\n    yield {\n      taskId: taskId,\n      contextId: contextId,\n      kind: \"status-update\",\n      status: {\n        state: TaskState.Working,\n        message: {\n          messageId: \"test-message-id\",\n          kind: \"message\",\n          role: \"agent\",\n          parts: [{ kind: \"text\", text: `Progress update ${i}/3` }],\n        },\n      },\n      final: false,\n    };\n\n    // Small delay to simulate processing\n    await new Promise((resolve) =&gt; setTimeout(resolve, 50));\n  }\n\n  // Final completion\n  yield {\n    taskId: taskId,\n    contextId: contextId,\n    kind: \"status-update\",\n    status: {\n      state: TaskState.Completed,\n      message: {\n        messageId: \"test-message-id\",\n        kind: \"message\",\n        role: \"agent\",\n        parts: [{ kind: \"text\", text: \"Task completed successfully\" }],\n      },\n    },\n    final: true,\n  };\n}\n\ndescribe(\"Streaming API Tests\", () =&gt; {\n  let server: A2AServer;\n  let app: express.Express;\n  let pendingRequests: request.Test[] = [];\n\n  beforeEach(() =&gt; {\n    server = new A2AServer({\n      handler: streamingTestHandler,\n      taskStore: new InMemoryTaskStore(),\n      port: 0, // Don't actually listen\n      card: {\n        name: \"Streaming Test Agent\",\n        url: \"http://localhost:41241\",\n        version: \"1.0.0\",\n        capabilities: {\n          streaming: true,\n          pushNotifications: false,\n          stateTransitionHistory: true,\n        },\n        skills: [\n          {\n            id: \"streaming-test\",\n            name: \"Streaming Test Skill\",\n            description: \"Streaming Test Skill\",\n            tags: [\"streaming\", \"test\"],\n          },\n        ],\n        description: \"Streaming Test Agent\",\n        defaultInputModes: [\"text\"],\n        defaultOutputModes: [\"text\"],\n      },\n    });\n    app = server.start();\n    pendingRequests = [];\n  });\n\n  afterEach(async () =&gt; {\n    // Clear the pending requests array - we don't need to re-execute them\n    pendingRequests = [];\n\n    await server.stop();\n    // Add a small delay to allow any open connections to close\n    await new Promise((resolve) =&gt; setTimeout(resolve, 250));\n  });\n\n  // Helper function to track supertest requests\n  const trackRequest = (req: request.Test): request.Test =&gt; {\n    pendingRequests.push(req);\n    return req;\n  };\n\n  // Helper to collect streamed events\n  const collectStreamEvents = async (\n    req: request.Test,\n    timeout = 2000\n  ): Promise&lt;string[]&gt; =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      const events: string[] = [];\n      let responseEnded = false;\n      const timeoutId = setTimeout(() =&gt; {\n        if (!responseEnded) {\n          responseEnded = true;\n          resolve(events);\n        }\n      }, timeout);\n\n      req\n        .buffer(false)\n        .parse((res, callback) =&gt; {\n          res.setEncoding(\"utf8\");\n          let data = \"\";\n          res.on(\"data\", (chunk: string) =&gt; {\n            data += chunk;\n            // Server-Sent Events are separated by double newlines\n            const parts = data.split(\"\\n\\n\");\n            if (parts.length &gt; 1) {\n              data = parts.pop() || \"\";\n              for (const part of parts) {\n                if (part.trim()) {\n                  events.push(part);\n                }\n              }\n            }\n          });\n          res.on(\"end\", () =&gt; {\n            clearTimeout(timeoutId);\n            if (!responseEnded) {\n              responseEnded = true;\n              resolve(events);\n            }\n          });\n          res.on(\"error\", (err) =&gt; {\n            clearTimeout(timeoutId);\n            if (!responseEnded) {\n              responseEnded = true;\n              reject(err);\n            }\n          });\n          callback(null, res);\n        })\n        .end((err) =&gt; {\n          if (err &amp;&amp; !responseEnded) {\n            responseEnded = true;\n            reject(err);\n          }\n        });\n    });\n  };\n\n  describe(\"message/stream\", () =&gt; {\n    it(\"establishes a stream and sends events until completion\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"stream-request-1\",\n        method: \"message/stream\",\n        params: {\n          message: {\n            taskId: \"stream-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Test streaming updates\" }],\n          },\n        },\n      };\n\n      const req = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(requestBody)\n      );\n\n      const events = await collectStreamEvents(req);\n\n      // Check for all expected events\n      expect(events.length).toBeGreaterThanOrEqual(5); // submitted + 3 working + completed\n\n      // Verify events contain correct data\n      let foundSubmitted = false;\n      let workingCount = 0;\n      let foundCompleted = false;\n      let foundFinal = false;\n\n      for (const event of events) {\n        const lines = event.split(\"\\n\");\n        const dataLine = lines.find((line) =&gt; line.startsWith(\"data:\"));\n\n        if (dataLine) {\n          const data = JSON.parse(dataLine.substring(5).trim());\n\n          if (data.result?.status?.state === \"submitted\") {\n            foundSubmitted = true;\n          } else if (data.result?.status?.state === \"working\") {\n            workingCount++;\n          } else if (data.result?.status?.state === \"completed\") {\n            foundCompleted = true;\n          }\n\n          if (data.result?.final === true) {\n            foundFinal = true;\n          }\n        }\n      }\n\n      expect(foundSubmitted).toBe(true);\n      expect(workingCount).toBeGreaterThanOrEqual(3);\n      expect(foundCompleted).toBe(true);\n      expect(foundFinal).toBe(true);\n    });\n\n    it(\"returns error if task ID is missing\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"invalid-stream-1\",\n        method: \"message/stream\",\n        params: {\n          // Missing id\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Missing task ID\" }],\n          },\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32602);\n      expect(response.body.error.message).toBe(\"Invalid parameters\");\n      // Invalid params\n    });\n  });\n\n  describe(\"tasks/resubscribe\", () =&gt; {\n    it(\"allows resubscribing to an existing task stream\", async () =&gt; {\n      // First create a streaming task\n      const createBody: SendStreamingMessageRequest = {\n        jsonrpc: \"2.0\",\n        id: \"resubscribe-request-1\",\n        method: \"message/stream\",\n        params: {\n          message: {\n            messageId: \"resubscribe-message-id-1\",\n            kind: \"message\",\n            taskId: \"resubscribe-task-1\",\n            role: \"user\",\n            parts: [{ kind: \"text\", text: \"Test for resubscribe\" }],\n          },\n        },\n      };\n\n      const req1 = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(createBody)\n      );\n\n      // Start collecting events from first request\n      const initialEventsPromise = collectStreamEvents(req1, 500);\n\n      // Wait a bit to ensure the task is started\n      await new Promise((resolve) =&gt; setTimeout(resolve, 200));\n\n      // Now resubscribe to the same task\n      const resubscribeBody: TaskResubscriptionRequest = {\n        jsonrpc: \"2.0\",\n        id: \"resubscribe-stream-2\",\n        method: \"tasks/resubscribe\",\n        params: {\n          id: \"resubscribe-task-1\",\n        },\n      };\n\n      const req2 = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(resubscribeBody)\n      );\n\n      // Collect events from the resubscription request\n      const resubscribeEvents = await collectStreamEvents(req2);\n\n      // Wait for the initial events to complete\n      const initialEvents = await initialEventsPromise;\n\n      // Verify we received events from resubscription\n      expect(resubscribeEvents.length).toBeGreaterThan(0);\n\n      // Check for task completion event in at least one of the streams\n      const allEvents = [...initialEvents, ...resubscribeEvents];\n      let foundCompleted = false;\n\n      for (const event of allEvents) {\n        const lines = event.split(\"\\n\");\n        const dataLine = lines.find((line) =&gt; line.startsWith(\"data:\"));\n\n        if (dataLine) {\n          const data = JSON.parse(dataLine.substring(5).trim());\n          if (data.result?.status?.state === \"completed\") {\n            foundCompleted = true;\n            break;\n          }\n        }\n      }\n\n      expect(foundCompleted).toBe(true);\n    });\n\n    it(\"returns error when resubscribing to non-existent task\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"nonexistent-resubscribe-1\",\n        method: \"tasks/resubscribe\",\n        params: {\n          id: \"nonexistent-task-1\",\n        },\n      };\n\n      const response = await trackRequest(\n        request(app).post(\"/\").send(requestBody)\n      );\n      expect(response.status).toBe(200);\n      expect(response.body.error).toBeDefined();\n      expect(response.body.error.code).toBe(-32001);\n      expect(response.body.error.message).toBe(\"Task not found\");\n    });\n  });\n\n  describe.skip(\"Stream Management\", () =&gt; {\n    it(\"removes stream on connection close\", async () =&gt; {\n      const requestBody = {\n        jsonrpc: \"2.0\",\n        id: \"close-stream-request-1\",\n        method: \"message/stream\",\n        params: {\n          id: \"close-stream-task-1\",\n          message: {\n            role: \"user\",\n            parts: [{ type: \"text\", text: \"Test stream connection close\" }],\n          },\n        },\n      };\n\n      const req = trackRequest(\n        request(app)\n          .post(\"/\")\n          .set(\"Accept\", \"text/event-stream\")\n          .send(requestBody)\n      );\n\n      // Get a few events\n      let eventsReceived = 0;\n      const timeoutPromise = new Promise&lt;void&gt;((resolve) =&gt;\n        setTimeout(resolve, 500)\n      );\n      const initialActiveStreams = server.getActiveStreams();\n      const initialTaskStreams = initialActiveStreams.get(\n        \"close-stream-task-1\"\n      );\n      console.log(\"Initial active streams\", initialActiveStreams);\n      console.log(\"Initial task streams\", initialTaskStreams);\n      expect(initialTaskStreams).toBeDefined();\n\n      req.buffer(false).parse((res, callback) =&gt; {\n        res.setEncoding(\"utf8\");\n        res.on(\"data\", () =&gt; {\n          eventsReceived++;\n          if (eventsReceived &gt;= 2) {\n            // Simulate client disconnection by destroying the response\n            (res as any).destroy();\n          }\n        });\n        callback(null, res);\n      });\n\n      await timeoutPromise;\n\n      // Explicitly abort the supertest request after destroying the response\n      req.abort();\n\n      // Get the number of active streams for this task\n      const activeStreams = server.getActiveStreams();\n      const taskStreams = activeStreams.get(\"close-stream-task-1\");\n\n      // The stream should have been removed after disconnection\n      expect(taskStreams).toBeUndefined();\n    });\n  });\n});\n</code></pre>"},{"location":"sdk/tests/streaming.test.html#running-the-tests","title":"Running the Tests","text":"<p>To run these tests:</p> <ol> <li>Clone the Artinet SDK repository</li> <li>Install dependencies with <code>npm install</code></li> <li>Run the tests with <code>npm test</code> or specifically with <code>npx jest streaming.test.ts</code></li> </ol>"},{"location":"sdk/tests/streaming.test.html#coverage","title":"Coverage","text":""}]}