{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Artinet SDK!","text":""},{"location":"#what-is-the-artinet-sdk","title":"What is the Artinet SDK?","text":"<p>The Artinet SDK is a robust implementation of the Agent2Agent (A2A) Protocol that enables developers to create and connect AI agents. Written in TypeScript, this SDK provides everything you need to build, deploy, and interact with A2A-compliant agents.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Production-Ready: Built with a focus on developer experience, reliability, and comprehensive features.</li> <li>Plug-and-Play Server: Built on Express.js, the SDK handles JSON-RPC complexity, routing, protocol compliance, and streaming mechanics automatically.</li> <li>Enhanced Client: Features refined error handling, flexible header management for authentication, and clear separation of concerns.</li> <li>TypeScript First: Fully written in TypeScript with comprehensive type definitions for a robust developer experience.</li> <li>Flexible Storage: Choose between memory storage for development or file-based persistence for production.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code># Install the SDK\nnpm install @artinet/sdk\n</code></pre> <p>Create your first agent in just a few lines of code:</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Define your agent logic\nconst myAgent: TaskHandler = async function* (context: TaskContext) {\n  yield { state: \"working\" };\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Hello from Artinet!\" }],\n    },\n  };\n};\n\n// Start your server\nconst server = new A2AServer({\n  taskHandler: myAgent,\n  taskStore: new InMemoryTaskStore(),\n  port: 3000,\n  basePath: \"/a2a\",\n  card: {\n    name: \"My First Agent\",\n    url: \"http://localhost:3000/a2a\",\n    version: \"0.1.0\",\n    capabilities: { streaming: true },\n    skills: [{ id: \"greeting\", name: \"Greeting Skill\" }],\n  },\n});\n\nserver.start();\nconsole.log(\"Agent running at http://localhost:3000/a2a\");\n</code></pre>"},{"location":"#why-use-artinet-sdk","title":"Why Use Artinet SDK?","text":"<ul> <li>A2A Protocol Compliance: Full implementation of the official A2A specification using the official JSON schema.</li> <li>Robust Streaming: Reliable Server-Sent Events (SSE) support for real-time communication.</li> <li>Configurable Logging: Integrated structured logging via <code>pino</code> with configurable levels.</li> <li>Advanced Customization: Fine-grained control over the JSON-RPC server, enabling integration with existing Express apps or adding custom methods.</li> <li>Comprehensive Testing: Includes a robust test suite to ensure reliability and maintainability.</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<p>Ready to dive deeper? Check out these resources:</p> <ul> <li>Quick Start Guide - Get up and running with a complete agent example</li> <li>Core Components - Understand the fundamental building blocks of the SDK</li> <li>Examples - Explore common usage patterns and scenarios</li> <li>API Reference - Detailed documentation of all classes and methods</li> </ul>"},{"location":"agents/quick_agents/","title":"Quick Agents Guide","text":"<p>This guide explains how to use the Artinet SDK's Quick Agents feature to rapidly build, test, and deploy your agents.</p>"},{"location":"agents/quick_agents/#what-are-quick-agents","title":"What are Quick Agents?","text":"<p>Quick Agents provide a streamlined way to:</p> <ol> <li>Bundle your agent code and dependencies into a single file</li> <li>Test your agent in a sandboxed environment</li> <li>Deploy your agent to the Artinet platform (for beta users)</li> </ol> <p>This feature is ideal for:</p> <ul> <li>Rapid prototyping</li> <li>Testing agent behavior without setting up a full server</li> <li>Sharing your agent with others</li> <li>Deploying to the Artinet ecosystem</li> </ul>"},{"location":"agents/quick_agents/#key-components","title":"Key Components","text":"<p>The Quick Agents feature includes several important utilities:</p> <ul> <li><code>bundle</code>: Packages your agent code and dependencies into a single distributable file</li> <li><code>taskHandlerProxy</code>: Simplifies running your agent logic in managed environments</li> <li><code>fetchResponseProxy</code>: Enables communication with other agents in the Artinet ecosystem</li> <li><code>testDeployment</code>: Tests your bundled agent in a temporary sandboxed environment</li> </ul>"},{"location":"agents/quick_agents/#bundling-your-agent","title":"Bundling Your Agent","text":"<p>The first step is to bundle your agent's code:</p> <pre><code>import { bundle } from \"@artinet/sdk\";\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\n\n// Get the current file's directory\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nasync function bundleMyAgent() {\n  // Path to your agent's main file\n  const agentPath = path.join(__dirname, \"my-agent.ts\");\n\n  // Bundle the agent code\n  const bundledCode = await bundle(new URL(`file://${agentPath}`));\n\n  console.log(\"Agent bundled successfully!\");\n  return bundledCode;\n}\n\nbundleMyAgent()\n  .then((bundledCode) =&gt; {\n    // Save the bundled code to a file or use it for deployment\n    console.log(`Bundled code size: ${bundledCode.length} bytes`);\n  })\n  .catch((error) =&gt; {\n    console.error(\"Bundling failed:\", error);\n  });\n</code></pre>"},{"location":"agents/quick_agents/#creating-a-quick-agent","title":"Creating a Quick Agent","text":"<p>When writing an agent for bundling, you can use the <code>taskHandlerProxy</code> to simplify the process:</p> <pre><code>// my-agent.ts\nimport { taskHandlerProxy, fetchResponseProxy } from \"@artinet/sdk\";\n\n// Define your agent's core logic as an async function\nasync function* myQuickAgent(context) {\n  // Extract the user's message\n  const userInput = context.userMessage.parts[0]?.text || \"\";\n\n  // Signal that we're working on the task\n  yield { state: \"working\" };\n\n  // Do some processing...\n  const response = `You said: \"${userInput}\"`;\n\n  // Complete the task\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: response }]\n    }\n  };\n}\n\n// Export the agent wrapped in taskHandlerProxy\nexport default taskHandlerProxy(myQuickAgent);\n</code></pre>"},{"location":"agents/quick_agents/#testing-your-quick-agent","title":"Testing Your Quick Agent","text":"<p>Before deploying, you can test your bundled agent:</p> <pre><code>import { \n  testDeployment, \n  ServerDeploymentRequestParams, \n  SendTaskRequest \n} from \"@artinet/sdk\";\n\nasync function testMyAgent(bundledCode) {\n  // Prepare deployment parameters\n  const deploymentParams: ServerDeploymentRequestParams = {\n    code: bundledCode\n  };\n\n  // Create test tasks to verify your agent's behavior\n  const testRequests: SendTaskRequest[] = [\n    {\n      id: \"test-1\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: \"Hello, agent!\" }]\n      }\n    },\n    {\n      id: \"test-2\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: \"What can you do?\" }]\n      }\n    }\n  ];\n\n  console.log(\"Testing agent deployment...\");\n\n  try {\n    // Process each test result as it completes\n    for await (const result of testDeployment(deploymentParams, testRequests)) {\n      console.log(`Result for task ${result.id}:`);\n\n      if (result.message?.parts[0]?.type === \"text\") {\n        console.log(`Response: ${result.message.parts[0].text}`);\n      } else {\n        console.log(\"Task completed with non-text response:\", result);\n      }\n    }\n\n    console.log(\"All test tasks completed successfully!\");\n  } catch (error) {\n    console.error(\"Deployment test failed:\", error);\n  }\n}\n</code></pre>"},{"location":"agents/quick_agents/#communication-between-agents","title":"Communication Between Agents","text":"<p>Your Quick Agent can communicate with other agents in the Artinet ecosystem using the <code>fetchResponseProxy</code>:</p> <pre><code>import { taskHandlerProxy, fetchResponseProxy } from \"@artinet/sdk\";\n\nasync function* collaborativeAgent(context) {\n  const userInput = context.userMessage.parts[0]?.text || \"\";\n\n  yield { state: \"working\" };\n\n  // Call another agent for assistance\n  try {\n    const helperResponse = await fetchResponseProxy(\n      \"WeatherExpertAgent\", // Name of another agent in the Artinet ecosystem\n      {\n        role: \"user\",\n        parts: [{ type: \"text\", text: `What's the weather in ${userInput}?` }]\n      }\n    );\n\n    // Extract the helper agent's response\n    const weatherInfo = helperResponse.message?.parts[0]?.text || \"No weather information available\";\n\n    yield {\n      state: \"completed\",\n      message: {\n        role: \"agent\",\n        parts: [{ \n          type: \"text\", \n          text: `I asked my colleague about the weather in ${userInput}. Here's what they said:\\n\\n${weatherInfo}` \n        }]\n      }\n    };\n  } catch (error) {\n    yield {\n      state: \"error\",\n      message: {\n        role: \"agent\",\n        parts: [{ \n          type: \"text\", \n          text: `Sorry, I couldn't get weather information: ${error.message}` \n        }]\n      }\n    };\n  }\n}\n\nexport default taskHandlerProxy(collaborativeAgent);\n</code></pre>"},{"location":"agents/quick_agents/#complete-workflow-example","title":"Complete Workflow Example","text":"<p>Here's a complete example that brings all the components together:</p> <pre><code>import { \n  bundle, \n  testDeployment, \n  ServerDeploymentRequestParams,\n  SendTaskRequest\n} from \"@artinet/sdk\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\n\n// Get the current directory\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nasync function buildAndTestAgent() {\n  try {\n    console.log(\"Step 1: Bundling agent code...\");\n\n    // Bundle your agent code\n    const agentPath = path.join(__dirname, \"my-quick-agent.ts\");\n    const bundledCode = await bundle(new URL(`file://${agentPath}`));\n\n    console.log(`Successfully bundled agent (${bundledCode.length} bytes)`);\n\n    // Optionally save the bundled code\n    const outputPath = path.join(__dirname, \"bundled-agent.js\");\n    fs.writeFileSync(outputPath, bundledCode);\n    console.log(`Saved bundled code to: ${outputPath}`);\n\n    console.log(\"\\nStep 2: Testing agent in sandbox environment...\");\n\n    // Prepare deployment parameters\n    const deploymentParams: ServerDeploymentRequestParams = {\n      code: bundledCode,\n      // You can add optional metadata about your agent\n      metadata: {\n        name: \"My Quick Agent\",\n        version: \"1.0.0\",\n        description: \"A demonstration of the Quick Agents feature\"\n      }\n    };\n\n    // Create test scenarios\n    const testRequests: SendTaskRequest[] = [\n      {\n        id: \"greeting-test\",\n        message: {\n          role: \"user\",\n          parts: [{ type: \"text\", text: \"Hello there!\" }]\n        }\n      },\n      {\n        id: \"question-test\",\n        message: {\n          role: \"user\",\n          parts: [{ type: \"text\", text: \"What's your purpose?\" }]\n        }\n      }\n    ];\n\n    // Test the agent with each scenario\n    console.log(\"Running test cases...\");\n    for await (const result of testDeployment(deploymentParams, testRequests)) {\n      console.log(`\\nTest case: ${result.id}`);\n      console.log(`Status: ${result.status.state}`);\n\n      if (result.message?.parts[0]?.type === \"text\") {\n        console.log(`Response: ${result.message.parts[0].text}`);\n      } else if (result.artifacts?.length &gt; 0) {\n        console.log(`Generated ${result.artifacts.length} artifacts`);\n        result.artifacts.forEach((artifact, index) =&gt; {\n          console.log(`Artifact ${index + 1}: ${artifact.name} (${artifact.mimeType})`);\n        });\n      }\n    }\n\n    console.log(\"\\nAll tests completed successfully!\");\n    console.log(\"\\nStep 3: Your agent is ready for deployment to Artinet!\");\n    console.log(\"To join the beta and deploy your agent, email humans@artinet.io\");\n\n  } catch (error) {\n    console.error(\"Error during build and test process:\", error);\n  }\n}\n\nbuildAndTestAgent();\n</code></pre>"},{"location":"agents/quick_agents/#limitations-and-considerations","title":"Limitations and Considerations","text":"<p>When using Quick Agents, be aware of these limitations:</p> <ol> <li> <p>Test-Agents expire after 60 seconds by default (you can request longer durations for testing complex agents)</p> </li> <li> <p>Limited environment access:</p> </li> <li>Quick Agents do not have access to a filesystem</li> <li>Network access is restricted</li> <li> <p>No persistent storage is available</p> </li> <li> <p>Resource constraints:</p> </li> <li>Memory and CPU usage are limited</li> <li>Large dependencies may affect performance</li> </ol>"},{"location":"agents/quick_agents/#beta-access-for-deployment","title":"Beta Access for Deployment","text":"<p>The ability to permanently deploy agents to the Artinet platform is currently in beta. To join the waitlist:</p> <ol> <li>Email humans@artinet.io with your request</li> <li>Describe your agent's purpose and use case</li> <li>Include any specific requirements or features you need</li> </ol>"},{"location":"agents/quick_agents/#best-practices","title":"Best Practices","text":"<p>For optimal results with Quick Agents:</p> <ol> <li> <p>Keep dependencies minimal - Large dependencies increase bundle size and startup time</p> </li> <li> <p>Use efficient algorithms - Quick Agents have resource constraints</p> </li> <li> <p>Implement timeouts - Add timeouts for external operations to prevent hanging</p> </li> <li> <p>Handle errors gracefully - Ensure your agent can recover from failed operations</p> </li> <li> <p>Test thoroughly - Use a variety of test cases to verify behavior</p> </li> <li> <p>Structure your code carefully - Organize your agent logic for clarity and maintainability</p> </li> </ol>"},{"location":"agents/quick_agents/#faq","title":"FAQ","text":"<p>Q: How long does it take to deploy a Quick Agent? A: Test deployments typically take a few seconds. Production deployments (for beta users) may take 1-2 minutes.</p> <p>Q: Can I use external APIs in my Quick Agent? A: Yes, using the fetchResponseProxy, but be mindful of rate limits and timeouts.</p> <p>Q: How do I update a deployed agent? A: For beta users, you can deploy a new version which will replace the previous one.</p> <p>Q: What's the difference between testDeployment and actual deployment? A: testDeployment creates a temporary sandbox that expires after 60 seconds. Actual deployment (for beta users) creates a permanent agent instance in the Artinet ecosystem.</p> <p>Q: Can my Quick Agent maintain state between invocations? A: Test agents cannot maintain state. For beta users, limited persistence capabilities are planned.</p>"},{"location":"agents/quick_agents/#next-steps","title":"Next Steps","text":"<p>After mastering Quick Agents:</p> <ol> <li>Explore more complex agent architectures</li> <li>Implement collaboration between multiple agents</li> <li>Consider joining the beta program for production deployment</li> <li>Explore integrations with other AI services and tools</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>This section provides a comprehensive reference for the Artinet SDK Core API components. The SDK implements the Agent2Agent (A2A) Protocol and provides enhanced functionality for building interoperable AI agents.</p>"},{"location":"api/#overview","title":"Overview","text":"<p>The Artinet SDK API is organized into several key component categories:</p> <ol> <li>Client API - For sending tasks to and receiving responses from agents</li> <li>Server API - For hosting and implementing agent behavior</li> <li>Task Handling API - For defining agent logic and processing tasks</li> <li>Storage API - For persisting task data and state </li> <li>Advanced Customization API - For fine-tuning server behavior</li> <li>Core Types - Shared type definitions used throughout the SDK</li> </ol>"},{"location":"api/#client-api","title":"Client API","text":""},{"location":"api/#a2aclient","title":"A2AClient","text":"<p>The primary class for interacting with A2A-compliant agent servers.</p> <pre><code>class A2AClient {\n  /**\n   * Creates a new A2AClient instance.\n   * @param baseUrl The base URL of the A2A-compliant server\n   */\n  constructor(baseUrl: string);\n\n  /**\n   * Adds a single HTTP header to requests.\n   * @param key The header name\n   * @param value The header value\n   */\n  addHeader(key: string, value: string): void;\n\n  /**\n   * Sets multiple HTTP headers, replacing any existing headers.\n   * @param headers Key-value pairs of headers\n   */\n  setHeaders(headers: Record&lt;string, string&gt;): void;\n\n  /**\n   * Sends a task and returns the final result.\n   * @param params The task parameters\n   * @returns A Promise resolving to the completed task\n   */\n  async sendTask(params: SendTaskRequest[\"params\"]): Promise&lt;Task&gt;;\n\n  /**\n   * Retrieves information about an existing task.\n   * @param params The task parameters including task ID\n   * @returns A Promise resolving to the task\n   */\n  async getTask(params: GetTaskRequest[\"params\"]): Promise&lt;Task&gt;;\n\n  /**\n   * Cancels an in-progress task.\n   * @param params The task parameters including task ID\n   */\n  async cancelTask(params: CancelTaskRequest[\"params\"]): Promise&lt;void&gt;;\n\n  /**\n   * Sends a task and subscribes to streaming updates.\n   * @param params The task parameters\n   * @returns An AsyncGenerator yielding status and artifact updates\n   */\n  sendTaskSubscribe(params: SendTaskRequest[\"params\"]): AsyncGenerator&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\n\n  /**\n   * Resubscribes to updates for an existing task.\n   * @param params The resubscribe parameters including task ID\n   * @returns An AsyncGenerator yielding status and artifact updates\n   */\n  resubscribe(params: ResubscribeRequest[\"params\"]): AsyncGenerator&lt;TaskStatusUpdateEvent | TaskArtifactUpdateEvent&gt;;\n\n  /**\n   * Configures push notifications for a task.\n   * @param params The push notification parameters\n   */\n  async setTaskPushNotification(params: SetTaskPushNotificationRequest[\"params\"]): Promise&lt;void&gt;;\n\n  /**\n   * Retrieves push notification configuration for a task.\n   * @param params The parameters including task ID\n   * @returns The push notification configuration\n   */\n  async getTaskPushNotification(params: GetTaskPushNotificationRequest[\"params\"]): Promise&lt;TaskPushNotificationInfo&gt;;\n\n  /**\n   * Retrieves the agent card describing the server's capabilities.\n   * @returns A Promise resolving to the agent card\n   */\n  async getAgentCard(): Promise&lt;AgentCard&gt;;\n}\n</code></pre>"},{"location":"api/#rpcerror","title":"RpcError","text":"<p>Represents client-side errors encountered during A2A communication.</p> <pre><code>class RpcError extends Error {\n  /**\n   * The error code (typically an HTTP status code)\n   */\n  code: number;\n\n  /**\n   * Additional error data, if any\n   */\n  data?: unknown;\n\n  /**\n   * Creates a new RpcError.\n   * @param message The error message\n   * @param code The error code\n   * @param data Additional error data (optional)\n   */\n  constructor(message: string, code: number, data?: unknown);\n}\n</code></pre>"},{"location":"api/#server-api","title":"Server API","text":""},{"location":"api/#a2aserver","title":"A2AServer","text":"<p>The core server class for hosting A2A-compliant agents.</p> <pre><code>class A2AServer {\n  /**\n   * Creates a new A2AServer instance.\n   * @param params Configuration parameters\n   */\n  constructor(params: A2AServerParams);\n\n  /**\n   * Starts the server, making it available to accept requests.\n   * @returns A Promise that resolves when the server is started\n   */\n  start(): Promise&lt;void&gt;;\n\n  /**\n   * Stops the server, closing all connections.\n   * @returns A Promise that resolves when the server is stopped\n   */\n  stop(): Promise&lt;void&gt;;\n\n  /**\n   * Gets the underlying Express application instance.\n   * Useful for advanced customization.\n   * @returns The Express application\n   */\n  getExpressApp(): Express.Application;\n}\n</code></pre>"},{"location":"api/#a2aserverparams","title":"A2AServerParams","text":"<p>Configuration interface for the A2AServer constructor.</p> <pre><code>interface A2AServerParams {\n  /**\n   * The task handler function that implements agent logic\n   */\n  taskHandler: TaskHandler;\n\n  /**\n   * The storage implementation for persisting tasks\n   */\n  taskStore: TaskStore;\n\n  /**\n   * Metadata about the agent's capabilities\n   */\n  card: AgentCard;\n\n  /**\n   * Port number to listen on (default: 3000)\n   */\n  port?: number;\n\n  /**\n   * Host address to bind to (default: '0.0.0.0')\n   */\n  host?: string;\n\n  /**\n   * Base URL path for API endpoints (default: '/a2a')\n   */\n  basePath?: string;\n\n  /**\n   * Alternative path for agent card (default: '/agent-card')\n   */\n  fallbackPath?: string;\n\n  /**\n   * Whether to register this agent with the Artinet registry\n   */\n  register?: boolean;\n\n  /**\n   * Custom JSON-RPC server factory for advanced usage\n   */\n  createJSONRPCServer?: JSONRPCServerFactory;\n\n  /**\n   * Logging verbosity level (default: LogLevel.info)\n   */\n  logLevel?: LogLevel;\n}\n</code></pre>"},{"location":"api/#task-handling-api","title":"Task Handling API","text":""},{"location":"api/#taskhandler","title":"TaskHandler","text":"<p>The core type for defining agent logic.</p> <pre><code>/**\n * An asynchronous generator function that processes tasks and yields updates.\n * @param context The context containing task information\n * @returns An AsyncGenerator that yields status and artifact updates\n */\ntype TaskHandler = (\n  context: TaskContext\n) =&gt; AsyncGenerator&lt;TaskYieldUpdate&gt;;\n</code></pre>"},{"location":"api/#taskcontext","title":"TaskContext","text":"<p>Provides task details to the TaskHandler.</p> <pre><code>interface TaskContext {\n  /**\n   * The Task being processed\n   */\n  readonly task: Task;\n\n  /**\n   * The message from the user that initiated this task\n   */\n  readonly userMessage: Message;\n\n  /**\n   * Message history for this task (if available)\n   */\n  readonly history?: Message[];\n\n  /**\n   * Task ID for this task\n   */\n  readonly taskId: string;\n\n  /**\n   * Checks if the task has been cancelled\n   * @returns true if the task is cancelled, false otherwise\n   */\n  isCancelled(): boolean;\n}\n</code></pre>"},{"location":"api/#taskyieldupdate","title":"TaskYieldUpdate","text":"<p>Union type for updates yielded by a TaskHandler.</p> <pre><code>/**\n * Represents either a status update or an artifact creation\n */\ntype TaskYieldUpdate = \n  /**\n   * Status update with optional message\n   */\n  | { state: TaskStatus[\"state\"]; message?: Message }\n\n  /**\n   * Artifact creation\n   */\n  | { name: string; mimeType: string; parts: Part[] };\n</code></pre>"},{"location":"api/#storage-api","title":"Storage API","text":""},{"location":"api/#taskstore","title":"TaskStore","text":"<p>Interface for task persistence implementations.</p> <pre><code>interface TaskStore {\n  /**\n   * Retrieves a task by its ID\n   * @param taskId The task ID\n   * @returns A Promise resolving to the task, or undefined if not found\n   */\n  getTask(taskId: string): Promise&lt;Task | undefined&gt;;\n\n  /**\n   * Creates a new task in the store\n   * @param taskId The task ID\n   * @param task The task data\n   * @returns A Promise that resolves when the task is saved\n   */\n  createTask(taskId: string, task: Task): Promise&lt;void&gt;;\n\n  /**\n   * Saves a new task or fully replaces an existing task\n   * @param task The task to save\n   * @returns A Promise that resolves when the task is saved\n   */\n  saveTask(task: Task): Promise&lt;void&gt;;\n\n  /**\n   * Updates an existing task with new data\n   * @param task The task with updated data\n   * @returns A Promise that resolves when the task is updated\n   */\n  updateTask(task: Task): Promise&lt;void&gt;;\n\n  /**\n   * Removes a task from the store\n   * @param taskId The task ID\n   * @returns A Promise that resolves when the task is deleted\n   */\n  deleteTask(taskId: string): Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"api/#inmemorytaskstore","title":"InMemoryTaskStore","text":"<p>Simple in-memory task persistence for development/testing.</p> <pre><code>class InMemoryTaskStore implements TaskStore {\n  /**\n   * Creates a new InMemoryTaskStore\n   */\n  constructor();\n\n  // Implements all TaskStore methods using in-memory storage\n  getTask(taskId: string): Promise&lt;Task | undefined&gt;;\n  createTask(taskId: string, task: Task): Promise&lt;void&gt;;\n  saveTask(task: Task): Promise&lt;void&gt;;\n  updateTask(task: Task): Promise&lt;void&gt;;\n  deleteTask(taskId: string): Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"api/#filestore","title":"FileStore","text":"<p>File-based task persistence that stores task data in the filesystem.</p> <pre><code>class FileStore implements TaskStore {\n  /**\n   * Creates a new FileStore\n   * @param dataDirectory Path to the directory for storing task files\n   */\n  constructor(dataDirectory: string);\n\n  // Implements all TaskStore methods using filesystem storage\n  getTask(taskId: string): Promise&lt;Task | undefined&gt;;\n  createTask(taskId: string, task: Task): Promise&lt;void&gt;;\n  saveTask(task: Task): Promise&lt;void&gt;;\n  updateTask(task: Task): Promise&lt;void&gt;;\n  deleteTask(taskId: string): Promise&lt;void&gt;;\n}\n</code></pre>"},{"location":"api/#logging-api","title":"Logging API","text":""},{"location":"api/#logger","title":"logger","text":"<p>Built-in structured logger based on Pino.</p> <pre><code>/**\n * The main logger instance for the SDK\n */\nconst logger: Logger;\n</code></pre>"},{"location":"api/#configurelogger","title":"configureLogger","text":"<p>Function to configure the logging level and other options.</p> <pre><code>/**\n * Configures the global logger's settings\n * @param options Configuration options\n */\nfunction configureLogger(options: { level?: LogLevel }): void;\n</code></pre>"},{"location":"api/#log-helper-functions","title":"Log Helper Functions","text":"<pre><code>/**\n * Logs a message at DEBUG level with context\n * @param component Name of the component generating the log\n * @param context Additional context objects\n * @param message The log message\n * @param error Optional error object\n */\nfunction logDebug(component: string, context: object, message: string, error?: Error): void;\n\n/**\n * Logs a message at INFO level with context\n * @param component Name of the component generating the log\n * @param context Additional context objects\n * @param message The log message\n * @param error Optional error object\n */\nfunction logInfo(component: string, context: object, message: string, error?: Error): void;\n\n/**\n * Logs a message at WARN level with context\n * @param component Name of the component generating the log\n * @param context Additional context objects\n * @param message The log message\n * @param error Optional error object\n */\nfunction logWarn(component: string, context: object, message: string, error?: Error): void;\n\n/**\n * Logs a message at ERROR level with context\n * @param component Name of the component generating the log\n * @param context Additional context objects\n * @param message The log message\n * @param error Optional error object\n */\nfunction logError(component: string, context: object, message: string, error?: Error): void;\n</code></pre>"},{"location":"api/#loglevel","title":"LogLevel","text":"<p>Enum defining logging levels.</p> <pre><code>enum LogLevel {\n  ERROR = \"error\",\n  WARN = \"warn\",\n  INFO = \"info\",\n  DEBUG = \"debug\",\n  TRACE = \"trace\"\n}\n</code></pre>"},{"location":"api/#advanced-customization-api","title":"Advanced Customization API","text":""},{"location":"api/#jsonrpcserverfactory","title":"JSONRPCServerFactory","text":"<p>Function signature for providing custom JSON-RPC server creation logic.</p> <pre><code>/**\n * Factory function for creating a custom JSON-RPC server\n * @param params Parameters with dependencies needed for server creation\n * @returns A configured JSON-RPC server\n */\ntype JSONRPCServerFactory = (\n  params: CreateJSONRPCServerParams\n) =&gt; JSONRPCServerType;\n</code></pre>"},{"location":"api/#createjsonrpcserverparams","title":"CreateJSONRPCServerParams","text":"<p>Object containing dependencies provided to a JSONRPCServerFactory function.</p> <pre><code>interface CreateJSONRPCServerParams {\n  /**\n   * The task handler function\n   */\n  taskHandler: TaskHandler;\n\n  /**\n   * The storage implementation\n   */\n  taskStore: TaskStore;\n\n  /**\n   * The agent's metadata\n   */\n  agentCard: AgentCard;\n\n  /**\n   * Set of active task cancellations\n   */\n  activeCancellations: Set&lt;string&gt;;\n\n  /**\n   * Function to create a TaskContext for a task\n   */\n  createTaskContext: (task: Task) =&gt; TaskContext;\n\n  /**\n   * Function to close all streams for a task\n   */\n  closeStreamsForTask: (taskId: string) =&gt; void;\n}\n</code></pre>"},{"location":"api/#method-type-definitions","title":"Method Type Definitions","text":"<pre><code>/**\n * Type definition for the tasks/send method handler\n */\ntype SendTaskMethod = (\n  deps: CreateJSONRPCServerParams,\n  params: SendTaskRequest[\"params\"],\n  callback: JSONRPCCallback\n) =&gt; void;\n\n/**\n * Type definition for the tasks/get method handler\n */\ntype GetTaskMethod = (\n  deps: CreateJSONRPCServerParams,\n  params: GetTaskRequest[\"params\"],\n  callback: JSONRPCCallback\n) =&gt; void;\n\n/**\n * Type definition for the tasks/cancel method handler\n */\ntype CancelTaskMethod = (\n  deps: CreateJSONRPCServerParams,\n  params: CancelTaskRequest[\"params\"],\n  callback: JSONRPCCallback\n) =&gt; void;\n</code></pre>"},{"location":"api/#createjsonrpcmethod","title":"createJSONRPCMethod","text":"<p>Helper function for creating JSON-RPC method handlers.</p> <pre><code>/**\n * Creates a JSON-RPC method with dependency injection and error handling\n * @param deps The dependency parameters\n * @param methodImpl The method implementation\n * @param methodName The name of the method\n * @returns A configured JSON-RPC method handler\n */\nfunction createJSONRPCMethod&lt;T, R&gt;(\n  deps: CreateJSONRPCServerParams,\n  methodImpl: (deps: CreateJSONRPCServerParams, params: T, callback: JSONRPCCallback) =&gt; void,\n  methodName: string\n): (params: T, callback: JSONRPCCallback) =&gt; void;\n</code></pre>"},{"location":"api/#quick-agent-api","title":"Quick Agent API","text":""},{"location":"api/#bundle","title":"bundle","text":"<p>Bundles agent code for deployment.</p> <pre><code>/**\n * Bundles an agent's code and dependencies into a single file\n * @param fileUrl URL to the agent's main file\n * @returns A Promise resolving to the bundled code as a string\n */\nfunction bundle(fileUrl: URL): Promise&lt;string&gt;;\n</code></pre>"},{"location":"api/#taskhandlerproxy","title":"taskHandlerProxy","text":"<p>Simplifies agent implementation for quick agents.</p> <pre><code>/**\n * Wraps agent logic for use in managed environments\n * @param agentLogic The agent's main function\n * @returns A Promise that resolves when the agent completes\n */\nfunction taskHandlerProxy(\n  agentLogic: (context: TaskContext) =&gt; AsyncGenerator&lt;TaskYieldUpdate&gt;\n): Promise&lt;void&gt;;\n</code></pre>"},{"location":"api/#fetchresponseproxy","title":"fetchResponseProxy","text":"<p>Enables communication between quick agents.</p> <pre><code>/**\n * Fetches a response from another agent in the Artinet ecosystem\n * @param targetAgent Name of the agent to call\n * @param message Message to send to the target agent\n * @returns A Promise resolving to the agent's response\n */\nfunction fetchResponseProxy(\n  targetAgent: string,\n  message: Message\n): Promise&lt;{ message: Message }&gt;;\n</code></pre>"},{"location":"api/#testdeployment","title":"testDeployment","text":"<p>Tests a deployment in a temporary sandbox environment.</p> <pre><code>/**\n * Tests an agent deployment in a sandboxed environment\n * @param params Deployment parameters including the agent code\n * @param requests Test requests to send to the deployed agent\n * @returns An AsyncGenerator yielding deployment responses\n */\nfunction testDeployment(\n  params: ServerDeploymentRequestParams,\n  requests: SendTaskRequest[]\n): AsyncGenerator&lt;ServerDeploymentResponse&gt;;\n</code></pre>"},{"location":"api/#deployment-types","title":"Deployment Types","text":"<pre><code>/**\n * Parameters for agent deployment\n */\ninterface ServerDeploymentRequestParams {\n  /**\n   * The bundled agent code\n   */\n  code: string;\n\n  /**\n   * Optional metadata about the agent\n   */\n  metadata?: {\n    name?: string;\n    version?: string;\n    description?: string;\n  };\n}\n\n/**\n * Response from a deployment test\n */\ninterface ServerDeploymentResponse {\n  /**\n   * The task ID\n   */\n  id: string;\n\n  /**\n   * The response message from the agent\n   */\n  message: Message;\n\n  /**\n   * The task status\n   */\n  status: TaskStatus;\n\n  /**\n   * Any artifacts generated by the agent\n   */\n  artifacts?: Artifact[];\n}\n</code></pre>"},{"location":"api/#core-types","title":"Core Types","text":"<p>The SDK includes comprehensive TypeScript definitions for all A2A Protocol types. Here are the most important ones:</p>"},{"location":"api/#agentcard","title":"AgentCard","text":"<p>Describes the agent's capabilities, metadata, skills, and endpoint URL.</p> <pre><code>interface AgentCard {\n  /**\n   * The name of the agent\n   */\n  name: string;\n\n  /**\n   * The URL where the agent can be reached\n   */\n  url: string;\n\n  /**\n   * The agent's version\n   */\n  version?: string;\n\n  /**\n   * Description of the agent's purpose\n   */\n  description?: string;\n\n  /**\n   * The agent's capabilities\n   */\n  capabilities?: {\n    /**\n     * Whether the agent supports streaming\n     */\n    streaming?: boolean;\n\n    /**\n     * Whether the agent supports artifacts\n     */\n    artifacts?: boolean;\n  };\n\n  /**\n   * Skills the agent provides\n   */\n  skills?: Array&lt;{\n    /**\n     * Unique identifier for the skill\n     */\n    id: string;\n\n    /**\n     * Human-readable name for the skill\n     */\n    name: string;\n\n    /**\n     * Description of what the skill does\n     */\n    description?: string;\n  }&gt;;\n}\n</code></pre>"},{"location":"api/#task","title":"Task","text":"<p>Represents the state and metadata of an A2A task.</p> <pre><code>interface Task {\n  /**\n   * Unique identifier for the task\n   */\n  id: string;\n\n  /**\n   * Current status of the task\n   */\n  status: TaskStatus;\n\n  /**\n   * The message that initiated this task\n   */\n  message: Message;\n\n  /**\n   * Message history for this task\n   */\n  history?: Message[];\n\n  /**\n   * Custom metadata associated with the task\n   */\n  metadata?: Record&lt;string, unknown&gt;;\n\n  /**\n   * Artifacts generated during task execution\n   */\n  artifacts?: Artifact[];\n\n  /**\n   * Optional session identifier\n   */\n  sessionId?: string;\n}\n</code></pre>"},{"location":"api/#message","title":"Message","text":"<p>Represents a message in the A2A protocol.</p> <pre><code>interface Message {\n  /**\n   * Who sent the message\n   */\n  role: \"user\" | \"agent\";\n\n  /**\n   * Content parts of the message\n   */\n  parts: Part[];\n}\n</code></pre>"},{"location":"api/#part","title":"Part","text":"<p>Represents a part of a message in the A2A protocol.</p> <pre><code>interface Part {\n  /**\n   * The type of content in this part\n   */\n  type: \"text\" | \"image\" | \"video\" | \"audio\" | \"file\";\n\n  /**\n   * Text content (for type: \"text\")\n   */\n  text?: string;\n\n  /**\n   * A link to an external resource (for media types)\n   */\n  uri?: string;\n\n  /**\n   * Metadata about the part\n   */\n  [key: string]: unknown;\n}\n</code></pre>"},{"location":"api/#artifact","title":"Artifact","text":"<p>Represents an artifact generated during a task.</p> <pre><code>interface Artifact {\n  /**\n   * Name of the artifact\n   */\n  name: string;\n\n  /**\n   * MIME type of the artifact\n   */\n  mimeType: string;\n\n  /**\n   * Content parts of the artifact\n   */\n  parts: Part[];\n}\n</code></pre>"},{"location":"api/#taskstatus","title":"TaskStatus","text":"<p>Represents the status of an A2A task.</p> <pre><code>interface TaskStatus {\n  /**\n   * Current state of the task\n   */\n  state: \"active\" | \"working\" | \"completed\" | \"failed\" | \"cancelled\";\n\n  /**\n   * Optional message describing the status\n   */\n  statusMessage?: string;\n}\n</code></pre>"},{"location":"api/#stream-event-types","title":"Stream Event Types","text":"<pre><code>/**\n * Event emitted when a task's status changes\n */\ninterface TaskStatusUpdateEvent {\n  /**\n   * The new status\n   */\n  status: TaskStatus;\n\n  /**\n   * Optional message from the agent\n   */\n  message?: Message;\n}\n\n/**\n * Event emitted when a task generates an artifact\n */\ninterface TaskArtifactUpdateEvent {\n  /**\n   * The generated artifact\n   */\n  artifact: Artifact;\n}\n</code></pre>"},{"location":"contributing/code-documentation/","title":"Code Documentation Guidelines","text":"<p>When contributing to the Artinet SDK, please use the following Doxygen-style comment patterns:</p>"},{"location":"contributing/code-documentation/#class-documentation","title":"Class Documentation","text":"<pre><code>/**\n * @brief Brief description of the class\n * \n * Detailed description of what the class does and how to use it.\n */\nclass ExampleClass {\n  // Class implementation\n}\n</code></pre>"},{"location":"contributing/code-documentation/#method-documentation","title":"Method Documentation","text":"<pre><code>/**\n * @brief Brief description of the method\n * \n * Detailed description of what the method does.\n * \n * @param paramName Description of the parameter\n * @return Description of what the method returns\n */\npublic methodName(paramName: string): ReturnType {\n  // Method implementation\n}\n</code></pre>"},{"location":"sdk/core/","title":"Core SDK Components","text":"<p>This page provides a brief overview of the main classes, types, and utilities available in the Artinet SDK. These are the fundamental building blocks you'll use to create and interact with A2A-compliant agents.</p>"},{"location":"sdk/core/#a2aserver","title":"A2AServer","text":"<ul> <li>The primary class for instantiating and running an A2A agent server. It manages the agent's lifecycle, handles incoming requests, executes tasks via a <code>TaskHandler</code>, and uses a <code>TaskStore</code> for persistence. Built on Express.js, it automatically handles JSON-RPC complexity, routing, A2A protocol compliance, and Server-Sent Events (SSE) streaming.</li> </ul>"},{"location":"sdk/core/#a2aclient","title":"A2AClient","text":"<ul> <li>The client class used to connect to an <code>A2AServer</code> instance. It allows you to send tasks (using <code>sendTask</code> for single responses or <code>sendTaskSubscribe</code> for streaming updates) and manage communication headers. Features refined error handling via <code>RpcError</code>, flexible header management for authentication, and clear separation of concerns.</li> </ul>"},{"location":"sdk/core/#taskhandler-type","title":"TaskHandler (Type)","text":"<ul> <li>An asynchronous generator function (<code>async function*</code>) type that defines the core logic of an agent. It receives a <code>TaskContext</code> and yields <code>TaskYieldUpdate</code> objects to report progress and results. This is where you implement your agent's main functionality, processing user messages and generating responses.</li> </ul>"},{"location":"sdk/core/#taskcontext-interfacetype","title":"TaskContext (Interface/Type)","text":"<ul> <li>An object passed as an argument to the <code>TaskHandler</code>. It provides task details such as <code>userMessage</code>, <code>taskId</code>, and methods like <code>isCancelled()</code> to check if a task should be aborted. Use this to access user inputs and manage the agent's execution flow.</li> </ul>"},{"location":"sdk/core/#message-interfacetype","title":"Message (Interface/Type)","text":"<ul> <li>Defines the structure for messages exchanged between users and agents, or between agents. It includes a <code>role</code> (e.g., 'user', 'agent') and <code>parts</code> containing the content (e.g., text, images). This structure follows the A2A protocol specifications and ensures standardized communication.</li> </ul>"},{"location":"sdk/core/#inmemorytaskstore","title":"InMemoryTaskStore","text":"<ul> <li>A simple implementation of the <code>TaskStore</code> interface that stores task state and history in memory. Suitable for development, testing, or agents that do not require persistent task data across restarts. Ideal for rapid prototyping and experimentation.</li> </ul>"},{"location":"sdk/core/#filestore","title":"FileStore","text":"<ul> <li>An implementation of the <code>TaskStore</code> interface that persists task state and history to the local filesystem in a specified directory. Useful for agents that need to retain task data between server restarts. Ensures your agent can maintain conversation context and task state.</li> </ul>"},{"location":"sdk/core/#taskstatusupdateevent-interfacetype","title":"TaskStatusUpdateEvent (Interface/Type)","text":"<ul> <li>An event object yielded by a <code>TaskHandler</code> during streaming operations. It includes the current <code>state</code> of the task (e.g., 'working', 'completed', 'error') and can include an updated <code>message</code> from the agent. This allows real-time progress updates to be sent to clients.</li> </ul>"},{"location":"sdk/core/#taskartifactupdateevent-interfacetype","title":"TaskArtifactUpdateEvent (Interface/Type)","text":"<ul> <li>An event object yielded by a <code>TaskHandler</code> when an agent produces an artifact (like a file) during a task. It includes details about the <code>artifact</code> such as its name, mimeType, and content. This enables agents to share documents, files, or other complex outputs during task execution.</li> </ul>"},{"location":"sdk/core/#logger-configurelogger-logdebug-utilities","title":"logger / configureLogger / logDebug (Utilities)","text":"<ul> <li>A set of logging utilities provided by the SDK. <code>logger</code> is the main logger instance based on the Pino library. <code>configureLogger</code> allows customization of log levels and output. <code>logDebug</code> and similar functions are helpers for common log levels, making it easier to add structured logging to your agent.</li> </ul>"},{"location":"sdk/core/#jsonrpcserverfactory-type","title":"JSONRPCServerFactory (Type)","text":"<ul> <li>A function signature for providing custom JSON-RPC server creation logic to the A2AServer for advanced customization. This allows you to implement custom methods, integrate with existing Express apps, or fine-tune the API behavior to meet specific requirements.</li> </ul>"},{"location":"sdk/core/#agentcard-interfacetype","title":"AgentCard (Interface/Type)","text":"<ul> <li>Describes an agent's capabilities, metadata, skills, and endpoint URL. This information is exposed at the standard <code>/.well-known/agent.json</code> endpoint (and optional fallback paths) to enable discovery and interoperability with other A2A-compliant systems.</li> </ul>"},{"location":"sdk/examples/","title":"SDK Examples","text":"<p>This page provides practical examples of using the Artinet SDK to create and interact with A2A-compliant agents. Each example demonstrates a key aspect of the SDK's functionality.</p>"},{"location":"sdk/examples/#basic-agent-server","title":"Basic Agent Server","text":"<p>This example shows how to create a simple echo agent that responds with the text it receives.</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Define the logic for your agent\nconst echoAgentLogic: TaskHandler = async function* (context: TaskContext) {\n  // Extract text from the user's message\n  const userInput =\n    context.userMessage.parts[0]?.type === \"text\"\n      ? context.userMessage.parts[0].text\n      : \"No text provided\";\n\n  // 1. Yield a 'working' state to indicate the task has started\n  yield { state: \"working\" };\n\n  // 2. Yield a 'completed' state with the agent's response\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: `Echo: ${userInput}` }],\n    },\n  };\n};\n\n// Configure and create the A2A Server instance\nconst server = new A2AServer({\n  taskHandler: echoAgentLogic,          // The logic our agent will use\n  taskStore: new InMemoryTaskStore(),   // Stores task information (in memory for this example)\n  port: 4000,                           // The port your agent server will run on\n  basePath: \"/a2a\",                     // The base API path for your agent\n\n  // The 'card' provides metadata about your agent so others can discover it\n  card: {\n    name: \"EchoAgent\",\n    url: \"http://localhost:4000/a2a\", // How to reach this agent\n    version: \"0.1.0\",\n    capabilities: { streaming: true }, // Indicates this agent supports streaming updates\n    skills: [{ id: \"echo\", name: \"Echo Skill\" }], // Describes what the agent can do\n  },\n});\n\n// Start the server\nasync function main() {\n  try {\n    await server.start(); // Start listening for requests\n    console.log(\"EchoAgent server running at http://localhost:4000/a2a\");\n  } catch (error) {\n    console.error(\"Failed to start server:\", error);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"sdk/examples/#basic-agent-client","title":"Basic Agent Client","text":"<p>This example demonstrates how to create a client that sends a message to an agent and receives a single response.</p> <pre><code>import { A2AClient, Message } from \"@artinet/sdk\";\n\nasync function talkToAgent() {\n  // Create a client pointing to your running agent server\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  // Define the message you want to send to the agent\n  const userMessage: Message = {\n    role: \"user\",\n    parts: [{ type: \"text\", text: \"Hello Agent!\" }],\n  };\n\n  try {\n    console.log(\"Sending message to agent...\");\n\n    // Send the task and wait for the final response\n    const taskResponse = await client.sendTask({\n      id: \"my-echo-task-01\", // A unique ID for this task\n      message: userMessage,\n    });\n\n    console.log(\"Agent responded successfully!\");\n\n    // The final message from the agent is in taskResponse.message\n    if (taskResponse.message &amp;&amp; taskResponse.message.parts[0]?.type === \"text\") {\n      console.log(\"Agent's final reply:\", taskResponse.message.parts[0].text);\n    } else {\n      console.log(\"Agent's final response structure:\", taskResponse);\n    }\n\n  } catch (error) {\n    console.error(\"Error interacting with agent:\", error);\n  }\n}\n\ntalkToAgent();\n</code></pre>"},{"location":"sdk/examples/#streaming-response-client","title":"Streaming Response Client","text":"<p>This example shows how to use the streaming API to receive real-time updates from an agent.</p> <pre><code>import { A2AClient, TaskStatusUpdateEvent, TaskArtifactUpdateEvent } from \"@artinet/sdk\";\n\nasync function streamFromAgent() {\n  // Create a client pointing to your running agent server\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  // Define the message you want to send to the agent\n  const userMessage = {\n    role: \"user\",\n    parts: [{ type: \"text\", text: \"Generate a detailed report\" }],\n  };\n\n  try {\n    console.log(\"Sending task with streaming...\");\n\n    // Use sendTaskSubscribe to get a stream of updates\n    const stream = client.sendTaskSubscribe({\n      id: \"streaming-task-01\",\n      message: userMessage,\n    });\n\n    // Process updates as they arrive\n    for await (const update of stream) {\n      if (\"status\" in update) {\n        const statusUpdate = update as TaskStatusUpdateEvent;\n        console.log(`Task status: ${statusUpdate.status.state}`);\n\n        // If there's a message with this status update, display it\n        if (statusUpdate.message?.parts[0]?.type === \"text\") {\n          console.log(`Agent says: ${statusUpdate.message.parts[0].text}`);\n        }\n      } else if (\"artifact\" in update) {\n        const artifactUpdate = update as TaskArtifactUpdateEvent;\n        console.log(`Received artifact: ${artifactUpdate.artifact.name}`);\n        // Process the artifact content\n        const artifactContent = artifactUpdate.artifact.parts[0]?.text || \"[No content]\";\n        console.log(`Artifact content: ${artifactContent.substring(0, 100)}...`);\n      }\n    }\n\n    console.log(\"Stream completed\");\n\n  } catch (error) {\n    console.error(\"Error with streaming task:\", error);\n  }\n}\n\nstreamFromAgent();\n</code></pre>"},{"location":"sdk/examples/#long-running-agent-logic-with-progress-updates","title":"Long-Running Agent Logic with Progress Updates","text":"<p>This example demonstrates how to create an agent that performs a long-running task with progress updates.</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Simulates a time-consuming process with progress updates\nconst longRunningAgent: TaskHandler = async function* (context: TaskContext) {\n  // Extract request from user message\n  const userInput =\n    context.userMessage.parts[0]?.type === \"text\"\n      ? context.userMessage.parts[0].text\n      : \"No specific request\";\n\n  // Initial update - we're starting the work\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Starting the requested task...\" }],\n    },\n  };\n\n  // Simulate first stage of work\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  // Check if task was cancelled during this time\n  if (context.isCancelled()) {\n    yield {\n      state: \"cancelled\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task was cancelled.\" }],\n      },\n    };\n    return;\n  }\n\n  // Progress update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"25% complete - analyzing data...\" }],\n    },\n  };\n\n  // Simulate second stage of work\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  if (context.isCancelled()) {\n    yield {\n      state: \"cancelled\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task was cancelled.\" }],\n      },\n    };\n    return;\n  }\n\n  // Another progress update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"50% complete - generating results...\" }],\n    },\n  };\n\n  // Simulate third stage of work\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  if (context.isCancelled()) {\n    yield {\n      state: \"cancelled\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task was cancelled.\" }],\n      },\n    };\n    return;\n  }\n\n  // Generate an artifact (like a report or document)\n  yield {\n    name: \"results.txt\",\n    mimeType: \"text/plain\",\n    parts: [{ \n      type: \"text\", \n      text: `Analysis results for: \"${userInput}\"\\n\\n1. Finding one\\n2. Finding two\\n3. Finding three` \n    }],\n  };\n\n  // Final progress update\n  yield {\n    state: \"working\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"75% complete - finalizing...\" }],\n    },\n  };\n\n  // Simulate final stage of work\n  await new Promise(resolve =&gt; setTimeout(resolve, 2000));\n\n  if (context.isCancelled()) {\n    yield {\n      state: \"cancelled\",\n      message: {\n        role: \"agent\",\n        parts: [{ type: \"text\", text: \"Task was cancelled.\" }],\n      },\n    };\n    return;\n  }\n\n  // Complete the task with final results\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ \n        type: \"text\", \n        text: \"Task completed successfully. Results have been generated and are available in the attached artifact.\" \n      }],\n    },\n  };\n};\n\n// Server setup\nconst server = new A2AServer({\n  taskHandler: longRunningAgent,\n  taskStore: new InMemoryTaskStore(),\n  port: 4000,\n  basePath: \"/a2a\",\n  card: {\n    name: \"LongRunningAgent\",\n    url: \"http://localhost:4000/a2a\",\n    version: \"0.1.0\",\n    capabilities: { streaming: true },\n    skills: [{ id: \"analysis\", name: \"Data Analysis\" }],\n  },\n});\n\nserver.start().then(() =&gt; {\n  console.log(\"LongRunningAgent server running at http://localhost:4000/a2a\");\n}).catch(err =&gt; {\n  console.error(\"Failed to start server:\", err);\n});\n</code></pre>"},{"location":"sdk/examples/#using-persistent-storage-with-filestore","title":"Using Persistent Storage with FileStore","text":"<p>This example shows how to configure an agent with file-based storage for persistence across restarts.</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  FileStore,\n} from \"@artinet/sdk\";\nimport path from \"path\";\nimport fs from \"fs\";\n\n// Define your agent logic\nconst persistentAgent: TaskHandler = async function* (context: TaskContext) {\n  // Basic echo agent logic\n  const userInput =\n    context.userMessage.parts[0]?.type === \"text\"\n      ? context.userMessage.parts[0].text\n      : \"No text provided\";\n\n  yield { state: \"working\" };\n\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: `Received: ${userInput}` }],\n    },\n  };\n};\n\n// Set up the data directory for the FileStore\nconst dataDir = path.join(process.cwd(), \"agent-data\");\nif (!fs.existsSync(dataDir)) {\n  fs.mkdirSync(dataDir, { recursive: true });\n}\n\n// Create a FileStore instance\nconst fileStore = new FileStore(dataDir);\n\n// Configure and create the server with FileStore\nconst server = new A2AServer({\n  taskHandler: persistentAgent,\n  taskStore: fileStore,  // Using FileStore instead of InMemoryTaskStore\n  port: 4000,\n  basePath: \"/a2a\",\n  card: {\n    name: \"PersistentAgent\",\n    url: \"http://localhost:4000/a2a\",\n    version: \"0.1.0\",\n    capabilities: { streaming: true },\n    skills: [{ id: \"persistence\", name: \"Persistent Conversations\" }],\n  },\n});\n\n// Start the server\nserver.start().then(() =&gt; {\n  console.log(\"PersistentAgent server running at http://localhost:4000/a2a\");\n  console.log(`Task data will be stored in: ${dataDir}`);\n}).catch(err =&gt; {\n  console.error(\"Failed to start server:\", err);\n});\n</code></pre>"},{"location":"sdk/examples/#authenticated-api-calls-with-headers","title":"Authenticated API Calls with Headers","text":"<p>This example demonstrates how to add authentication headers to API calls when using the A2AClient.</p> <pre><code>import { A2AClient } from \"@artinet/sdk\";\n\nasync function authenticatedApiCall() {\n  // Create a client\n  const client = new A2AClient(\"https://api.example.com/a2a\");\n\n  // Add an authentication header\n  client.addHeader(\"Authorization\", \"Bearer YOUR_API_TOKEN\");\n\n  // You can also add multiple headers at once\n  client.setHeaders({\n    \"X-API-Key\": \"your-api-key\",\n    \"User-Agent\": \"Artinet SDK Example\",\n    \"Accept\": \"application/json\"\n  });\n\n  // Now make the API call with authentication\n  try {\n    const taskResponse = await client.sendTask({\n      id: \"auth-task-01\",\n      message: {\n        role: \"user\",\n        parts: [{ type: \"text\", text: \"Secure API request example\" }]\n      }\n    });\n\n    console.log(\"Authenticated API call succeeded:\", taskResponse);\n\n  } catch (error) {\n    // Handle different error types\n    if (error.code === 401) {\n      console.error(\"Authentication failed. Check your API token.\");\n    } else if (error.code === 403) {\n      console.error(\"Not authorized to perform this action.\");\n    } else {\n      console.error(\"API call failed:\", error);\n    }\n  }\n}\n\nauthenticatedApiCall();\n</code></pre>"},{"location":"sdk/examples/#structured-logging","title":"Structured Logging","text":"<p>This example shows how to use the built-in logging utilities for better debugging and monitoring.</p> <pre><code>import { \n  A2AServer, \n  logger, \n  configureLogger, \n  LogLevel,\n  logDebug,\n  logInfo,\n  logWarn,\n  logError\n} from \"@artinet/sdk\";\n\n// Configure logging level\nconfigureLogger({ level: LogLevel.debug });\n\n// Standard logger usage\nlogger.info(\"Application starting\");\nlogger.debug({ module: \"startup\" }, \"Initializing components\");\n\n// Use the helper functions with context\nlogInfo(\"UserService\", { userId: \"user-123\" }, \"User logged in\");\nlogDebug(\"TaskProcessor\", { taskId: \"task-456\" }, \"Processing started\");\nlogWarn(\"ApiClient\", { endpoint: \"/api/data\" }, \"Rate limit approaching\");\nlogError(\"Database\", { operation: \"insert\" }, \"Connection failed\", new Error(\"DB timeout\"));\n\n// Create a child logger with bound context\nconst taskLogger = logger.child({ taskId: \"abc-789\", sessionId: \"session-321\" });\ntaskLogger.info(\"Task received\");\ntaskLogger.debug(\"Processing step 1\");\ntaskLogger.info(\"Task completed\");\n\n// Example of integrating logging into an agent\nconst loggingAgent = async function* (context) {\n  const taskId = context.taskId;\n  const taskLogger = logger.child({ taskId });\n\n  taskLogger.info(\"Received new task\");\n  yield { state: \"working\" };\n\n  taskLogger.debug(\"Processing user message\");\n  // ... processing logic ...\n\n  if (someErrorCondition) {\n    taskLogger.error(\"Failed to process task\", new Error(\"Processing error\"));\n    yield { \n      state: \"error\",\n      message: { \n        role: \"agent\", \n        parts: [{ type: \"text\", text: \"Sorry, an error occurred\" }]\n      }\n    };\n    return;\n  }\n\n  taskLogger.info(\"Task completed successfully\");\n  yield { \n    state: \"completed\",\n    message: { \n      role: \"agent\", \n      parts: [{ type: \"text\", text: \"Task complete!\" }]\n    }\n  };\n};\n</code></pre>"},{"location":"sdk/examples/#advanced-custom-jsonrpcserverfactory","title":"Advanced: Custom JSONRPCServerFactory","text":"<p>This example shows how to create a custom JSON-RPC server implementation for advanced use cases.</p> <pre><code>import {\n  A2AServer,\n  JSONRPCServerFactory,\n  CreateJSONRPCServerParams,\n  SendTaskMethod,\n  defaultGetTaskMethod,\n  defaultCancelTaskMethod,\n  defaultSetTaskPushNotificationMethod,\n  defaultGetTaskPushNotificationMethod,\n  createJSONRPCMethod,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\nimport { JSONRPCServer } from \"jayson/promise\";\n\n// Define our custom task/send method\nconst myCustomSendMethod: SendTaskMethod = (\n  deps,\n  requestParams,\n  callback\n) =&gt; {\n  const { taskStore, taskHandler, createTaskContext } = deps;\n  const taskId = requestParams.id;\n  const { message, sessionId } = requestParams;\n\n  console.log(`Custom handler processing task ${taskId}`);\n\n  // Log incoming messages\n  console.log(`Message from user: ${message.parts[0]?.text || \"No text\"}`);\n\n  // Here you could add custom validation, preprocessing, or business logic\n  // before delegating to the normal task handling flow\n\n  // For this example, we'll just add a custom metadata field\n  const enhancedParams = {\n    ...requestParams,\n    metadata: {\n      ...(requestParams.metadata || {}),\n      customField: \"Added by custom handler\",\n      timestamp: new Date().toISOString()\n    }\n  };\n\n  // Create and process the task using the standard pattern\n  // (simplified - a real implementation would be more robust)\n  taskStore.createTask(taskId, {\n    id: taskId,\n    message: enhancedParams.message,\n    status: { state: \"submitted\" },\n    sessionId: enhancedParams.sessionId,\n    metadata: enhancedParams.metadata\n  });\n\n  // Start processing the task\n  const task = taskStore.getTask(taskId);\n  const context = createTaskContext(task);\n\n  // Execute the TaskHandler (simplified)\n  const taskIterator = taskHandler(context);\n\n  // Process the first yield to update status\n  taskIterator.next().then(result =&gt; {\n    if (result.value) {\n      // Update the task with the first yield result\n      taskStore.updateTask(taskId, { status: { state: result.value.state } });\n\n      // Return the updated task\n      callback(null, taskStore.getTask(taskId));\n    }\n  }).catch(err =&gt; {\n    callback(err);\n  });\n};\n\n// Create the custom factory\nconst myCustomRPCServer: JSONRPCServerFactory = (\n  params: CreateJSONRPCServerParams\n) =&gt; {\n  // Create methods using the dependency injection helper\n  const taskSendMethod = createJSONRPCMethod(params, myCustomSendMethod, \"tasks/send\");\n  const taskGetMethod = createJSONRPCMethod(params, defaultGetTaskMethod, \"tasks/get\");\n  const taskCancelMethod = createJSONRPCMethod(params, defaultCancelTaskMethod, \"tasks/cancel\");\n  const taskPushNotificationSetMethod = createJSONRPCMethod(\n    params, \n    defaultSetTaskPushNotificationMethod, \n    \"tasks/pushNotification/set\"\n  );\n  const taskPushNotificationGetMethod = createJSONRPCMethod(\n    params, \n    defaultGetTaskPushNotificationMethod, \n    \"tasks/pushNotification/get\"\n  );\n\n  // Create the JSON-RPC server with our methods\n  const rpcServer = new JSONRPCServer({\n    \"tasks/send\": taskSendMethod,\n    \"tasks/get\": taskGetMethod,\n    \"tasks/cancel\": taskCancelMethod,\n    \"tasks/pushNotification/set\": taskPushNotificationSetMethod,\n    \"tasks/pushNotification/get\": taskPushNotificationGetMethod,\n  });\n\n  return rpcServer;\n};\n\n// Define a simple agent\nconst simpleAgent: TaskHandler = async function* (context) {\n  yield { state: \"working\" };\n  yield {\n    state: \"completed\",\n    message: {\n      role: \"agent\",\n      parts: [{ type: \"text\", text: \"Processed by custom RPC server!\" }]\n    }\n  };\n};\n\n// Create the server with the custom factory\nconst server = new A2AServer({\n  taskHandler: simpleAgent,\n  taskStore: new InMemoryTaskStore(),\n  port: 4000,\n  basePath: \"/a2a\",\n  card: {\n    name: \"CustomRPCAgent\",\n    url: \"http://localhost:4000/a2a\",\n    version: \"0.1.0\",\n    capabilities: { streaming: true },\n    skills: [{ id: \"custom\", name: \"Custom RPC Handling\" }],\n  },\n  createJSONRPCServer: myCustomRPCServer\n});\n\nserver.start().then(() =&gt; {\n  console.log(\"Server with custom RPC handler running at http://localhost:4000/a2a\");\n}).catch(err =&gt; {\n  console.error(\"Failed to start server:\", err);\n});\n</code></pre>"},{"location":"sdk/examples/#error-handling-in-taskhandlers","title":"Error Handling in TaskHandlers","text":"<p>This example demonstrates how to implement comprehensive error handling in your agent logic.</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n  logger\n} from \"@artinet/sdk\";\n\n// Agent with robust error handling\nconst robustAgent: TaskHandler = async function* (context: TaskContext) {\n  try {\n    // Initial state update\n    yield { state: \"working\" };\n\n    // Extract user input\n    const userInput = \n      context.userMessage.parts[0]?.type === \"text\"\n        ? context.userMessage.parts[0].text\n        : \"\";\n\n    // Validate input\n    if (!userInput) {\n      // Handle empty input gracefully\n      yield {\n        state: \"completed\",\n        message: {\n          role: \"agent\",\n          parts: [{ type: \"text\", text: \"I didn't receive any text to process. Please provide some text.\" }]\n        }\n      };\n      return;\n    }\n\n    // Simulate potential error condition\n    if (userInput.toLowerCase().includes(\"error\")) {\n      throw new Error(\"Simulated error for demonstration\");\n    }\n\n    // Simulate async operation that might fail\n    try {\n      const result = await someAsyncOperation(userInput);\n\n      // Check for cancellation after async operation\n      if (context.isCancelled()) {\n        yield {\n          state: \"cancelled\",\n          message: {\n            role: \"agent\",\n            parts: [{ type: \"text\", text: \"Operation was cancelled by the user.\" }]\n          }\n        };\n        return;\n      }\n\n      // Success path\n      yield {\n        state: \"completed\",\n        message: {\n          role: \"agent\",\n          parts: [{ type: \"text\", text: `Successfully processed: ${result}` }]\n        }\n      };\n    } catch (operationError) {\n      // Handle operation-specific error\n      logger.error({ taskId: context.taskId, error: operationError }, \"Operation failed\");\n\n      yield {\n        state: \"error\",\n        message: {\n          role: \"agent\",\n          parts: [{ \n            type: \"text\", \n            text: `Sorry, I couldn't process your request due to an error with the operation: ${operationError.message}` \n          }]\n        }\n      };\n    }\n  } catch (error) {\n    // Handle any unexpected errors\n    logger.error({ taskId: context.taskId, error }, \"Unexpected error in agent\");\n\n    yield {\n      state: \"error\",\n      message: {\n        role: \"agent\",\n        parts: [{ \n          type: \"text\", \n          text: \"I encountered an unexpected error while processing your request. Please try again later.\" \n        }]\n      }\n    };\n  }\n};\n\n// Simulate an async operation\nasync function someAsyncOperation(input: string): Promise&lt;string&gt; {\n  // Simulate processing delay\n  await new Promise(resolve =&gt; setTimeout(resolve, 1000));\n\n  // Simulate potential failure\n  if (input.toLowerCase().includes(\"fail\")) {\n    throw new Error(\"Operation failed\");\n  }\n\n  return `Processed: ${input.toUpperCase()}`;\n}\n\n// Create and start the server\nconst server = new A2AServer({\n  taskHandler: robustAgent,\n  taskStore: new InMemoryTaskStore(),\n  port: 4000,\n  basePath: \"/a2a\",\n  card: {\n    name: \"RobustAgent\",\n    url: \"http://localhost:4000/a2a\",\n    version: \"0.1.0\",\n    capabilities: { streaming: true },\n    skills: [{ id: \"robust\", name: \"Error-Resilient Processing\" }],\n  },\n});\n\nserver.start().then(() =&gt; {\n  console.log(\"Robust agent running at http://localhost:4000/a2a\");\n}).catch(err =&gt; {\n  console.error(\"Failed to start server:\", err);\n});\n</code></pre>"},{"location":"sdk/examples/#client-side-error-handling-and-retry-logic","title":"Client-Side Error Handling and Retry Logic","text":"<p>This example shows how to implement robust error handling and retry logic in client applications.</p> <pre><code>import { A2AClient, RpcError } from \"@artinet/sdk\";\n\n// Configuration\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY_MS = 1000;\nconst BACKOFF_FACTOR = 1.5;\n\nasync function robustClientRequest() {\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  const userMessage = {\n    role: \"user\",\n    parts: [{ type: \"text\", text: \"Process this data please\" }]\n  };\n\n  let retryCount = 0;\n  let delay = RETRY_DELAY_MS;\n\n  while (true) {\n    try {\n      console.log(`Attempt ${retryCount + 1} of ${MAX_RETRIES + 1}`);\n\n      // Send the request\n      const response = await client.sendTask({\n        id: `task-${Date.now()}`, // Generate unique ID\n        message: userMessage\n      });\n\n      // Success! Process the response\n      console.log(\"Request succeeded:\", response);\n\n      if (response.message?.parts[0]?.type === \"text\") {\n        console.log(\"Agent response:\", response.message.parts[0].text);\n      }\n\n      return response; // Success, exit the loop\n\n    } catch (error) {\n      // Handle different error scenarios\n      if (error instanceof RpcError) {\n        const { code, message, data } = error;\n\n        console.error(`RPC Error (${code}): ${message}`);\n\n        // Check if we should retry based on error type\n        if (\n          // Retry on server errors (5xx)\n          (code &gt;= 500 &amp;&amp; code &lt; 600) ||\n          // Retry on timeout\n          code === 408 ||\n          // Retry on rate limiting with backoff\n          code === 429\n        ) {\n          if (retryCount &lt; MAX_RETRIES) {\n            console.log(`Retrying in ${delay}ms...`);\n            await new Promise(resolve =&gt; setTimeout(resolve, delay));\n\n            // Increase delay with backoff\n            delay = Math.floor(delay * BACKOFF_FACTOR);\n            retryCount++;\n            continue; // Try again\n          }\n        }\n\n        // Don't retry client errors (4xx) except those handled above\n        if (code &gt;= 400 &amp;&amp; code &lt; 500) {\n          console.error(\"Client error, not retrying\");\n          throw error;\n        }\n      }\n\n      // For network errors or other issues\n      console.error(\"Request failed:\", error);\n\n      if (retryCount &lt; MAX_RETRIES) {\n        console.log(`Retrying in ${delay}ms...`);\n        await new Promise(resolve =&gt; setTimeout(resolve, delay));\n\n        // Increase delay with backoff\n        delay = Math.floor(delay * BACKOFF_FACTOR);\n        retryCount++;\n      } else {\n        console.error(`Maximum retries (${MAX_RETRIES}) exceeded`);\n        throw error; // Bubble up the error after max retries\n      }\n    }\n  }\n}\n\n// Run the robust client\nrobustClientRequest()\n  .then(result =&gt; {\n    console.log(\"Operation completed successfully\");\n  })\n  .catch(error =&gt; {\n    console.error(\"Operation failed after retries:\", error);\n  });\n</code></pre> <p>These examples provide a foundation for exploring the Artinet SDK's capabilities. They demonstrate common patterns and techniques for building robust, feature-rich A2A-compliant agents and client applications.</p>"},{"location":"sdk/quickstart/","title":"Quick Start Guide: Artinet SDK","text":"<p>This guide will help you get your first A2A-compliant agent up and running and show you how to interact with it.</p>"},{"location":"sdk/quickstart/#installation","title":"Installation","text":"<p>First, you need to install the Artinet SDK into your project. If you're using Node.js and npm, you can install it with the following command in your terminal:</p> <p><pre><code>npm install @artinet/sdk\n</code></pre> If you're using Yarn, you can use:</p> <pre><code>yarn add @artinet/sdk\n</code></pre>"},{"location":"sdk/quickstart/#1-creating-your-first-agent-server-side","title":"1. Creating Your First Agent (Server-Side)","text":"<p>An A2A-compliant agent is essentially a server that can perform tasks. Here's how to create a simple agent that echoes back any text it receives:</p> <pre><code>import {\n  A2AServer,\n  TaskContext,\n  TaskHandler,\n  InMemoryTaskStore,\n} from \"@artinet/sdk\";\n\n// Define the logic for your agent\n// This function is a 'TaskHandler'. It processes incoming tasks.\nconst echoAgentLogic: TaskHandler = async function* (context: TaskContext) {\n  // Extract text from the user's message\n  // (Assuming the message part is text)\n  const userInput =\n    context.userMessage.parts[0]?.type === \"text\"\n      ? context.userMessage.parts[0].text\n      : \"No text provided\";\n\n  // 1. Yield a 'working' state to indicate the task has started\n  yield { state: \"working\" };\n\n  // You could do more complex work here.\n  // For long tasks, you might periodically check `context.isCancelled()`\n\n  // 2. Yield a 'completed' state with the agent's response\n  yield {\n    state: \"completed\",\n    message: { // This is the agent's reply\n      role: \"agent\",\n      parts: [{ type: \"text\", text: `Your agent says: You sent '${userInput}'` }],\n    },\n  };\n};\n\n// Configure and create the A2A Server instance\nconst server = new A2AServer({\n  taskHandler: echoAgentLogic,          // The logic our agent will use\n  taskStore: new InMemoryTaskStore(),   // Stores task information (in memory for this example)\n  port: 4000,                           // The port your agent server will run on\n  basePath: \"/a2a\",                     // The base API path for your agent\n\n  // The 'card' provides metadata about your agent so others can discover it\n  card: {\n    name: \"EchoAgent\",\n    url: \"http://localhost:4000/a2a\", // How to reach this agent\n    version: \"0.1.0\",\n    capabilities: { streaming: true }, // Indicates this agent supports streaming updates\n    skills: [{ id: \"echo\", name: \"Echo Skill\" }], // Describes what the agent can do\n  },\n});\n\n// Start the server\nasync function main() {\n  try {\n    await server.start(); // Start listening for requests\n    console.log(\"EchoAgent server running at http://localhost:4000/a2a\");\n  } catch (error) {\n    console.error(\"Failed to start server:\", error);\n  }\n}\n\nmain();\n</code></pre>"},{"location":"sdk/quickstart/#key-concepts","title":"Key Concepts:","text":"<ul> <li>TaskHandler: This is the heart of your agent - an asynchronous generator function that processes incoming tasks and yields status updates.</li> <li>TaskContext: Contains information about the task, including the user's message and methods like <code>isCancelled()</code>.</li> <li>A2AServer: Creates and manages your agent server, handling protocol details automatically.</li> <li>AgentCard (in <code>card</code> parameter): Describes your agent's capabilities and how to reach it.</li> </ul>"},{"location":"sdk/quickstart/#2-interacting-with-your-agent-client-side","title":"2. Interacting with Your Agent (Client-Side)","text":"<p>Now that you have an agent server running, let's send it a task using the A2AClient:</p> <pre><code>import { A2AClient, Message } from \"@artinet/sdk\";\n\nasync function talkToAgent() {\n  // Create a client pointing to your running agent server\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  // Define the message you want to send to the agent\n  const userMessage: Message = {\n    role: \"user\", // Indicates the message is from a user\n    parts: [{ type: \"text\", text: \"Hello Artinet Agent!\" }], // The content of the message\n  };\n\n  try {\n    console.log(\"Sending message to agent...\");\n\n    // Send the task and wait for the final response\n    // 'sendTask' is good for tasks that have a single, final response.\n    const taskResponse = await client.sendTask({\n      id: \"my-echo-task-01\", // A unique ID for this task\n      message: userMessage,\n    });\n\n    console.log(\"Agent responded successfully!\");\n\n    // The final message from the agent is in taskResponse.message\n    if (taskResponse.message &amp;&amp; taskResponse.message.parts[0]?.type === \"text\") {\n      console.log(\"Agent's final reply:\", taskResponse.message.parts[0].text);\n    } else {\n      console.log(\"Agent's final response structure:\", taskResponse);\n    }\n\n  } catch (error) {\n    console.error(\"Error interacting with agent:\", error);\n  }\n}\n\ntalkToAgent();\n</code></pre>"},{"location":"sdk/quickstart/#key-concepts_1","title":"Key Concepts:","text":"<ul> <li>A2AClient: Connects to and interacts with A2A-compliant agent servers.</li> <li>Message: Structured format for communication, with a <code>role</code> and <code>parts</code> containing content.</li> <li>sendTask(): Sends a one-time request and waits for the final response.</li> </ul>"},{"location":"sdk/quickstart/#3-receiving-streaming-updates","title":"3. Receiving Streaming Updates","text":"<p>For long-running tasks or real-time updates, you can use the streaming API:</p> <pre><code>import { A2AClient, TaskStatusUpdateEvent } from \"@artinet/sdk\";\n\nasync function streamFromAgent() {\n  const client = new A2AClient(\"http://localhost:4000/a2a\");\n\n  const userMessage = {\n    role: \"user\",\n    parts: [{ type: \"text\", text: \"Process this data please\" }],\n  };\n\n  try {\n    // Use sendTaskSubscribe to get a stream of updates\n    const stream = client.sendTaskSubscribe({\n      id: \"streaming-task-01\",\n      message: userMessage,\n    });\n\n    // Process updates as they arrive\n    for await (const update of stream) {\n      if (\"status\" in update) {\n        const statusUpdate = update as TaskStatusUpdateEvent;\n        console.log(`Task status: ${statusUpdate.status.state}`);\n\n        if (statusUpdate.message?.parts[0]?.type === \"text\") {\n          console.log(`Agent says: ${statusUpdate.message.parts[0].text}`);\n        }\n      }\n    }\n\n    console.log(\"Stream completed\");\n  } catch (error) {\n    console.error(\"Error with streaming task:\", error);\n  }\n}\n\nstreamFromAgent();\n</code></pre>"},{"location":"sdk/quickstart/#4-running-the-examples","title":"4. Running the Examples","text":"<p>To run these examples:</p> <ol> <li>Save the server code as <code>myEchoAgent.ts</code></li> <li>Save the client code as <code>runClient.ts</code> or <code>streamClient.ts</code></li> <li>Run the server with <code>npx ts-node myEchoAgent.ts</code></li> <li>In another terminal, run the client with <code>npx ts-node runClient.ts</code></li> </ol>"},{"location":"sdk/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've built your first agent, you can:</p> <ul> <li>Explore more complex examples</li> <li>Learn about the core components of the SDK</li> <li>Add authentication to your agent's endpoints</li> <li>Implement persistent storage with <code>FileStore</code></li> <li>Create agents with advanced capabilities by integrating LLMs or other APIs</li> </ul> <p>The Artinet SDK provides a solid foundation for building sophisticated A2A-compliant agents with minimal boilerplate!</p>"}]}